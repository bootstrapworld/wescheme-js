{"version":3,"sources":["webpack:///wescheme-js.min.js","webpack:///webpack/bootstrap d9783c8208cd40031085","webpack:///./src/wescheme.js","webpack:///./src/lex.js","webpack:///./src/structures.js","webpack:///./src/runtime/types.js","webpack:///./src/runtime/js-numbers.js","webpack:///./src/runtime/jshashtable.js","webpack:///./src/parser.js","webpack:///./src/analyzer.js","webpack:///./src/modules.js","webpack:///./src/compiler.js"],"names":["wescheme","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Object","defineProperty","value","lex","parser","analyzer","compiler","compile","code","debug","arguments","length","undefined","lexemes","AST","parse","desugared","desugar","pinfo","analyze","local_bytecode","bytecode","window","plt","types","jsnums","isWhiteSpace","str","test","isDelim","x","Comment","txt","this","matchingDelims","y","otherDelim","throwError","Message","chewWhiteSpace","i","charAt","line","column","sexpToString","sexp","Array","map","toString","readProg","strSource","startCol","startRow","caseSensitiveSymbols","source","sexps","delims","readSExpByIndex","push","location","startChar","span","Location","iStart","endOfError","rightListDelims","ColoredPart","leftListDelims","readList","readString","readPoundSExp","readLineComment","quotes","readQuote","readSymbolOrNumber","readListItem","list","end","symbolExpr","val","dot2Idx","msg","dot1Idx","parent","processDots","slice","concat","handleError","e","exec","eLoc","JSON","errorLocation","Number","offset","innerError","openingDelim","closedString","greedy","chr","datum","regexp","hex2","hex4","hex8","match","String","fromCharCode","parseInt","oct3","strng","literal","string","throwUnsupportedError","errorStr","token","toLowerCase","unsupportedMatch","RegExp","unsupportedTest","badExtensionMatch","badExtensionTest","caseSensitiveMatch","caseSensitiveTest","vectorMatch","vectorTest","kind","base","replace","error","unsupportedExpr","trim","size","sizeChars","elts","len","Vector","poundChunk","chunk","nextChar","readChar","boxCall","readBlockComment","readSExpComment","matchUntilDelim","isFirstChar","special","hex6","comment","nextSExp","endChar","atom","eofError","action","symbol","unexpected","quotedSexp","quotedSpan","symOrNum","trailingEscs","unescaped","j","chunks","split","sizeOfLastChunk","strBeforeLastChunk","lastVerbatimMarkerIndex","filtered","reduce","acc","special_chars","escaped_nums","node","numValue","fromString","stx","message","theSource","endCol","endRow","start","toVector","vector","prototype","join","Date","getTime","console","log","Math","floor","loc","errorClass","rewritePart","part","text","type","locations","solid","locs","l","args","json","dom-message","structured-error","stringify","couple","first","second","defFunc","name","body","Program","defVar","expr","defVars","names","defStruct","fields","beginExpr","exprs","lambdaExpr","localExpr","defs","letrecExpr","bindings","letExpr","letStarExpr","condExpr","clauses","caseExpr","andExpr","orExpr","callExpr","func","ifExpr","predicate","consequence","alternative","whenUnlessExpr","Char","toWrittenString","quotedExpr","quoteLikePairP","v","shortName","lexeme","s","elementToString","unquotedExpr","quasiquotedExpr","unquoteSplice","requireExpr","spec","provideStatement","errorMsg","errorSpan","isExpression","isDefinition","moduleBinding","constantBinding","moduleSource","permissions","functionBinding","minArity","isVarArity","isCps","structBinding","constructor","accessors","mutators","env","that","makeHash","lookup","containsKey","get","peek","depth","emptyEnv","contains","keys","extend","binding","put","extendFunction","extendConstant","lookup_context","context","extendEnv_moduleBinding","reduceRight","values","b","unboundStackReference","unnamedEnv","localEnv","boxed","localStackReference","globalEnv","pos","indexOf","globalStackReference","levenshteinDistance","a","matrix","min","usedBindingsHash","freeVariables","gensymCounter","providedNames","definedNames","sharedExpressions","withLocationEmits","allowRedefinition","moduleResolver","modulePathResolver","currentModulePath","declaredPermissions","defaultModuleResolver","defaultModulePathResolver","defaultCurrentModulePath","isRedefinition","usedBindings","accumulateDeclaredPermission","permission","accumulateSharedExpression","expression","translation","labeledTranslation","makeLabeledTranslation","accumulateDefinedBinding","keywords","prevBinding","accumulateDefinedBindings","forEach","accumulateModuleBindings","accumulateModule","accumulateBindingUse","alreadyExists","accumulateFreeVariableUse","sym","gensym","label","onlyUnique","index","self","reducePermissions","filter","getExposedBindings","lookupProvideBindingInDefinitionBindings","provideBinding","ref","symbl","checkBindingCompatibility","provideBindingStructId","decorateWithPermissions","bindingEntry","entry","filteredPermissions","exportedBinding","getBasePinfo","language","baseConstantsEnv","topLevelEnv","topLevelModules","mod","mobyModuleBinding","heir","f","last","elt","makeLowLevelEqHash","knownModules","moduleGuess","wrongName","best","dist","distance","path","parentPath","parts","collectionName","knownCollections","_Hashtable","makeLParen","document","createElement","appendChild","createTextNode","className","makeRParen","child","hasOwnProperty","_eqHashCodeCounter","makeEqHashCode","getEqHashCode","_eqHashCode","UnionFind","parentMap","find","ptr","rep","merge","ptr1","ptr2","Class","initializing","fnTest","xyz","innerClass","prop","_super","fn","tmp","ret","apply","Dummy","init","callee","StructType","numberOfArgs","numberOfFields","firstField","accessor","mutator","isEqual","other","aUnionFind","makeStructureType","theName","parentType","initFieldCnt","autoFieldCnt","autoV","guard","Struct","numParentArgs","aStruct","initArgs","k","ValuesWrapper","cont","guardRes","guardedArgs","parentArgs","_fields","unshift","Symbol","makeInstance","constructorName","_constructorName","cache","buffer","toDisplayedString","toDomNode","RegularExpression","pattern","ByteRegularExpression","Path","Bytes","bts","mutable","bytes","set","copy","subbytes","escapeByte","aByte","returnVal","Box","unbox","newVal","boxSymbol","Logic","TRUE","FALSE","Boolean","valueOf","charCodeAt","numStr","toUpperCase","getValue","symbolCache","wrapper","style","fontFamily","whiteSpace","Keyword","keywordCache","Empty","EMPTY","reverse","Error","rest","isEmpty","append","Cons","r","lst","texts","explicitConsString","tails","abbr","explicitConsDomNode","topNode","restSpan","n","initialElements","toList","lVect","rVect","Str","chars","escapeString","substring","newStr","regexpr","replaceUnprintableStringChars","EqHashTable","inputHash","hash","keyStr","valStr","EqualHashTable","JsObject","obj","WorldConfig","startup","shutdown","startupArgs","shutdownArg","Effect","invokeEffect","helpers","raise","incompleteExn","exnFail","makeEffectType","superType","impl","caller","newType","lastFieldIndex","changeWorld","schemeChangeWorld","PrimProc","aState","worldUpdater","check","procArityContains","w","k2","interpret","VOID_VALUE","RenderEffect","callImplementation","makeRenderEffectType","remove","isNumber","numberToDomNode","textToDomNode","nodeType","newlineDiv","clear","isExact","isInteger","isRational","rationalToDomNode","isComplex","repeatingDecimalNode","toRepeatingDecimal","numerator","denominator","limit","firstPart","overlineSpan","textDecoration","fractionalNode","numeratorNode","denominatorNode","barNode","numberNode","showingRepeating","onclick","isSchemeNumber","isString","equals","ThreadCell","isPreserved","UndefinedValue","UNDEFINED_VALUE","VoidValue","EofValue","EOF_VALUE","ClosureValue","numParams","paramTypes","isRest","closureVals","format","CaseLambdaValue","closures","ContinuationClosureValue","vstack","cstack","PrefixValue","slots","definedMask","addSlot","UNDEFINED","GlobalBucket","srcloc","exnFailContractVariable","ModuleVariableRecord","resolvedModuleName","variableName","VariableReference","prefix","ContMarkRecordControl","dict","invoke","state","update","key","ContinuationMarkSet","dom","ContinuationPrompt","defaultContinuationPrompt","assignsToValueRegister","CasePrimitive","cases","toReturn","isMessage","o","isColoredPart","GradientPart","coloredParts","isGradientPart","resultArray","MultiPart","isMultiPart","makeList","result","makeVector","makeString","internalError","makeHashEq","newHash","makeHashEqual","NoLocation","isNoLocation","Posn","Color","ArityAtLeast","greaterThanOrEqual","rational","makeRational","makeFloat","complex","makeComplex","bignum","makeBignum","byteRegexp","box","boxImmutable","keyword","pair","hashEq","jsObject","posn","posnX","psn","posnY","color","g","colorRed","colorGreen","colorBlue","colorAlpha","arityAtLeast","arityValue","arity","isSymbol","isChar","isPair","isVector","isBox","isHash","isByteString","isStruct","isPosn","isArityAtLeast","isColor","isFunction","getProcedureType","isJsObject","cons","VOID","EOF","contMarkRecordControl","isContMarkRecordControl","continuationMarkSet","isContinuationMarkSet","isStructType","InternalError","contMarks","isInternalError","SchemeError","schemeError","isSchemeError","IncompleteExn","otherArgs","isIncompleteExn","Exn","exn","isExn","exnMessage","exnContMarks","exnSetContMarks","ExnBreak","exnBreak","isExnBreak","exnBreakContinuation","ExnFail","isExnFail","ExnFailContract","exnFailContract","isExnFailContract","ExnFailContractArity","exnFailContractArity","isExnFailContractArity","ExnFailContractVariable","isExnFailContractVariable","exnFailContractVariableId","ExnFailContractDivisionByZero","exnFailContractDivisionByZero","isExnFailContractDivisionByZero","ExnFailContractArityWithPosition","exnFailContractArityWithPosition","isExnFailContractArityWithPosition","exnFailContractArityWithPositionLocations","worldConfig","isWorldConfig","isEffectType","isEffect","isRenderEffectType","isRenderEffect","__PLTNUMBERS_TOP__","rationalRegexp","digits","matchComplexRegexp","radix","sign","maybeSign","digitsForRadix","expmark","expMarkForRadix","digitSequence","unsignedRational","noDecimal","decimalNumOnRight","decimalNumOnLeft","unsignedDecimal","unsignedRealNoExp","unsignedReal","unsignedRealOrSpecial","real","alt1","alt2","alt3","match1","match2","match3","digitRegexp","flonumRegexp","scientificPattern","exp_mark","throwRuntimeError","Exactness","defaultp","exactp","inexactp","fromStringRaw","exactness","mustBeANumberp","cMatch","Complex","fromStringRawNoComplex","aMatch","Rational","FloatPoint","nan","inf","neginf","NEGATIVE_ZERO","fMatch","integralPart","fractionalPart","parseFloat","sMatch","coefficient","exponent","multiply","expt","isOverflow","intAsExactp","integralPartValue","parseExactInt","fractionalNumerator","fractionalDenominator","pow","fractionalPartValue","divide","forceInexact","toInexact","floatAsInexactp","add","on","BigInteger","fromNumber","nbi","am1","am2","xl","xh","h","am3","int2char","BI_RM","intAt","BI_RC","bnpCopyTo","t","bnpFromInt","DV","nbv","fromInt","bnpFromString","fromRadix","mi","sh","DB","clamp","ZERO","subTo","bnpClamp","DM","bnToString","negate","toRadix","d","km","bnNegate","bnAbs","bnCompareTo","nbits","bnBitLength","bnpDLShiftTo","bnpDRShiftTo","max","bnpLShiftTo","bs","cbs","bm","ds","bnpRShiftTo","bnpSubTo","bnpMultiplyTo","abs","am","bnpSquareTo","bnpDivRemTo","q","pm","pt","copyTo","ts","ms","nsh","lShiftTo","ys","y0","yt","F1","F2","d1","FV","d2","dlShiftTo","compareTo","ONE","qd","drShiftTo","rShiftTo","bnMod","divRemTo","Classic","cConvert","cRevert","cReduce","cMulTo","multiplyTo","cSqrTo","squareTo","bnpInvDigit","Montgomery","mp","invDigit","mpl","mph","um","mt2","montConvert","montRevert","montReduce","u0","montSqrTo","montMulTo","bnpIsEven","bnpExp","z","r2","convert","sqrTo","mulTo","revert","bnModPowInt","isEven","exp","bnClone","bnIntValue","bnByteValue","bnShortValue","bnpChunkSize","LN2","bnSigNum","bnpToRadix","signum","cs","chunkSize","intValue","substr","bnpFromRadix","dMultiply","dAddOffset","bnpFromNumber","testBit","bitwiseTo","shiftLeft","op_or","isProbablePrime","bitLength","nextBytes","bnToByteArray","bnEquals","bnMin","bnMax","bnpBitwiseTo","op","op_and","bnAnd","bnOr","op_xor","bnXor","op_andnot","bnAndNot","bnNot","bnShiftLeft","bnShiftRight","lbit","bnGetLowestSetBit","cbit","bnBitCount","bnTestBit","bnpChangeBit","bnSetBit","changeBit","bnClearBit","bnFlipBit","bnpAddTo","bnAdd","addTo","bnSubtract","bnMultiply","bnDivide","bnRemainder","bnDivideAndRemainder","bnpDMultiply","bnpDAddOffset","NullExp","nNop","nMulTo","nSqrTo","bnPow","bnpMultiplyLowerTo","bnpMultiplyUpperTo","Barrett","q3","mu","barrettConvert","barrettRevert","barrettReduce","multiplyUpperTo","multiplyLowerTo","barrettSqrTo","barrettMulTo","bnModPow","k1","g2","is1","bnGCD","clone","getLowestSetBit","bnpModInt","bnModInverse","ac","u","subtract","bnIsProbablePrime","lowprimes","lplim","modInt","millerRabin","bnpMillerRabin","n1","shiftRight","modPow","modPowInt","temporaryAccuracyLosingWorkAroundForBigNums","function_name","inexact","Numbers","makeNumericBinop","onFixnums","onBoxednums","options","isXSpecialCase","onXSpecialCase","isYSpecialCase","onYSpecialCase","liftFixnumInteger","level","liftTo","fromFixnum","isNaN","isFinite","nf","expandExponent","mantissaChunks","zfill","onThrowRuntimeError","thing","isReal","isInexact","isExactInteger","toFixnum","toExact","sum","addSlow","_integerIsZero","diff","prod","multiplySlow","_integerIsOne","_integerIsNegativeOne","div","eqv","realPart","imaginaryPart","ex","ey","approxEquals","delta","lessThan","lessThanOrEqual","greaterThan","_expt","modulo","_integerModulo","sqrt","ceiling","conjugate","magnitude","angle","pi","tan","atan","cos","sin","acos","asin","round","sqr","integerSqrt","gcd","lcm","divisor","_integerGcd","quotient","_integerQuotient","remainder","_integerRemainder","cosh","sinh","makeComplexPolar","theta","isSchemeNumberFinite","MIN_FIXNUM","MAX_FIXNUM","halve","timesI","plusI","fastExpt","makeIntegerBinop","onBignums","doNotCoerseToFloating","makeIntegerUnOp","NEGATIVE_ONE","_integerAdd","_integerSubtract","_integerMultiply","_integerDivideToFixnum","ignoreOverflow","_integerEquals","_integerGreaterThan","_integerLessThan","_integerGreaterThanOrEqual","_integerLessThanOrEqual","target","newN","newD","halfintp","negativep","quo","rem","NaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","TOO_POSITIVE_TO_REPRESENT","TOO_NEGATIVE_TO_REPRESENT","INEXACT_ZERO","PI","E","Infinity","stringRep","tenToDecimalPlaces","partialResult","afterDecimal","factorToInt","extraFactor","multFactor","ceil","imagPart","con","up","down","r_plus_x","minusI","iz","iz_negate","z2","exp_negate","expo","cos_a","sin_a","pi_half","root","oneNegateThisSq","sqrtOneNegateThisSq","hashModifiersRegexp","def","off","dbits","hMatch","modifierString","exactFlag","radixFlag","numberString","canary","j_lm","navigator","appName","BI_FP","rr","vv","byteValue","shortValue","toByteArray","and","or","xor","andNot","not","bitCount","setBit","clearBit","flipBit","divideAndRemainder","modInverse","fixrep","quotientAndRemainder","searchIter","guess","fix","approx","getResidue","seenRemainders","nextDigit","nextRemainder","firstRepeatingRemainder","repeatingDigits","digitString","repeatingDigitString","beforeDecimalPoint","afterDecimals","_1","_2","_3","_4","_5","_6","_7","_8","_9","_a","_b","_c","_d","_e","_f","_10","hashCode","_11","_12","_13","_14","_15","_16","_17","o1","o2","_1a","arr","_1c","_1d","_1e","_1f","_20","_23","idx","splice","_26","_29","kv","_2b","_2e","_2c","_30","_31","_2d","_32","_33","_34","_35","entries","addEntry","getEqualityFunction","_36","_37","_38","_39","_4c","_4d","_4e","_4f","_50","_51","_52","_53","_54","_55","_56","_57","_58","_59","_5a","_5b","_5d","_5e","_5f","_60","getEntryForKey","_61","_63","_64","_65","_67","_68","containsValue","_69","_6c","_6f","_73","_74","removeEntryForKey","_75","_76","_3a","searchForEntry","getEntryIndexForKey","_3f","_41","_42","_43","_46","_47","_4b","isLiteral","isUnsupported","isSymbolEqualTo","isCons","ls","parseStar","parseSExp","parseDefinition","isExpr","parseExpr","isRequire","parseRequire","isProvide","parseProvide","isStructDefinition","isValueDefinition","isMultiValueDefinition","parseDefStruct","arg","extraLocs","wording1","wording2","parseIdExpr","parseMultiDef","wording","parseDef","parseExprList","parseExprSingleton","parseFuncCall","parseLambdaExpr","parseLocalExpr","parseLetrecExpr","sexpIsCouple","parseBinding","parseLetExpr","parseLetStarExpr","parseIfExpr","parseBeginExpr","parseAndExpr","parseOrExpr","orEx","parseQuotedExpr","parseQuotedItem","parseCondExpr","parseCaseExpr","parseWhenUnlessExpr","parseQuasiQuotedExpr","parseUnquoteExpr","parseUnquoteSplicingExpr","isElseClause","checkCondCouple","clause","clauseLocations","condLocs","parseCondCouple","cpl","isClause","numClauses","parsedClauses","checkCaseCouple","caseLocs","parseCaseCouple","parseQuasiQuotedItem","res","quoted","parseVector","buildZero","lit","unParsedVector","vals","vectorFunc","buildVector","singleton","partsNum","partsStr","req","provide","checkDuplicateIdentifiers","visitedIds","tagApplicationOperator_Module","application","moduleName","forceBooleanContext","boolExpr","verifyCall","stxQuote","locQuote","boolLocQuote","runtimeCall","desugarProgram","programs","isTopLevelExpr","desugaredAndPinfo","printValues","printCall","desugarQuasiQuotedList","qqlist","desugarQuasiQuotedListElement","element","argument","listSym","listCall","appendArgs","appendSym","appendCall","bf","modulePath","vararity","provideBindingId","analyzeClosureUses","funcExpr","oldEnv","oldKeys","newBindings","newEnv","analyzeUses","programAnalyzeWithPinfo","collectDefinitions","collectProvides","pinfo1","pinfo2","bodyAndPinfo","newDefFunc","exprAndPinfo","newDefVar","newDefVars","makeAccessorDefn","makeFieldFunc","makeFieldArgs","makeFieldCall","accessorSymbol","defineVar","stxs","ids","idSymbols","makeStructTypeFunc","makeStructTypeArgs","makeStructTypeCall","defineValuesStx","exprsAndPinfo","newBeginExpr","newLambdaExpr","defnsAndPinfo","newLocalExpr","newCallExpr","newIfExpr","begin_exp","void_exp","call_exp","if_exp","bindingToDefn","localAndPinfo","coupleFirst","coupleSecond","lambda","bindingToLet","let_exp","condExhausted","exhaustedLoc","ifStx","processClause","ormapStx","callStx","predicateStx","caseStx","pinfoAndValSym","updatedPinfo1","valStx","pinfoAndXSym","updatedPinfo2","xStx","voidStx","lastClause","pop","equalStx","equalTestStx","letExp","desugarAndExprs","ifLink","ifChain","desugarOrExprs","firstExpr","pinfoAndTempSym","firstExprSym","notOriginalSource","secondExpr","tmpBinding","orStx","secondExprAndPinfo","desugarQuotedItem","uSym","listArgs","usSym","qqSym","fieldToAccessor","fieldToMutator","constructorId","predicateId","selectorIds","mutatorIds","structNameLoc","structureBinding","constructorBinding","predicateBinding","mutatorBinding","refBinding","getWeSchemeModule","throwModuleError","bestGuess","processModule","provides","COLLECTIONS","strToBinding","imported","provideBindings","modulebinding","newPinfo","url","protocol","host","jQuery","ajax","success","program","eval","src","objectCode","async","addProvidedName","collectProvidesFromClause","fns","pinfoAfterDefs","exps","bindingLoc","ASTandPinfo","makeFunctionBinding","kernelMiscModule","foreignModule","worldEffectsModule","worldHandlersModule","bootstrapTeachpackFunctions","bootstrapTeachpack","bootstrapTeachpack2011","bootstrapTeachpack2012","bootstrapTiltTeachpack2012","bootstrapTeachpack2014","bootstrapTiltTeachpack2014","bootstrapTeachpack2015","bootstrapTiltTeachpack2015","cageTeachpack","cageTeachpack2011","cageTeachpack2012","cageTeachpack2014","functionTeachpack","functionTeachpack2011","functionTeachpack2012","functionTeachpack2014","functionTeachpack2015","locationModule","tiltModule","telephonyModule","netModule","parserModule","jsWorldModule","worldModule","needsPermission","topLevelModule","stackReference","isBoxed","convertToBytecode","bc","toBytecode","escapeSym","symName","bcStr","escapes","globalBucket","Bytecode","moduleVariable","modidx","phase","$","wrap","wrapped","wraps","certs","encoded","numLifts","topLevels","form","indirect","compilationTop","maxLetDepth","provided","srcName","nomSrc","srcPhase","isProtected","insp","topLevel","constant","ready","seq","forms","defValues","rhs","defSyntaxes","defForSyntax","selfModidx","requires","syntaxBody","unexported","dummy","langInfo","internalContext","lam","operatorAndRandLocs","flags","closureMap","closureTypes","closure","genId","caseLam","letOne","flonum","letVoid","count","boxes","letRec","procs","installValue","boxEnv","localRef","otherClears","topSyntax","midpt","rator","rands","branch","testExpr","thenExpr","elseExpr","withContMark","beg0","varRef","assign","undefOk","applyValues","proc","primVal","reqs","reqBytecode","lexicalRename","bool1","bool2","alist","phaseShift","amt","dest","wrapMark","prune","allFromModule","exceptions","nominalPath","simpleNominalPath","phasedModuleBinding","exportName","nominalExportName","exportedNominalModuleBinding","nominalModuleBinding","exportedModuleBinding","simpleModuleBinding","ModuleRename","setId","unmarshals","renames","markRenames","plusKern","sortAndUnique","equalTo","unique","convertedSortFn","sort","compilePrograms","bytecodes","compiledProgramAndPinfo","compiledProgram","compileCompilationTop","makeModulePrefixAndEnv","requiredModuleBindings","isNotRequiredModuleBinding","moduleOrTopLevelDefinedBindings","allModuleBindings","makeGlobalBucket","modulePathIndexJoin","makeModuleVariablefromBinding","globalNames","uniqueGlobalNames","globals","toplevelPrefixAndEnv","toplevelPrefix","defns","compiledRequiresAndPinfo","compiledRequires","compiledDefinitionsAndPinfo","compiledDefinitions","compiledExpressionsAndPinfo","compiledExpressions","zo_bytecode","response","num","pushLocalBoxedFromSym","pushLocalFromSym","updatedEnv","freeVarsInBody","addFreeVarsInDef","envWithArgs","compiledFunNameAndPinfo","compiledFunName","compiledLambdaAndPinfo","compiledLambda","compiledIdAndPinfo","compiledId","compiledExprAndPinfo","compiledExpr","compiledIdsAndPinfo","compiledIds","compiledBodyAndPinfo","compiledBody","isUnnamedLambda","maskUnusedGlobals","listOfNames","namesToKeep","pushLocal","pushLocalBoxed","pushGlobals","getClosureVectorAndEnv","originalEnv","freeVariableRefs","ormap","isLocalStackRef","isGlobalStackRef","isUnboundStackRef","getDepthFromRef","anyUnboundStackRefs","lexicalFreeRefs","lexicalFreeDepths","globalRefs","globalDepths","env1","env2","env3","refsAtDepth","usedGlobals","newGlobals","closureVectorAndEnv","closureVector","extendedEnv","getLocs","getDefinedNames","processDefns","numInstalled","envWithBoxedNames","compiledDefAndPInfo","compiledRhs","numToInstall","newBodyAndPinfo","newBody","letVoidBodyAndPinfo","letVoidBody","makeSpace","operand","compiledOperatorAndPinfo","compiledOperator","compiledOperandsAndPinfo","compiledOperands","app","extractLoc","locVectors","appWithcontMark","compiledPredicateAndPinfo","compiledPredicate","compiledConsequenceAndPinfo","compiledConsequence","compiledAlternateAndPinfo","compiledAlternate","pinfo3","unwrapLiterals"],"mappings":"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i+C,EAAA,gCACAe,EAAA,GAAA5xC,GAAA,iCACA,eAAApN,IAAAi+C,EAAA,oCACAgB,EAAA,GAAA7xC,GAAA,iCACA,eAAApN,IAAAi+C,EAAA,oCACAiB,EAAA,GAAA9xC,GAAA,iCACA,eAAApN,IAAAi+C,EAAA,oCAGAkB,EAAA,GAAA/xC,GAAA,iCACA,eAAApN,IAAAi+C,EAAA,oCACAmB,EAAA,GAAAhyC,GAAA,qCACA,eAAApN,IAAAi+C,EAAA,wCACAoB,EAAA,GAAAjyC,GAAA,qCACA,eAAApN,IAAAi+C,EAAA,wCACAqB,EAAA,GAAAlyC,GAAA,qCACA,eAAApN,IAAAi+C,EAAA,wCACAsB,EAAA,GAAAnyC,GAAA,qCACA,eAAApN,IAAAi+C,EAAA,wCAGAuB,EAAA,GAAApyC,GAAA,aACA,sDACA,uDACA,sDACA,qDACA,mDACA,2DACApN,IAAAi+C,EAAA,wBAIAwB,EAAA,GAAAryC,GAAA,SACA,wDACA,wDACA,wDACA,iDACA,+CACA,8CACApN,IAAAi+C,EAAA,iBAIAyB,EAAA,GAAAtyC,GAAA,cACA,8DACApN,IAAAi+C,EAAA,gBAIA0B,EAAA,GAAAvyC,GAAA,QACA,iDACApN,IAAAi+C,EAAA,gBAIA2B,EAAA,GAAAxyC,GAAA,WACA,qBACApN,IAAAi+C,EAAA,mBAIA4B,EAAA,GAAAzyC,GAAA,YACA,qBACA,kBACA,gBACA,cACA,mBACA,oBACA,iBACA,iBACA,mBACA,gDACApN,IAAAi+C,EAAA,oBAIA6B,EAAA,GAAA1yC,GAAA,QACAixC,EAAAnzC,SAAA3I,OAAA67C,EAAAlzC,UACA,QACA,aACA,UACA,WAEA,aACA,SACA,YACA,cACA,aACA,cAEA,cACA,cACA,aACA,YACA,cACA,oBACA,cACA,SACA,OACA,UACA,cACA,eACA,eACA,YACA,kBACA,UACA,SACA,WACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,iBACA,qBACA,UACA,OACA,WACA,UACA,aACA,gBACA,WACA,cACA,iBACA,SACA,eACA,QACA,cACA,SACA,QACA,WACA,OACA,QACA,kBACA,gBACA,OACA,YACA,YACA,YACA,aACA,YACA,iBACA,SACA,UACA,cACA,eAGA,eACA,UAEA,oBACA,oBACA,qBAEA,iBACA,QACA,eACA,cACA,WACA,WACA,SACA,cACA,eACAlL,IAAA,SAAA4O;AACA,GAAAmxC,IAAA,uDACAxyC,EAAAwyC,EAAAlwC,QAAAjB,GAAA,qCACA,WAAAvB,GAAAuB,EAAA,eAAArB,GAAA,OAKAyyC,EAAA,GAAA5yC,GAAA,kBACA,WACA,YACA,WACA,WACA,YAEA,SACA,qBACA,YACA,WACA,gBACA,gBACA,cACA,gBACA,eACA,gBACA,gBACA,kBACA,eACA,YACA,UACA,WACA,WACA,YACA,WACA,cACA,cACA,eACA,gBACA,UACA,WACA,kBACA,YACA,qBACA,aACA,UACA,WACA,YACA,aACA,gBACA,qBACA,eACA,oBACA,mBACA,eACA,aACA,UACA,gBACA,iBACA,uBACA,aACA,aACA,aACA,gBACA,cACA,gBACA,WACA,gBACA,aACA,gBACA,gBACA,YACA,YACA,UACA,UACA,WAEA,UACA,WACA,WACA,UACA,YAEA,WACA,WACA,WACA,WAGA,UACA,aACA,eACA,gBAGA,qBACA,eACA,cAGA,gBACA,WACA,WACA,YACA,YACA,YACA,WACA,YACA,aACA,YACA,WACA,UACA,YACA,YACA,WACA,UACA,YACA,YACA,WACA,YACA,YACA,WACA,aACA,aACA,cACA,eACA,eACA,aACA,aACA,cACA,WACA,WACA,YACA,YACA,WACA,cACA,YACA,aACA,YACA,aACA,YACA,YACA,cACA,aAQA,UACA,YACA,eACA,WAGA,gBACA,aACA,aACA,YAGA,oBACA,uBACA,oBACA,mBACA,mBACA,oBACA,mBACA,oBACA,uBACA,oBACA,kBACA,uBACA,uBACA,iBACA,gBACA,gBACA,iBACA,gBACA,YAGA,gBACA,mBACA,kBACA,gBACA,gBACA,mBACA,qBACA,qBACA,yBACA,uBACA,sBACA,qBACA,qBACA,sBACA,qBACA,kBACA,oBACA,yBACA,sBACA,iBACA,yBACA,yBACA,mBACA,kBACA,kBACA,mBACA,kBACA,cACA,gBACA,iBACA,kBACA,kBACA,cACA,cAGA,kBAGA,SACA,UACA,aACA,cACA,WACA,YAEA,eACA,cACA,sBAGA,gBACA,eACA,aACA,aACA,iBACA,mBACA,iBACA,aACA,eACA,eACA,aACA,kBACA,WACA,eACA,iBACA,gBACA,WAEA,cAGA,iBAGA,mBAEA,qBACA,gBACA,oBACA,iBACA,kBACA,mBACA,mBACA,cAEA,gBACA,cACA,YACA,cACA,cACA,sBAMA,mBACA,cACA,mBACA,kBACA,kBACA,gBACA,gBACA,eACA,mBACA,eACA,oBACA,YAGA,YAGA,iBAGA,gBAGA,0BACA,oCACA,mCAIA,oCACA,qCAGA,yBACA,yBACA,+BACA,gCACA,gBACA,6BACA,sBAEA,uBAEA,mBACA,uBACA,iBACA,gBACA,sBAEA,2BACA,sBACA,kBACA,8BACA,+BAEA,0BACA,iBACA,4BAEA,iCACA,0BACA,qBAKA,iCAMA,gBACA,eACA,sCAEA,kBACA,qBACA,gCACApN,IAAAi+C,EAAA,oBAKAz/C,KAAAjB,SAAAsW,iBAAAmsC,EAAA9B,EAAA,CAAA2B,EAAAC,GACAthD,IAAAjB,SAAAwX,kBAAA,6EAGAvW,IAAAjB,SAAA8W,cAAA6pC,EACA2B,EACA1B,EACA2B,EACAvB,EACAC,EACAC,EACAE,EACAE,EACAH,EACAE,EACAE,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAI,MAGAtjD,EAAAD,QAAA+B,IAAAjB,UVqrVM,SAASb,EAAQD,EAASH,GW10WhCA,EAAA,EACA,IAAAoC,GAAApC,EAAA,GACAmC,EAAAnC,EAAA,EAGAiC,QAAAC,IAAAD,OAAAC,QACAA,IAAAjB,SAAAiB,IAAAjB,aAWA,WAmEA,QAAA0iD,MACA,QAAAvwC,GAAAvF,EAAA+1C,EAAA3xC,GACA0xC,EAAApjD,KAAAqC,MACAA,KAAAiL,OACAjL,KAAAghD,UACAhhD,KAAAqP,QA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","file":"wescheme-js.min.js","sourcesContent":["var wescheme =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar lex = __webpack_require__(1);\n\tvar parser = __webpack_require__(6);\n\tvar analyzer = __webpack_require__(7);\n\tvar compiler = __webpack_require__(9);\n\t\n\tvar compile = exports.compile = function compile(code) {\n\t  var debug = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t\n\t  var lexemes = lex.lex(code, 'foo', debug);\n\t  var AST = parser.parse(lexemes);\n\t  var desugared = analyzer.desugar(AST)[0]; // includes [AST, pinfo]\n\t  var pinfo = analyzer.analyze(desugared);\n\t  var local_bytecode = compiler.compile(desugared, pinfo);\n\t  return local_bytecode.bytecode;\n\t};\n\t\n\texports.default = compile;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t// if not defined, declare the compiler object as part of plt\n\twindow.plt   = window.plt || {};\n\tplt.compiler = __webpack_require__(2);\n\tvar types = __webpack_require__(3);\n\tvar jsnums = __webpack_require__(4);\n\t\n\t/*\n\t \n\t Follows WeScheme's current implementation of Advanced Student\n\t http://docs.racket-lang.org/htdp-langs/advanced.html\n\t\n\t NOT SUPPORTED BY MOBY, WESCHEME, OR THIS COMPILER: define-datatype, begin0, set!, time, delay, shared, recur,\n\t    match, check-member-of, check-range, (require planet), byetstrings (#\"Apple\"),\n\t    regexps (#rx or #px), hashtables (#hash), graphs (#1=100 #1# #1#), #reader and #lang\n\t \n\t \n\t TODO\n\t - JSLint\n\t - convert Location structs to use those from the Pyret lexer\n\t */\n\t\n\t//////////////////////////////////////////////////////////////////////////////\n\t////////////////////////////////// LEXER OBJECT //////////////////////////////\n\t//////////////////////////////////////////////////////////////////////////////\n\t\n\t// Parse a program into SExps\n\t//\n\t// A SExp is either:\n\t// - Literal x Location\n\t// - symbolExpr x Location\n\t// - [ListOf SExp] x Location\n\t//\n\t// A Literal is either:\n\t// - types.<number>\n\t// - types.string\n\t// - types.char\n\t// - types.vector\n\t\n\t    /////////////////////\n\t    /*      Data       */\n\t    /////////////////////\n\t\n\t(function () {\n\t    'use strict';\n\t\n\t    // import frequently-used bindings\n\t    var literal         = plt.compiler.literal;\n\t    var symbolExpr      = plt.compiler.symbolExpr;\n\t    var unsupportedExpr = plt.compiler.unsupportedExpr;\n\t    var throwError      = plt.compiler.throwError;\n\t\n\t    // a collection of common RegExps\n\t    var leftListDelims  = /[(\\u005B\\u007B]/,\n\t        rightListDelims = /[)\\u005D\\u007D]/,\n\t        matchUntilDelim = /^[^(\\u005B\\u007B)\\u005D\\u007D\\s]+/,\n\t        quotes          = /[\\'`,]/,\n\t        hex2            = new RegExp(\"^([0-9a-f]{1,2})\", \"i\"),\n\t        hex4            = new RegExp(\"^([0-9a-f]{1,4})\", \"i\"),\n\t        hex6            = new RegExp(\"^([0-9a-f]{1,6})\", \"i\"),\n\t        hex8            = new RegExp(\"^([0-9a-f]{1,8})\", \"i\"),\n\t        oct3            = new RegExp(\"^([0-7]{1,3})\", \"i\");\n\t\n\t    // the delimiters encountered so far, line and column, and case-sensitivity\n\t    var delims, line, column, startCol, startRow, source, caseSensitiveSymbols, i;\n\t    // UGLY HACK to track index if an error occurs. We should remove this if we can make i entirely stateful\n\t    var endOfError;\n\t                            \n\t    // the location struct\n\t    // endCol and endRow are included for pyret error location\n\t    var Location = function(startCol, startRow, startChar, span, theSource){\n\t      this.startCol   = startCol;   // starting index into the line\n\t      this.startRow   = startRow;   // starting line # (1-index)\n\t      this.startChar  = startChar;  // ch index of lexeme start, from beginning\n\t      this.span       = span;       // num chrs between lexeme start and end\n\t      this.source     = theSource || source; // [OPTIONAL] id of the containing DOM element\n\t                            \n\t      this.endCol     = column;     // ending index into the line\n\t      this.endRow     = line;       // ending index into the line\n\t      this.endChar    = startChar+span;      // ch index of lexeme end, from beginning\n\t                            \n\t      this.start      = function(){ return new Location(\"\", \"\", this.startChar, 1); };\n\t      this.end        = function(){ return new Location(\"\", \"\", this.startChar+this.span-1, 1); };\n\t      this.toString   = function(){\n\t        return \"Loc(\"+this.startCol+\", \"+this.startRow+\", \"+(this.startChar+1)+\",\"+this.span+\")\";\n\t      };\n\t      this.toVector = function(){\n\t        return new types.vector(['\"'+this.source+'\"' // add quotes to the source, since it's a str (not a symbol)\n\t                                ,this.startChar+1\n\t                                ,this.startRow\n\t                                ,this.startCol\n\t                                ,this.span]);\n\t      };\n\t      this.toString = function(){\n\t        return {line: this.startRow.toString(), id: this.source, span: this.span.toString(),\n\t               offset: (this.startChar+1).toString(), column: this.startCol.toString()};\n\t      };\n\t    };\n\t\n\t    /////////////////////\n\t    /* Utility Methods */\n\t    /////////////////////\n\t                   \n\t    // some important string methods\n\t    function isWhiteSpace(str) {\n\t      return (/\\s/).test(str);\n\t    }\n\t\n\t    // determines if a character string is in one of the three sets of delimiters\n\t    function isDelim(x) {\n\t      return x === '(' || x === ')'\n\t        ||   x === '[' || x === ']'\n\t        ||   x === '{' || x === '}';\n\t    }\n\t\n\t    // this is returned when a comment is read\n\t    function Comment(txt) {this.txt = txt;}\n\t\n\t    // determines if the character is valid as a part of a symbol\n\t    function isValidSymbolCharP(x) {\n\t      return !isDelim(x) && !isWhiteSpace(x)\n\t            && x !== '\"' && x !== ',' && x !== \"'\"\n\t                        && x !== '`' && x !== ';';\n\t    }\n\t\n\t    // determines if they are matching delimiter pairs\n\t    // ie ( and ) [ and ] { and }\n\t    function matchingDelims(x, y) {\n\t      return (x === '(' && y === ')')\n\t        ||   (x === '[' && y === ']')\n\t        ||   (x === '{' && y === '}');\n\t    }\n\t\n\t    // gets the matching delim given the other delim in a pair\n\t    function otherDelim(x) {\n\t      return  x === '(' ? ')' :\n\t              x === '[' ? ']' :\n\t              x === '{' ? '}' :\n\t              x === ')' ? '(' :\n\t              x === ']' ? '[' :\n\t              x === '}' ? '{' :\n\t    /* else */ throwError(new types.Message([\"otherDelim: Unknown delimiter: \", x]));\n\t    }\n\t\n\t    // reads through whitespace\n\t    function chewWhiteSpace(str, i) {\n\t      var p;\n\t      if(i < str.length) {\n\t        p = str.charAt(i);\n\t        while (isWhiteSpace(p) && i < str.length) {\n\t          // increment column/line counters\n\t          if(p===\"\\n\"){ line++; column = 0;}\n\t          else { column++; }\n\t          p = str.charAt(++i);\n\t        }\n\t      }\n\t      return i;\n\t    }\n\t\n\t    Array.prototype.toString = function () {return this.join(\" \"); };\n\t    function sexpToString(sexp) {\n\t      return (sexp instanceof Array)? \"(\" + sexp.map(sexpToString).toString() + \")\"\n\t                                    : sexp.toString();\n\t    }\n\t\n\t                   \n\t    /////////////////////\n\t    /* Primary Methods */\n\t    /////////////////////\n\t\n\t    // readProg : String String -> SExp\n\t    // reads multiple sexps encoded into this string and converts them to a SExp\n\t    // datum\n\t    function readProg(str, strSource) {\n\t      var i = 0; startCol = column = 0; startRow = line = 1, // initialize all position indices\n\t          caseSensitiveSymbols = true;                // initialize case sensitivity\n\t      source = strSource || \"<definitions>\";\n\t      var sexp, sexps = [];\n\t      delims = [];\n\t      // get rid of any whitespace at the start of the string\n\t      i = chewWhiteSpace(str, 0);\n\t      while(i < str.length) {\n\t        sexp = readSExpByIndex(str, i);\n\t        if(!(sexp instanceof Comment)) { sexps.push(sexp); }\n\t        i = chewWhiteSpace(str, sexp.location.startChar+sexp.location.span);\n\t      }\n\t      sexps.location = new Location(startCol, startRow, 0, i, source);\n\t      return sexps;\n\t    }\n\t\n\t    // readSSFile : String String -> SExp\n\t    // removes the first three lines of the string that contain DrScheme meta data\n\t    function readSSFile(str, strSource) {\n\t      var i = 0; startCol = column = 0; startRow = line = 1, // initialize all position indices\n\t          caseSensitiveSymbols = true;                // initialize case sensitivity\n\t      source = strSource || \"<definitions>\";\n\t      var crs = 0;\n\t\n\t      while(i < str.length && crs < 3) {\n\t        if(str.charAt(i++) === \"\\n\") { crs++; }\n\t      }\n\t\n\t      var sexp, sexps = [];\n\t      delims = [];\n\t      while(i < str.length) {\n\t        sexp = readSExpByIndex(str, i);\n\t        if(!(sexp instanceof Comment)) { sexps.push(sexp); }\n\t        i = chewWhiteSpace(str, sexp.location.startChar+sexp.location.span);\n\t      }\n\t      return sexps;\n\t    }\n\t\n\t    // readSExp : String String -> SExp\n\t    // reads the first sexp encoded in this string and converts it to a SExp datum\n\t    function readSExp(str, source) {\n\t      delims = [];\n\t      var sexp = readSExpByIndex(str, 0);\n\t      return sexp instanceof Comment ? null : sexp;\n\t    }\n\t\n\t    // readSExpByIndex : String Number -> SExp\n\t    // reads a sexp encoded as a string starting at the i'th character and converts\n\t    // it to a SExp datum\n\t    function readSExpByIndex(str, i) {\n\t      startCol = column; startRow = line; var iStart = i;\n\t      i = chewWhiteSpace(str, i);\n\t      var p = str.charAt(i);\n\t      if(i >= str.length) {\n\t        endOfError = i; // remember where we are, so readList can pick up reading\n\t        throwError(new types.Message([source , \":\"\n\t                                      , startRow.toString(), \":\"\n\t                                      , (startCol-1).toString()\n\t                                      , \": read: (found end-of-file)\"])\n\t                   ,new Location(startCol-1, startRow, i-2, 2) // back up the startChar before #;, make the span include only those 2\n\t                   ,\"Error-GenericReadError\");\n\t      }\n\t      var sexp = rightListDelims.test(p) ?\n\t                   throwError(new types.Message([\"read: expected a \", otherDelim(p), \" to open \"\n\t                                                , new types.ColoredPart(p, new Location(column, startRow, iStart, 1))])\n\t                              ,new Location(column, startRow, iStart, 1)) :\n\t                 leftListDelims.test(p) ? readList(str, i) :\n\t                 p === '\"'                  ? readString(str, i) :\n\t                 p === '#'                  ? readPoundSExp(str, i) :\n\t                 p === ';'                  ? readLineComment(str, i) :\n\t                 quotes.test(p)             ? readQuote(str, i) :\n\t                  /* else */                   readSymbolOrNumber(str, i);\n\t       return sexp;\n\t    }\n\t                            \n\t    // readList : String Number -> SExp\n\t    // reads a list encoded in this string with the left delimiter at index i\n\t    function readList(str, i) {\n\t      var startCol=column, startRow=line, iStart=i, innerError=false,\n\t          errorLocation = new Location(startCol, startRow, iStart, 1),\n\t          openingDelim = str.charAt(i++),\n\t          dot1Idx=false, dot2Idx = false; // indices of the dot operator\n\t      column++; // move forward to count the closing delimeter\n\t      var sexp, list = [];\n\t      delims.push(openingDelim);\n\t      i = chewWhiteSpace(str, i);\n\t         \n\t      // read a single list item\n\t      // To allow optimization in v8, this function is broken out into its own (named) function\n\t      // see http://www.html5rocks.com/en/tutorials/speed/v8/#toc-topic-compilation\n\t      function readListItem(str, i, list){\n\t        var sexp = readSExpByIndex(str, i);       // read the next s-exp\n\t        i = sexp.location.end().startChar+1;         // move i to the character at the end of the sexp\n\t        // if it's a dot, treat it as a cons\n\t        if(sexp instanceof symbolExpr && sexp.val == '.'){\n\t          if(dot2Idx){\n\t            var msg = new types.Message([\"A syntax list may have only 2 `.'s\"]);\n\t            throwError(msg, list[dot1Idx].location);\n\t          }\n\t          dot2Idx = dot1Idx? list.length : false; // if we've seen dot1, save this idx to dot2Idx\n\t          dot1Idx = dot1Idx || list.length;       // if we haven't seen dot1, save this idx to dot1Idx\n\t        }\n\t        if(!(sexp instanceof Comment)){            // if it's not a comment, add it to the list\n\t          sexp.parent = list;                     // set this list as it's parent\n\t          list.push(sexp);                        // and add the sexp to the list\n\t        }\n\t        return i;\n\t      }\n\t                            \n\t      // if we have one dot, splice the element at that idx into the list\n\t      // if we have two dots, move the element they surround to the front\n\t      // throw errors for everything else\n\t      function processDots(list, dot1Idx, dot2Idx){\n\t        // if the dot is the first element in the list, throw an error\n\t        if(dot1Idx === 0){\n\t          var msg = new types.Message([\"A `.' cannot be the first element in a syntax list\"]);\n\t          throwError(msg, list[dot1Idx].location);\n\t        }\n\t        // if a dot is the last element in the list, throw an error\n\t        if(dot1Idx===(list.length-1) || dot2Idx===(list.length-1)){\n\t          var msg = new types.Message([\"A `.' cannot be the last element in a syntax list\"]);\n\t          throwError(msg, list[dot2Idx||dot1Idx].location);\n\t        }\n\t\n\t        // assuming they are legal, if there are two dots in legal places...\n\t        if(dot2Idx){\n\t          // if they are not surrounding a single element, throw an error\n\t          if(dot2Idx - dot1Idx !== 2){\n\t            var msg = new types.Message([\"Two `.'s may only surround one syntax item\"]);\n\t            throwError(msg, list[dot2Idx].location);\n\t          // if they are, move that element to the front of the list and remove the dots\n\t          } else {\n\t            return list.slice(dot1Idx+1,dot1Idx+2).concat(list.slice(0, dot1Idx), list.slice(dot2Idx+1));\n\t          }\n\t        }\n\t        // okay, we know there's just one dot, so the next element had better be a list AND the last element of the outer list\n\t        if(!(list[dot1Idx+1] instanceof Array)){\n\t           var msg = new types.Message([\"A `.' must be followed by a syntax list, but found \"\n\t                                        , new types.ColoredPart(\"something else\", list[dot1Idx+1].location)])\n\t           throwError(msg, list[dot1Idx+1].location);\n\t        }\n\t        if(list.length > dot1Idx+2){\n\t           var msg = new types.Message([\"A `.' followed by a syntax list must be followed by a closing delimeter, but found \"\n\t                                        , new types.ColoredPart(\"something else\", list[dot1Idx+2].location)])\n\t           throwError(msg, list[dot1Idx+1].location);\n\t         // splice that element into the list, removing the dots\n\t         } else {\n\t           return list.slice(0,dot1Idx).concat(list[dot1Idx+1],list.slice(dot1Idx+2));\n\t         }\n\t      }\n\t                            \n\t      // if we see an error while reading a listItem\n\t      function handleError(e){\n\t        // Some errors we throw immediately, without reading the rest of the list...\n\t        if(/expected a .+ to (close|open)/.exec(e)   // brace or dot errors\n\t           || /unexpected/.exec(e)                   // unexpected delimiter\n\t           || /syntax list/.exec(e)                  // improper use of .\n\t           || /bad syntax/.exec(e)                   // bad syntax\n\t           || /bad character constant/.exec(e)       // bad character constant\n\t           ){\n\t          throw e;\n\t        } else {\n\t          // when we reconstruct the location from an error, we use Racket-style fieldnames, for historical reasons\n\t          var eLoc = JSON.parse(JSON.parse(e)[\"structured-error\"]).location;\n\t          errorLocation = new Location(Number(eLoc.column), Number(eLoc.line),\n\t                                       Number(eLoc.offset)-1, Number(eLoc.span));\n\t          i = endOfError;// keep reading from the last error location\n\t          innerError = e;\n\t        }\n\t        return i;\n\t      }\n\t                            \n\t      // read forward until we see a closing delim, saving the last known-good location\n\t      while (i < str.length && !rightListDelims.test(str.charAt(i))) {\n\t        // check for newlines\n\t        if(str.charAt(i) === \"\\n\"){ line++; column = 0;}\n\t        try  { i = readListItem(str, i, list); }  // read a list item, hopefully without error\n\t        catch (e){ var i = handleError(e);   }        // try to keep reading from endOfError...\n\t        // move reader to the next token\n\t        i = chewWhiteSpace(str, i);\n\t      }\n\t      // if we reached the end of an otherwise-successful list but there's no closing delim...\n\t      if(i >= str.length) {\n\t         var msg = new types.Message([\"read: expected a \", otherDelim(openingDelim),\n\t                                      \" to close \",\n\t                                      new types.ColoredPart(openingDelim.toString(),\n\t                                                            new Location(startCol, startRow, iStart, 1))\n\t                                      ]);\n\t         // throw an error\n\t         throwError(msg, errorLocation);\n\t      }\n\t      // if we reached the end of an otherwise-successful list and it's the wrong closing delim...\n\t      if(!matchingDelims(openingDelim, str.charAt(i))) {\n\t         var msg = new types.Message([\"read: expected a \", otherDelim(openingDelim),\n\t                                      \" to close \",\n\t                                      new types.ColoredPart(openingDelim.toString(),\n\t                                                            new Location(startCol, startRow, iStart, 1)),\n\t                                      \" but found a \",\n\t                                      new types.ColoredPart(str.charAt(i).toString(),\n\t                                                            new Location(column, line, i, 1))\n\t                                      ]);\n\t         throwError(msg, new Location(column, line, i, 1));\n\t      }\n\t      \n\t      column++; i++;  // move forward to count the closing delimeter\n\t      // if an error occured within the list, set endOfError to the end, and throw it\n\t      if(innerError){ endOfError = i; throw innerError; }\n\t                            \n\t      // deal with dots, if they exist\n\t      if(dot1Idx || dot2Idx) list = processDots(list, dot1Idx, dot2Idx);\n\t      list.location = new Location(startCol, startRow, iStart, i-iStart);\n\t      return list;\n\t    }\n\t\n\t    // readString : String Number -> SExp\n\t    // reads a string encoded in this string with the leftmost quotation mark\n\t    // at index i\n\t    function readString(str, i) {\n\t      var startCol = column, startRow = line, iStart = i;\n\t      // greedily match to the end of the string, before examining escape sequences\n\t      var closedString = /^\\\"[^\\\"]*(\\\\\\\"[^\\\"]*)*[^\\\\]\\\"|\\\"\\\"/.test(str.slice(i)),\n\t          greedy = /^\\\"[^\\\"]*(\\\\\"[^\\\"]*)*/.exec(str.slice(iStart))[0];\n\t      i++; column++; // skip over the opening quotation mark char\n\t      // it's a valid string, so let's make sure it's got proper escape sequences\n\t      var chr, datum = \"\";\n\t      while(i < str.length && str.charAt(i) !== '\"') {\n\t        chr = str.charAt(i++);\n\t        // track line/char values while we scan\n\t        if(chr === \"\\n\"){ line++; column = 0;}\n\t        else { column++; }\n\t        if(chr === '\\\\') {\n\t          column++; // move the column forward to skip over the escape character\n\t          chr = str.charAt(i++);\n\t          if(i >= str.length) break; // if there's nothing there, break out\n\t          switch(true){\n\t             case /a/.test(chr)  : chr = '\\u0007'; break;\n\t             case /b/.test(chr)  : chr = '\\b'; break;\n\t             case /t/.test(chr)  : chr = '\\t'; break;\n\t             case /n/.test(chr)  : chr = '\\n'; break;\n\t             case /v/.test(chr)  : chr = '\\v'; break;\n\t             case /f/.test(chr)  : chr = '\\f'; break;\n\t             case /r/.test(chr)  : chr = '\\r'; break;\n\t             case /e/.test(chr)  : chr = '\\u0027'; break;\n\t             case /\\n/.test(chr) : chr = '';   break; // newlines disappear\n\t             case /[\\\"\\'\\\\]/.test(chr)  : break;\n\t             // if it's a charCode symbol, match with a regexp and move i forward\n\t             case /[xuU]/.test(chr):\n\t                var regexp = chr === \"x\"? hex2\n\t                            :chr === \"u\"? hex4\n\t                            /* else */   : hex8;\n\t                if(!regexp.test(str.slice(i))){\n\t                  // remember where we are, so readList can pick up reading\n\t                  endOfError = iStart+greedy.length+1;\n\t                  throwError(new types.Message([source, \":\" , startRow.toString(), \":\", startCol.toString()\n\t                                              , \": read: no hex digit following \\\\\"+chr+\" in string\"])\n\t                           , new Location(startCol, startRow, iStart, i-iStart+1)\n\t                           , \"Error-GenericReadError\");\n\t                }\n\t                var match = regexp.exec(str.slice(i))[1];\n\t                chr = String.fromCharCode(parseInt(match, 16));\n\t                i += match.length; column += match.length;\n\t                break;\n\t             case oct3.test(str.slice(i-1)) :\n\t                var match = oct3.exec(str.slice(i-1))[1];\n\t                chr = String.fromCharCode(parseInt(match, 8));\n\t                i += match.length-1; column += match.length-1;\n\t                break;\n\t             default   :\n\t                // remember where we are, so readList can pick up reading\n\t                endOfError = iStart+greedy.length+1;\n\t                throwError(new types.Message([source, \":\"\n\t                                              , startRow.toString(), \":\"\n\t                                              , startCol.toString()\n\t                                              , \": read: unknown escape sequence \\\\\" +chr+\" in string\"])\n\t                           , new Location(startCol, startRow, iStart, i-iStart)\n\t                           , \"Error-GenericReadError\");\n\t                  }\n\t        }\n\t        datum += chr;\n\t      }\n\t\n\t      // if the next char after iStart+openquote+greedy isn't a closing quote, it's an unclosed string\n\t      if(!closedString) {\n\t        endOfError = iStart+greedy.length; // remember where we are, so readList can pick up reading\n\t        throwError(new types.Message([source, \":\"\n\t                                      , startRow.toString(), \":\"\n\t                                      , startCol.toString()\n\t                                      , \": read: expected a closing \\'\\\"\\'\"])\n\t                   , new Location(startCol, startRow, iStart, 1)\n\t                   , \"Error-GenericReadError\");\n\t      }\n\t      var strng = new literal(new types.string(datum));\n\t      i++; column++; // move forward to include the ending quote\n\t      strng.location = new Location(startCol, startRow, iStart, i-iStart);\n\t      return strng;\n\t    }\n\t\n\t    // readPoundSExp : String Number -> SExp\n\t    // based on http://docs.racket-lang.org/reference/reader.html#%28part._default-readtable-dispatch%29\n\t    // NOTE: bytestrings, regexps, hashtables, graphs, reader and lang extensions are not supported\n\t    function readPoundSExp(str, i) {\n\t      var startCol = column, startRow = line, iStart = i, datum;\n\t      i++; column++; // skip over the pound sign\n\t      // construct an unsupported error string\n\t      var unsupportedError;\n\t                            \n\t      // throwUnsupportedError : ErrorString token -> Error\n\t      function throwUnsupportedError(errorStr, token){\n\t        var msg = new types.Message([source, \":\", line.toString()\n\t                                     , \":\", (column-1).toString()\n\t                                     , errorStr]);\n\t        throwError(msg\n\t                   , new Location(startCol, startRow, iStart, token.length+1)\n\t                   , \"Error-GenericReadError\");\n\t      }\n\t               \n\t      if(i < str.length) {\n\t        var p = str.charAt(i).toLowerCase();\n\t        // fl and fx Vectors, structs, and hashtables are not supported\n\t        var unsupportedMatch = new RegExp(\"^(((fl|fx|s|hash|hasheq)[\\[\\(\\{])|((rx|px)\\#{0,1}\\\"))\", 'g'),\n\t            unsupportedTest = unsupportedMatch.exec(str.slice(i));\n\t        // Reader or Language Extensions are not allowed\n\t        var badExtensionMatch = /^(!(?!\\/)|reader|lang[\\s]{0,1})/,\n\t            badExtensionTest = badExtensionMatch.exec(str.slice(i));\n\t        // Case sensitivity flags ARE allowed\n\t        var caseSensitiveMatch = new RegExp(\"^(c|C)(i|I|s|S)\"),\n\t            caseSensitiveTest = caseSensitiveMatch.exec(str.slice(i));\n\t        // Vector literals ARE allowed\n\t        var vectorMatch = new RegExp(\"^([0-9]*)[\\[\\(\\{]\", 'g'),\n\t            vectorTest = vectorMatch.exec(str.slice(i));\n\t        if(unsupportedTest && unsupportedTest[0].length > 0){\n\t            var sexp = readSExpByIndex(str, i+unsupportedTest[0].length-1),\n\t                kind, span = unsupportedTest[0].length, // save different error strings and spans\n\t                base = unsupportedTest[0].replace(/[\\(\\[\\{\\\"|#\\\"]/g, '');\n\t            switch(base){\n\t              case \"fl\":    kind = \"flvectors\"; break;\n\t              case \"fx\":    kind = \"fxvectors\"; break;\n\t              case \"s\":     kind = \"structs\";   break;\n\t              case \"hash\":\n\t              case \"hasheq\":kind = \"hashtables\"; break;\n\t              case \"px\":\n\t              case \"rx\":    kind = \"regular expressions\"; break;\n\t              default: throw \"IMPOSSIBLE: unsupportedMatch captured something it shouldn't: \"+base;\n\t            }\n\t            var error = new types.Message([source, \":\", line.toString(), \":\", \"0\"\n\t                                           , \": read-syntax: literal \"+ kind + \" not allowed\"]);\n\t            datum = new unsupportedExpr(sexp, error, span);\n\t            datum.location = new Location(startCol, startRow, iStart, unsupportedTest[0].length+sexp.location.span);\n\t            return datum;\n\t        } else if(badExtensionTest && badExtensionTest[0].length > 0){\n\t            throwUnsupportedError(\": read: #\" + badExtensionTest[0].trim()\n\t                              + \" not enabled in the current context\"\n\t                                  , badExtensionTest[0]);\n\t        } else if(caseSensitiveTest && caseSensitiveTest[0].length > 0){\n\t            caseSensitiveSymbols = (caseSensitiveTest[0].toLowerCase() === \"cs\");\n\t            i+=2; column+=2;\n\t            return readSExpByIndex(str, i);\n\t        } else if(vectorTest && vectorTest[0].length > 0){\n\t          var size = (vectorTest[1])? parseInt(vectorTest[1]) : \"\",    // do we have a size string?\n\t              sizeChars = size.toString().length;                     // how long is the size string?\n\t          i+=sizeChars; column+=sizeChars           // start reading after the vectorsize was specified\n\t          var elts = readList(str, i),\n\t              len = size===\"\"? elts.length : parseInt(vectorTest[1]);  // set the size to a number\n\t          // test vector size\n\t          if(elts.length > len){\n\t             var msg = new types.Message([\"read: vector length \"+len+\" is too small, \",\n\t                                          elts.length+\" value\" + ((elts.length>1)? \"s\" : \"\"),\n\t                                          \" provided\"]);\n\t             throwError(msg, new Location(startCol, startRow, iStart, vectorTest[0].length));\n\t          }\n\t\n\t          i+=elts.location.span;\n\t          datum = new literal(new Vector(len, elts));\n\t          datum.location = new Location(startCol, startRow, iStart, i-iStart);\n\t          return datum;\n\t        } else {\n\t          // match every valid (or *almost-valid*) sequence of characters, or the empty string\n\t          var poundChunk = new RegExp(\"^(hasheq|hash|fl|fx|\\\\d+|true|false|[tfeibdox]|\\\\<\\\\<|[\\\\\\\\\\\\\\\"\\\\%\\\\:\\\\&\\\\|\\\\;\\\\!\\\\`\\\\,\\\\']|)\", 'i'),\n\t              chunk = poundChunk.exec(str.slice(i))[0],\n\t              // match the next character\n\t              nextChar = str.charAt(i+chunk.length);\n\t          // grab the first non-whitespace character\n\t          var p = chunk.charAt(0).toLowerCase();\n\t          switch(p){\n\t            // CHARACTERS\n\t            case '\\\\': datum = readChar(str, i-1);\n\t                       i+= datum.location.span-1; break;\n\t            // BYTE-STRINGS (unsupported)\n\t            case '\"': throwUnsupportedError(\": byte strings are not supported in WeScheme\", \"#\\\"\");\n\t            // SYMBOLS\n\t            case '%': datum = readSymbolOrNumber(str, i);\n\t                      datum.val = '#'+datum.val;\n\t                      i+= datum.location.span; break;\n\t            // KEYWORDS (lex to a symbol, then strip out the contents)\n\t            case ':': datum = readSymbolOrNumber(str, i-1);\n\t                      var error = new types.Message([source, \":\", line.toString(), \":\", \"0\"\n\t                                                   , \": read-syntax: Keyword internment is not supported in WeScheme\"]);\n\t                      datum = new unsupportedExpr(datum.val, error, datum.location.span);\n\t                      i+= datum.val.length-1;\n\t                      break;\n\t            // BOXES\n\t            case '&': column++;\n\t                      sexp = readSExpByIndex(str, i+1);\n\t                      var boxCall = new symbolExpr(\"box\"),\n\t                          datum = [boxCall, sexp];\n\t                      i+= sexp.location.span+1;\n\t                      boxCall.location = new Location(startCol, startRow, iStart, i-iStart);\n\t                      break;\n\t            // BLOCK COMMENTS\n\t            case '|': i--;\n\t                      datum = readBlockComment(str, i);\n\t                      i+= datum.location.span+1; break;\n\t            // SEXP COMMENTS\n\t            case ';': datum = readSExpComment(str, i+1);\n\t                      i+= datum.location.span+1; break;\n\t            // LINE COMMENTS\n\t            case '!': datum = readLineComment(str, i-1);\n\t                      i+= datum.location.span; break;\n\t            // SYNTAX QUOTES, UNQUOTES, AND QUASIQUOTES\n\t            case '`':\n\t            case ',':\n\t            case '\\'': datum = readQuote(str, i);\n\t                      datum.location.startChar--; datum.location.span++; // expand the datum to include leading '#'\n\t                      endOfError = i+datum.location.span;\n\t                      var msg = new types.Message([source, \":\", startRow.toString()\n\t                                                   , \":\", (column-1).toString()\n\t                                                   , \" read: WeScheme does not support the '#\"+p+\"' notation for \"\n\t                                                   , (p===\",\"? \"unsyntax\" : p===\"'\"? \"syntax\" : \"quasisyntax\")]);\n\t                      throwError(msg, datum.location);\n\t                      break;\n\t            // STRINGS\n\t            case '<<': datum = readString(str, i-1);\n\t                       i+= datum.location.span; break;\n\t            // NUMBERS\n\t            case 'e':  // exact\n\t            case 'i':  // inexact\n\t            case 'b':  // binary\n\t            case 'o':  // octal\n\t            case 'd':  // decimal\n\t            case 'x':  // hexadecimal\n\t                column--; //  back up the column one char\n\t                datum = readSymbolOrNumber(str, i-1);\n\t                i+= datum.location.span-1; break;\n\t            // BOOLEANS\n\t            case 'true':\n\t            case 'false':\n\t            case 't':  // true\n\t            case 'f':  // false\n\t                if(!matchUntilDelim.exec(nextChar)){             // if there's no other chars aside from space or delims...\n\t                  datum = new literal(p==='t' || chunk==='true'); // create a Boolean literal\n\t                  i+=chunk.length; column+=chunk.length;         // move i/col ahead by the char\n\t                  break;\n\t                }\n\t            default:\n\t              endOfError = i; // remember where we are, so readList can pick up reading\n\t              var msg = new types.Message([source, \":\", line.toString()\n\t                                           , \":\", (column-1).toString()\n\t                                           , \": read: bad syntax `#\", (chunk+nextChar),\"'\"]);\n\t              throwError(msg\n\t                        , new Location(startCol, startRow, iStart, (chunk+nextChar).length+1)\n\t                        , \"Error-GenericReadError\");\n\t           }\n\t        }\n\t      // only reached if # is the end of the string...\n\t      } else {\n\t        endOfError = i; // remember where we are, so readList can pick up reading\n\t        throwError(new types.Message([source, \":\", line.toString()\n\t                                     , \":\" , (column-1).toString()\n\t                                     , \": read: bad syntax `#'\"])\n\t                  , new Location(startCol, startRow, iStart, i-iStart)\n\t                  , \"Error-GenericReadError\");\n\t      }\n\t      datum.location = new Location(startCol, startRow, iStart, i-iStart);\n\t      return datum;\n\t    }\n\t\n\t    // readChar : String Number -> types.char\n\t    // reads a character encoded in the string and returns a representative datum\n\t    // see http://docs.racket-lang.org/reference/reader.html#%28part._parse-character%29\n\t    function readChar(str, i) {\n\t      var startCol = column, startRow = line, iStart = i;\n\t      i+=2;  column++; // skip over the #\\\\\n\t      var datum = \"\", isFirstChar=true, regexp;\n\t                                                        \n\t      // read until we hit the end of the string, another char, or whitespace when it's not the first char\n\t      while(i < str.length && (str.slice(i,i+2) !== \"#\\\\\")\n\t             && !(!isFirstChar && (isWhiteSpace(str.charAt(i)) || isDelim(str.charAt(i))) )) {\n\t        isFirstChar = false;\n\t        column++;\n\t        datum += str.charAt(i++);\n\t      }\n\t                                                        \n\t      // a special char is one of the following, as long as the next char is not alphabetic\n\t      // unlike DrRacket, there is no JS equivalent for nul, null, page and rubout\n\t      var special = new RegExp(\"(backspace|tab|newline|space|vtab)[^a-zA-Z]*\", \"i\"),\n\t          match = special.exec(datum);\n\t      // check for special chars\n\t      if(special.test(datum)){\n\t          datum = datum === 'backspace'? '\\b' :\n\t                  datum === 'tab' ?     '\\t' :\n\t                  datum === 'newline' ? '\\n' :\n\t                  datum === 'space' ?   ' ' :\n\t                  datum === 'vtab' ?    '\\v' :\n\t                    \"Impossible: unknown special char was matched by special char!\";\n\t          i = iStart + 2 + match[1].length; // set the reader to the end of the char\n\t                                                        \n\t       // octal charCodes\n\t       } else if(/^[0-9].*/.test(datum)                       // if it starts with a number...\n\t                 && oct3.test(datum)                         // it had better have some octal digits..\n\t                 && (oct3.exec(datum)[0]===datum)            // in fact, all of them should be octal..\n\t                 && (parseInt(oct3.exec(datum)[0], 8) < 256) // and less than 256...\n\t                 && (parseInt(oct3.exec(datum)[0], 8) > 31)  // and greater than 31,\n\t                 ) {\n\t          var match = /[0-7]+/.exec(datum)[0];\n\t          datum = String.fromCharCode(parseInt(match, 8));\n\t          i = iStart + 2 + match.length; // set the reader to the end of the char\n\t                                                        \n\t       // check for hex4 or hex6\n\t      } else if( /[uU]/.test(datum)                          // if it declares itself to be hexidecimal...\n\t                && (regexp=datum.charAt(0)===\"u\"? hex4:hex6) // and we have a regexp for it...\n\t                && regexp.test(datum.slice(1))               // and it's a valid hex code for that regexp...\n\t              ){\n\t          var match = regexp.exec(datum.slice(1))[0];\n\t          column += (match.length-datum.length)+1; // adjust column if only a subset of the datum matched\n\t          datum = String.fromCharCode(parseInt(match, 16));\n\t          i = iStart + 3 + match.length; // fast-forward past (1) hash, (2) backslash, (3) u and (4) number\n\t       // check for a single character, or a character that is NOT followed by a unicode-alphabetic character\n\t      } else if (datum.length===1 || /[^\\u00C0-\\u1FFF\\u2C00-\\uD7FF\\w]$/.test(datum.charAt(1))) {\n\t          datum = datum.charAt(0);\n\t          i = iStart + 3; // fast-forward past (1) hash, (2) backslash and (3) single char\n\t      } else {\n\t          throwError(new types.Message([source , \":\" , startRow.toString(), \":\", (startCol-1).toString(),\n\t                                        \": read: bad character constant: #\\\\\",datum]),\n\t                     new Location(startCol-1, startRow, iStart, i-iStart),\n\t                     \"Error-GenericReadError\");\n\t      }\n\t      var chr = new literal(new types['char'](datum));\n\t      chr.location = new Location(startCol, startRow, iStart, i-iStart);\n\t      return chr;\n\t    }\n\t\n\t    // readBlockComment : String Number -> Atom\n\t    // reads a multiline comment\n\t    function readBlockComment(str, i) {\n\t      var startCol = column, startRow = line, iStart = i;\n\t      i+=2; column+=2; // skip over the #|\n\t      var txt = \"\";\n\t      while(i+1 < str.length && !(str.charAt(i) === '|' && str.charAt(i+1) === '#')) {\n\t        // check for newlines\n\t        if(str.charAt(i) === \"\\n\"){ line++; column = 0;}\n\t        txt+=str.charAt(i);\n\t        i++; column++;  // move ahead\n\t      }\n\t      if(i+1 >= str.length) {\n\t        throwError(new types.Message([\"read: Unexpected EOF when reading a multiline comment\"])\n\t                   ,new Location(startCol, startRow, iStart, i-iStart));\n\t      }\n\t      i++; column++; // hop over '|#'\n\t      var comment = new Comment(txt);\n\t      comment.location = new Location(startCol, startRow, iStart, i-iStart);\n\t      return comment;\n\t    }\n\t\n\t    // readSExpComment : String Number -> Atom\n\t    // reads exactly one SExp and ignores it entirely\n\t    function readSExpComment(str, i) {\n\t      var startCol = column++, startRow = line, iStart = i, nextSExp;\n\t      // keep reading s-exprs while...\n\t      while((i = chewWhiteSpace(str, i)) &&           // there's whitespace to chew\n\t            (i+1<str.length) &&                         // we're not out of string\n\t            (nextSExp = readSExpByIndex(str, i)) &&   // there's an s-expr to be read\n\t            (nextSExp instanceof Comment)){            // and it's not a comment\n\t        i = nextSExp.location.endChar;\n\t      }\n\t                                                        \n\t      // if we're done reading, make sure we didn't read past the end of the file\n\t      if(i+1 >= str.length) {\n\t        endOfError = i; // remember where we are, so readList can pick up reading\n\t        throwError(new types.Message([source , \":\" , startRow.toString(), \":\", (startCol-1).toString()\n\t                                      , \": read: expected a commented-out element for `#;' (found end-of-file)\"])\n\t                   ,new Location(startCol-1, startRow, i-2, 2) // back up the startChar before #;, make the span include only those 2\n\t                   ,\"Error-GenericReadError\");\n\t      }\n\t      // if we're here, then we read a proper s-expr\n\t      var atom = new Comment(\"(\"+nextSExp.toString()+\")\");\n\t      i = nextSExp.location.endChar;\n\t      atom.location = new Location(startCol, startRow, iStart, i-iStart);\n\t      return atom;\n\t    }\n\t\n\t    // readLineComment : String Number -> Atom\n\t    // reads a single line comment\n\t    function readLineComment(str, i) {\n\t      var startCol = column, startRow = line, iStart = i;\n\t      i++; column++; // skip over the ;\n\t      var txt = \"\";\n\t      while(i < str.length && str.charAt(i) !== '\\n') {\n\t        // track column values while we scan\n\t        txt+=str.charAt(i); column++; i++;\n\t      }\n\t      if(i > str.length) {\n\t        endOfError = i; // remember where we are, so readList can pick up reading\n\t        throwError(new types.Message([\"read: Unexpected EOF when reading a line comment\"]),\n\t                   new Location(startCol, startRow, iStart, i-iStart));\n\t      }\n\t      var atom = new Comment(txt);\n\t      atom.location = new Location(startCol, startRow, iStart, i+1-iStart);\n\t      // at the end of the line, reset line/col values\n\t      line++; column = 0;\n\t      return atom;\n\t    }\n\t\n\t    // readQuote : String Number -> SExp\n\t    // reads a quote, quasiquote, or unquote encoded as a string\n\t    // NOT OPTIMIZED BY V8, due to presence of try/catch\n\t    function readQuote(str, i) {\n\t      var startCol = column, startRow = line, iStart = i, nextSExp;\n\t      var p = str.charAt(i);\n\t      var symbol = p == \"'\" ? new symbolExpr(\"quote\") :\n\t                   p == \"`\" ? new symbolExpr(\"quasiquote\") :\n\t                   /* else */  \"\";\n\t      function eofError(i){\n\t        endOfError = i+1; // remember where we are, so readList can pick up reading\n\t        var action = p == \"'\" ? \" quoting \" :\n\t                     p == \"`\" ? \" quasiquoting \" :\n\t                     p == \",\" ? \" unquoting \" :\n\t                     p == \",@\" ? \" unquoting \" :                                 \n\t                     /* else */  \"\";\n\t        throwError(new types.Message([source, \":\", startRow.toString(), \":\", startCol.toString()\n\t                                      , \": read: expected an element for\" + action, p\n\t                                      , \" (found end-of-file)\"])\n\t                   , new Location(startCol, startRow, iStart, p.length)\n\t                   , \"Error-GenericReadError\");\n\t      }\n\t      if(i+1 >= str.length) { eofError(i); }\n\t      i++; column++; // read forward one char\n\t      if(p == ',') {\n\t        if(str.charAt(i) == '@') {\n\t          i++; column++; p+='@'; // read forward one char, and add @ to the option\n\t          symbol = new symbolExpr(\"unquote-splicing\");\n\t        } else {\n\t          symbol = new symbolExpr(\"unquote\");\n\t        }\n\t      }\n\t\n\t      symbol.location = new Location(column-1, startRow, iStart, i - iStart);\n\t\n\t      // read the next non-comment sexp\n\t      while(!nextSExp || (nextSExp instanceof Comment)){\n\t        i = chewWhiteSpace(str, i);\n\t        try{nextSExp = readSExpByIndex(str, i);}\n\t        catch(e){\n\t          // if it's the end of file, throw a special EOF for quoting\n\t          if(/read\\: \\(found end-of-file\\)/.test(e)) eofError(i);\n\t          var unexpected = /expected a .* to open \\\",\\\"(.)\\\"/.exec(e);\n\t          if(unexpected){\n\t            endOfError = i+1; // remember where we are, so readList can pick up reading\n\t            throwError(new types.Message([source, \":\", line.toString(), \":\", column.toString()\n\t                                          , \": read: unexpected `\" + unexpected[1] + \"'\"])\n\t                       , new Location(column, line, i, 1)\n\t                       , \"Error-GenericReadError\");\n\t          }\n\t          throw e;\n\t        }\n\t        i = nextSExp.location.end().startChar+1;\n\t      }\n\t      var quotedSexp = [symbol, nextSExp],\n\t          quotedSpan = (nextSExp.location.end().startChar+1) - iStart;\n\t      \n\t      quotedSexp.location = new Location(startCol, startRow, iStart, quotedSpan);\n\t      return quotedSexp;\n\t    }\n\t                   \n\t                                                                \n\t    // readSymbolOrNumber : String Number -> symbolExpr | types.Number\n\t    // NOT OPTIMIZED BY V8, due to presence of try/catch\n\t    function readSymbolOrNumber(str, i){\n\t      var startCol = column, startRow = line, iStart = i;\n\t      // match anything consisting of stuff between two |bars|, **OR**\n\t      // non-whitespace characters that do not include:  ( ) { } [ ] , ' ` | \\\\ \" ;\n\t      var symOrNum = new RegExp(\"(\\\\|(.|\\\\n)*\\\\||\\\\\\\\(.|\\\\n)|[^\\\\(\\\\)\\\\{\\\\}\\\\[\\\\]\\\\,\\\\'\\\\`\\\\s\\\\\\\"\\\\;])+\", 'mg');\n\t      var chunk = symOrNum.exec(str.slice(i))[0];\n\t      // if there's an unescaped backslash at the end, throw an error\n\t      var trailingEscs = /\\.*\\\\+$/.exec(chunk);\n\t      if(trailingEscs && (trailingEscs[0].length%2 > 0)){\n\t            i = str.length; // jump to the end of the string\n\t            endOfError = i; // remember where we are, so readList can pick up reading\n\t            throwError(new types.Message([source, \":\", line.toString(), \":\", startCol.toString(),\n\t                                          \": read: EOF following `\\\\' in symbol\"])\n\t                       ,new Location(startCol, startRow, iStart, i-iStart)\n\t                       ,\"Error-GenericReadError\");\n\t      }\n\t      // move the read head and column tracker forward\n\t      i+=chunk.length; column+=chunk.length;\n\t                                                        \n\t      // remove escapes\n\t      var unescaped = \"\";\n\t      for(var j=0; j < chunk.length; j++){\n\t        if(chunk.charAt(j) == \"\\\\\") { j++; }  // if it's an escape char, skip over it and add the next one\n\t        unescaped += chunk.charAt(j);\n\t      }\n\t      // split the chunk at each |\n\t      var chunks = unescaped.split(\"|\");\n\t      // check for unbalanced |'s, and generate an error that begins at the last one\n\t      // and extends for the remainder of the string\n\t      if(((chunks.length%2) === 0)){\n\t          endOfError = str.length;\n\t          var sizeOfLastChunk = chunks[chunks.length-1].length+1, // add 1 for the starting '|'\n\t              strBeforeLastChunk = chunk.slice(0, chunk.length-sizeOfLastChunk),\n\t              lastVerbatimMarkerIndex = iStart+strBeforeLastChunk.length;\n\t          // We need to go back and get more precise location information\n\t          column = startCol;\n\t          for(var j=0; j<strBeforeLastChunk.length; j++){\n\t            if(str.charAt(i) === \"\\n\"){line++; column = 0;}\n\t            else { column++; }\n\t          }\n\t          throwError(new types.Message([source, \":\", line.toString(), \":\", column.toString(),\n\t                                        \": read: unbalanced `|'\"])\n\t                      ,new Location(column, line, lastVerbatimMarkerIndex, str.length-lastVerbatimMarkerIndex)\n\t                      ,\"Error-GenericReadError\");\n\t      }\n\t                                                        \n\t      // enforce case-sensitivity for non-verbatim sections.\n\t      var filtered = chunks.reduce(function(acc, str, i){\n\t            // if we're inside a verbatim portion (i is even) *or* we're case sensitive, preserve case\n\t            return acc+= (i%2 || caseSensitiveSymbols)? str : str.toLowerCase();\n\t          }, \"\");\n\t\n\t      // if it's a newline, adjust line and column trackers\n\t      if(filtered===\"\\n\"){line++; column=0;}\n\t\n\t      // add bars if it's a symbol that needs those escape characters, or if the original string used an escaped number\n\t      var special_chars = new RegExp(\"^$|[\\\\(\\\\)\\\\{\\\\}\\\\[\\\\]\\\\,\\\\'\\\\`\\\\s\\\\\\\"\\\\\\\\]\", 'g');\n\t      var escaped_nums = new RegExp(\"^.*\\\\\\\\[\\\\d]*.*|\\\\|[\\\\d]*\\\\|\");\n\t      filtered = (escaped_nums.test(chunk) || special_chars.test(filtered)? \"|\"+filtered+\"|\" : filtered);\n\t                                                        \n\t      // PERF: start out assuming it's a symbol...\n\t      var node = new symbolExpr(filtered);\n\t      // PERF: if it's not trivially a symbol, we take the hit of jsnums.fromString()\n\t      if((chunks.length === 1) && !/^[a-zA-Z\\-\\?]+$/.test(filtered)){\n\t        // attempt to parse using jsnums.fromString(), assign to sexp and add location\n\t        // if it's a bad number, throw an error\n\t        try{\n\t           var numValue = jsnums.fromString(filtered, true);\n\t           // If it's a number (don't interpret zero as 'false'), that's our node\n\t           if(numValue || numValue === 0){\n\t             if(numValue instanceof Object){\n\t               numValue.stx = filtered;\n\t               numValue.location = new Location(startCol, startRow, iStart, i-iStart);\n\t             }\n\t             node = new literal(numValue);\n\t           }\n\t        // if it's not a number OR a symbol\n\t        } catch(e) {\n\t            endOfError = i; // remember where we are, so readList can pick up reading\n\t            var msg = new types.Message([source, \":\", startRow.toString()\n\t                                         , \":\" , startCol.toString()\n\t                                         , \": read: \"+e.message]);\n\t            throwError(msg\n\t                       , new Location(startCol, startRow, iStart, i-iStart)\n\t                       , \"Error-GenericReadError\");\n\t        }\n\t      }\n\t      node.stx = filtered; // save the string that generated the symbol/number to begin with\n\t      node.location = new Location(startCol, startRow, iStart, i-iStart);\n\t      return node;\n\t    }\n\t    /////////////////////\n\t    /* Export Bindings */\n\t    /////////////////////\n\t    plt.compiler.lex = function(str, strSource, debug){\n\t        var start = new Date().getTime();\n\t        try { var sexp      = readProg(str, strSource); }  // do the actual work\n\t        catch(e) { console.log(\"LEXING ERROR\"); throw e; }\n\t        var end = new Date().getTime();\n\t        if(debug){\n\t          console.log(\"Lexed in \"+(Math.floor(end-start))+\"ms\");\n\t          console.log(sexp);\n\t          console.log(sexpToString(sexp));\n\t        }\n\t        return sexp;\n\t    };\n\t    plt.compiler.sexpToString = sexpToString;\n\t})();\n\t\n\tmodule.exports = plt.compiler;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar types = __webpack_require__(3);\n\tvar Vector = types.Vector;\n\t\n\t// if not defined, declare the compiler object as part of plt\n\twindow.plt   = window.plt   || {};\n\tplt.compiler = plt.compiler || {};\n\t//plt.compiler = require('./modules');\n\t\n\t/*\n\t TODO\n\t - have modulePathResolver return the proper name!\n\t */\n\t\n\t//////////////////////////////////////////////////////////////////////////////\n\t/////////////////// COMMON FUNCTIONS AND STRUCTURES //////////////////////////\n\t//////////////// used by multiple phases of the compiler/////////////////////\n\t\n\t(function () {\n\t 'use strict';\n\t \n\t  var unimplementedException = function(str){\n\t    this.str = str;\n\t  }\n\t\n\t  /**************************************************************************\n\t   *\n\t   *    CONVERT LOCAL COMPILER ERRORS INTO WESCHEME ERRORS\n\t   *\n\t   **************************************************************************/\n\t  // encode the msg and location as a JSON error\n\t  function throwError(msg, loc, errorClass) {\n\t    loc.source = loc.source || \"<unknown>\"; // FIXME -- we should have the source populated\n\t    // rewrite a ColoredPart to match the format expected by the runtime\n\t    function rewritePart(part){\n\t      if(typeof(part) === 'string'){\n\t        return part;\n\t      } else if(part instanceof symbolExpr){\n\t        return '[\"span\", [[\"class\", \"SchemeValue-Symbol\"]], '+part.val+']';\n\t        return part.val;\n\t      } else if(part.location !== undefined){\n\t        return {text: part.text, type: 'ColoredPart', loc: part.location.toString()\n\t              , toString: function(){return part.text;}};\n\t      } else if(part.locations !== undefined){\n\t        return {text: part.text, type: 'MultiPart', solid: part.solid\n\t              , locs: part.locations.map(function(l){return l.toString()})\n\t              , toString: function(){return part.text;}};\n\t      }\n\t    }\n\t    \n\t    msg.args = msg.args.map(rewritePart);\n\t    \n\t    var json = {type: \"moby-failure\"\n\t      , \"dom-message\": [\"span\"\n\t                        ,[[\"class\", \"Error\"]]\n\t                        ,[\"span\"\n\t                          , [[\"class\", (errorClass || \"Message\")]]].concat(\n\t                           (errorClass? [[\"span\"\n\t                                          , [[\"class\", \"Error.reason\"]]\n\t                                          , msg.toString()]\n\t                                        , [\"span\", [[\"class\", ((errorClass || \"message\")\n\t                                                              +((errorClass === \"Error-GenericReadError\")?\n\t                                                                \".locations\"\n\t                                                                :\".otherLocations\"))]]]]\n\t                                        : msg.args.map(function(x){return x.toString();})))\n\t                        ,[\"br\", [], \"\"]\n\t                        ,[\"span\"\n\t                          , [[\"class\", \"Error.location\"]]\n\t                          , [\"span\"\n\t                             , [[\"class\", \"location-reference\"]\n\t                                , [\"style\", \"display:none\"]]\n\t                             , [\"span\", [[\"class\", \"location-offset\"]], (loc.startChar+1).toString()]\n\t                             , [\"span\", [[\"class\", \"location-line\"]]  , loc.startRow.toString()]\n\t                             , [\"span\", [[\"class\", \"location-column\"]], loc.startCol.toString()]\n\t                             , [\"span\", [[\"class\", \"location-span\"]]  , loc.span.toString()]\n\t                             , [\"span\", [[\"class\", \"location-id\"]]    , loc.source.toString()]\n\t                             ]\n\t                          ]\n\t                        ]\n\t      , \"structured-error\": JSON.stringify({message: (errorClass? false : msg.args), location: loc.toString() })\n\t    };\n\t    throw JSON.stringify(json);\n\t  }\n\t\n\t  // couple = pair\n\t  function couple(first, second) {\n\t    this.first = first;\n\t    this.second = second;\n\t    this.toString = function(){\n\t      return \"(\"+this.first.toString() +\" \"+this.second.toString()+\")\";\n\t    };\n\t  };\n\t\n\t  /**************************************************************************\n\t   *\n\t   *    AST Nodes\n\t   *\n\t   **************************************************************************/\n\t\n\t  // Inheritance from pg 168: Javascript, the Definitive Guide.\n\t  var heir = function(p) {\n\t    var f = function() {};\n\t    f.prototype = p;\n\t    return new f();\n\t  };\n\t\n\t  // all Programs, by default, print out their values\n\t  // anything that behaves differently must provide their own toString() function\n\t  var Program = function() {\n\t    // -> String\n\t    this.toString = function(){ return this.val.toString(); };\n\t    // every Program has a location, but it's initialized to null\n\t    this.location = null;\n\t  };\n\t\n\t  // Function definition\n\t  function defFunc(name, args, body, stx) {\n\t    Program.call(this);\n\t    this.name = name;\n\t    this.args = args;\n\t    this.body = body;\n\t    this.stx  = stx;\n\t    this.toString = function(){\n\t      return \"(define (\"+this.name.toString()+\" \"+this.args.join(\" \")+\")\\n    \"+this.body.toString()+\")\";\n\t    };\n\t  };\n\t  defFunc.prototype = heir(Program.prototype);\n\t\n\t\n\t  // Variable definition\n\t  function defVar(name, expr, stx) {\n\t    Program.call(this);\n\t    this.name = name;\n\t    this.expr = expr;\n\t    this.stx  = stx;\n\t    this.toString = function(){\n\t      return \"(define \"+this.name.toString()+\" \"+this.expr.toString()+\")\";\n\t    };\n\t  };\n\t  defVar.prototype = heir(Program.prototype);\n\t\n\t  // Multi-Variable definition\n\t  function defVars(names, expr, stx) {\n\t    Program.call(this);\n\t    this.names  = names;\n\t    this.expr   = expr;\n\t    this.stx    = stx;\n\t    this.toString = function(){\n\t      return \"(define-values (\"+this.names.join(\" \")+\") \"+this.expr.toString()+\")\";\n\t    };\n\t  };\n\t  defVars.prototype = heir(Program.prototype);\n\t\n\t  // Structure definition\n\t  function defStruct(name, fields, stx) {\n\t    Program.call(this);\n\t    this.name   = name;\n\t    this.fields = fields;\n\t    this.stx    = stx;\n\t    this.toString = function(){\n\t      return \"(define-struct \"+this.name.toString()+\" (\"+this.fields.toString()+\"))\";\n\t    };\n\t  };\n\t  defStruct.prototype = heir(Program.prototype);\n\t\n\t  // Begin expression\n\t  function beginExpr(exprs, stx) {\n\t    Program.call(this);\n\t    this.exprs  = exprs;\n\t    this.stx    = stx;\n\t    this.toString = function(){\n\t      return \"(begin \"+this.exprs.join(\" \")+\")\";\n\t    };\n\t  };\n\t  beginExpr.prototype = heir(Program.prototype);\n\t\n\t  // Lambda expression\n\t  function lambdaExpr(args, body, stx) {\n\t    Program.call(this);\n\t    this.args = args;\n\t    this.body = body;\n\t    this.stx  = stx;\n\t    this.toString = function(){\n\t      return \"(lambda (\"+this.args.join(\" \")+\") \"+this.body.toString()+\")\";\n\t    };\n\t  };\n\t  lambdaExpr.prototype = heir(Program.prototype);\n\t\n\t  // Local expression\n\t  function localExpr(defs, body, stx) {\n\t    Program.call(this);\n\t    this.defs = defs;\n\t    this.body = body;\n\t    this.stx  = stx;\n\t    this.toString = function(){\n\t      return \"(local (\"+this.defs.toString()+\") \"+this.body.toString()+\")\";\n\t    };\n\t  };\n\t  localExpr.prototype = heir(Program.prototype);\n\t\n\t  // Letrec expression\n\t  function letrecExpr(bindings, body, stx) {\n\t    this.bindings = bindings;\n\t    this.body     = body;\n\t    this.stx      = stx;\n\t    this.toString = function(){\n\t      return \"(letrec (\"+this.bindings.toString()+\") (\"+this.body.toString()+\"))\";\n\t    };\n\t  };\n\t\n\t  // Let expression\n\t  function letExpr(bindings, body, stx) {\n\t    this.bindings = bindings;\n\t    this.body     = body;\n\t    this.stx      = stx;\n\t    this.toString = function(){\n\t      return \"(let (\"+this.bindings.toString()+\") (\"+this.body.toString()+\"))\";\n\t    };\n\t  };\n\t\n\t  // Let* expressions\n\t  function letStarExpr(bindings, body, stx) {\n\t    this.bindings = bindings;\n\t    this.body     = body;\n\t    this.stx      = stx;\n\t    this.toString = function(){\n\t      return \"(let* (\"+this.bindings.toString()+\") (\"+this.body.toString()+\"))\";\n\t    };\n\t  };\n\t\n\t  // cond expression\n\t  function condExpr(clauses, stx) {\n\t    this.clauses  = clauses;\n\t    this.stx      = stx;\n\t    this.toString = function(){\n\t      return \"(cond\\n    \"+this.clauses.join(\"\\n    \")+\")\";\n\t    };\n\t  };\n\t\n\t  // Case expression\n\t  function caseExpr(expr, clauses, stx) {\n\t    Program.call(this);\n\t    this.expr     = expr;\n\t    this.clauses  = clauses;\n\t    this.stx      = stx;\n\t    this.toString = function(){\n\t      return \"(case \"+this.expr.toString()+\"\\n    \"+this.clauses.join(\"\\n    \")+\")\";\n\t    };\n\t  };\n\t  caseExpr.prototype = heir(Program.prototype);\n\t\n\t  // and expression\n\t  function andExpr(exprs, stx) {\n\t    this.exprs  = exprs;\n\t    this.stx    = stx;\n\t    this.toString = function(){ return \"(and \"+this.exprs.join(\" \")+\")\"; };\n\t  };\n\t\n\t  // or expression\n\t  function orExpr(exprs, stx) {\n\t    this.exprs  = exprs;\n\t    this.stx    = stx;\n\t    this.toString = function(){ return \"(or \"+this.exprs.toString()+\")\"; };\n\t  };\n\t\n\t  // application expression\n\t  function callExpr(func, args, stx) {\n\t    Program.call(this);\n\t    this.func   = func;\n\t    this.args   = args;\n\t    this.stx    = stx;\n\t    this.toString = function(){\n\t      return \"(\"+[this.func].concat(this.args).join(\" \")+\")\";\n\t    };\n\t  };\n\t  callExpr.prototype = heir(Program.prototype);\n\t\n\t  // if expression\n\t  function ifExpr(predicate, consequence, alternative, stx) {\n\t    Program.call(this);\n\t    this.predicate = predicate;\n\t    this.consequence = consequence;\n\t    this.alternative = alternative;\n\t    this.stx = stx;\n\t    this.toString = function(){\n\t      return \"(if \"+this.predicate.toString()+\" \"+this.consequence.toString()+\" \"+this.alternative.toString()+\")\";\n\t    };\n\t  };\n\t  ifExpr.prototype = heir(Program.prototype);\n\t\n\t  // when/unless expression\n\t  function whenUnlessExpr(predicate, exprs, stx) {\n\t    Program.call(this);\n\t    this.predicate = predicate;\n\t    this.exprs = exprs;\n\t    this.stx = stx;\n\t    this.toString = function(){\n\t      return \"(\"+this.stx[0]+\" \"+this.predicate.toString()+\" \"+this.exprs.toString()+\")\";\n\t    };\n\t  };\n\t  whenUnlessExpr.prototype = heir(Program.prototype);\n\t\n\t  // symbol expression (ID)\n\t  function symbolExpr(val, stx) {\n\t    Program.call(this);\n\t    this.val = val;\n\t    this.stx = stx;\n\t  };\n\t  symbolExpr.prototype = heir(Program.prototype);\n\t\n\t  // Literal values (String, Char, Number, Vector)\n\t  function literal(val) {\n\t    Program.call(this);\n\t    this.val = val;\n\t    this.toString = function(){\n\t      // racket prints booleans using #t and #f\n\t      if(this.val===true) return \"#t\";\n\t      if(this.val===false) return \"#f\";\n\t      // racket prints special chars using their names\n\t      if(this.val instanceof Char){\n\t        var c = this.val.val;\n\t        return c === '\\b' ? '#\\\\backspace' :\n\t              c === '\\t' ? '#\\\\tab' :\n\t              c === '\\n' ? '#\\\\newline' :\n\t              c === ' '  ? '#\\\\space' :\n\t              c === '\\v' ? '#\\\\vtab' :\n\t              /* else */  this.val.toWrittenString();\n\t      }\n\t      return types.toWrittenString(this.val);\n\t    }\n\t  };\n\t  literal.prototype = heir(Program.prototype);\n\t\n\t  Vector.prototype.toString = Vector.prototype.toWrittenString = function(){\n\t    var filtered = this.elts.filter(function(e){return e!==undefined;}),\n\t        last = filtered[filtered.length-1];\n\t    return \"#(\"+this.elts.map(function(elt){return elt===undefined? last : elt;})+\")\";\n\t  }\n\t\n\t  // quoted expression\n\t  function quotedExpr(val) {\n\t    Program.call(this);\n\t    this.val = val;\n\t    this.toString = function() {\n\t      function quoteLikePairP(v) {\n\t        return v instanceof Array\n\t          && v.length === 2\n\t          && v[0] instanceof symbolExpr\n\t          && (    v[0].val === 'quasiquote'\n\t                  || v[0].val === 'quote'\n\t                  || v[0].val === 'unquote'\n\t                  || v[0].val === 'unquote-splicing'\n\t             ) }\n\t      function shortName(lexeme) {\n\t        var s = lexeme.val\n\t        return s === 'quasiquote' ? \"`\" :\n\t          s === 'quote' ? \"'\" :\n\t          s === 'unquote' ? \",\" :\n\t          s === 'unquote-splicing' ? \",@\" :\n\t          (function () { throw \"impossible quote-like string\" })()\n\t      }\n\t      function elementToString(v) {\n\t        if (quoteLikePairP(v)) {\n\t          return shortName(v[0]).concat(elementToString(v[1]))\n\t        } else if (v instanceof Array) {\n\t          return v.reduce(function (acc, x) { return acc.concat(elementToString(x)) }, \"(\").concat(\")\")\n\t        } else {\n\t          return v.toString()\n\t        }\n\t      }\n\t\n\t      return \"'\"+elementToString(this.val)\n\t    }\n\t  };\n\t  quotedExpr.prototype = heir(Program.prototype);\n\t\n\t  // unquoted expression\n\t  function unquotedExpr(val) {\n\t    Program.call(this);\n\t    this.val = val;\n\t    this.toString = function(){ return \",\"+this.val.toString(); };\n\t  };\n\t  unquotedExpr.prototype = heir(Program.prototype);\n\t\n\t  // quasiquoted expression\n\t  function quasiquotedExpr(val) {\n\t    Program.call(this);\n\t    this.val = val;\n\t    this.toString = function(){\n\t      if(this.val instanceof Array) return \"`(\"+this.val.toString()+\")\";\n\t      else return \"`\"+this.val.toString();\n\t    };\n\t  };\n\t  quasiquotedExpr.prototype = heir(Program.prototype);\n\t\n\t  // unquote-splicing\n\t  function unquoteSplice(val) {\n\t    Program.call(this);\n\t    this.val = val;\n\t    this.toString = function(){ return \",@\"+this.val.toString();};\n\t  };\n\t  unquoteSplice.prototype = heir(Program.prototype);\n\t\n\t  // require expression\n\t  function requireExpr(spec, stx) {\n\t    Program.call(this);\n\t    this.spec = spec;\n\t    this.stx  = stx;\n\t    this.toString = function(){ return \"(require \"+this.spec.toString()+\")\"; };\n\t  };\n\t  requireExpr.prototype = heir(Program.prototype);\n\t\n\t  // provide expression\n\t  function provideStatement(clauses, stx) {\n\t    Program.call(this);\n\t    this.clauses  = clauses;\n\t    this.stx      = stx;\n\t    this.toString = function(){ return \"(provide \"+this.clauses.toString()+\")\" };\n\t  };\n\t  provideStatement.prototype = heir(Program.prototype);\n\t\n\t  // Unsupported structure (allows us to generate parser errors ahead of \"unsupported\" errors)\n\t  function unsupportedExpr(val, errorMsg, errorSpan) {\n\t    Program.call(this);\n\t    this.val = val;\n\t    this.errorMsg = errorMsg;\n\t    this.errorSpan = errorSpan; // when throwing an error, we use a different span from the actual sexp span\n\t    this.toString = function(){ return this.val.toString() };\n\t  };\n\t  unsupportedExpr.prototype = heir(Program.prototype);\n\t\n\t\n\t  function isExpression(node){\n\t    return !(   (node instanceof defVar)\n\t             || (node instanceof defVars)\n\t             || (node instanceof defStruct)\n\t             || (node instanceof defFunc)\n\t             || (node instanceof provideStatement)\n\t             || (node instanceof unsupportedExpr)\n\t             || (node instanceof requireExpr));\n\t  }\n\t\n\t  function isDefinition(node){\n\t    return (node instanceof defVar)\n\t        || (node instanceof defVars)\n\t        || (node instanceof defStruct)\n\t        || (node instanceof defFunc);\n\t  }\n\t\n\t  /**************************************************************************\n\t   *\n\t   *    STRUCTURES NEEDED BY THE COMPILER\n\t   *\n\t   **************************************************************************/\n\t\n\t  // moduleBinding: records an id and its associated JS implementation.\n\t  function moduleBinding(name, bindings){\n\t    this.name     = name;\n\t    this.bindings = bindings;\n\t  }\n\t\n\t  // constantBinding: records an id and its associated JS implementation.\n\t  function constantBinding(name, moduleSource, permissions, loc){\n\t    this.name = name;\n\t    this.moduleSource = moduleSource;\n\t    this.permissions = permissions;\n\t    this.loc = loc;\n\t    this.toString = function(){return this.name;};\n\t    return this;\n\t  }\n\t\n\t  // functionBinding: try to record more information about the toplevel-bound function\n\t  function functionBinding(name, moduleSource, minArity, isVarArity, permissions, isCps, loc){\n\t    this.name = name;\n\t    this.moduleSource = moduleSource;\n\t    this.minArity = minArity;\n\t    this.isVarArity = isVarArity;\n\t    this.permissions = permissions;\n\t    this.isCps = isCps;\n\t    this.loc = loc;\n\t    this.toString = function(){return this.name;};\n\t    return this;\n\t  }\n\t\n\t  // structBinding: A binding to a structure.\n\t  // structBinding : symbol, ?, (listof symbol), symbol, symbol, (listof symbol) (listof symbol) (listof permission), location -> Binding\n\t  function structBinding(name, moduleSource, fields, constructor,\n\t                        predicate, accessors, mutators, permissions, loc){\n\t    this.name = name;\n\t    this.moduleSource = moduleSource;\n\t    this.fields = fields;\n\t    this.constructor = constructor;\n\t    this.predicate = predicate;\n\t    this.accessors = accessors;\n\t    this.mutators = mutators;\n\t    this.permissions = permissions;\n\t    this.loc = loc;\n\t    this.toString = function(){return this.name;};\n\t    return this;\n\t  }\n\t\n\t  var makeHash = types.makeLowLevelEqHash;\n\t  plt.compiler.keywords = [\"cond\", \"else\", \"let\", \"case\", \"let*\", \"letrec\", \"quote\",\n\t                              \"quasiquote\", \"unquote\",\"unquote-splicing\",\"local\",\"begin\",\n\t                              \"if\",\"or\",\"and\",\"when\",\"unless\",\"lambda\",\"λ\",\"define\",\n\t                              \"define-struct\", \"define-values\"];\n\t\n\t  // ENVIRONMENT STRUCTS ////////////////////////////////////////////////////////////////\n\t  // Representation of the stack environment of the mzscheme vm, so we know where\n\t  // things live.\n\t  function env(bindings){\n\t    var that = this;\n\t    this.bindings = bindings || makeHash();\n\t \n\t    // lookup : Symbol -> (or/c binding false)\n\t    this.lookup = function(id){\n\t      return (this.bindings.containsKey(id))? this.bindings.get(id) : false;\n\t    };\n\t \n\t    // peek: Number -> env\n\t    this.peek = function(depth){\n\t      return (depth==0)?                  this\n\t          :  (this instanceof emptyEnv)?  \"IMPOSSIBLE - peeked at an emptyEnv!\"\n\t           /* else */                   : this.parent.peek(depth-1);\n\t    };\n\t \n\t    // contains?: symbol -> boolean\n\t    this.contains = function(name){\n\t      return this.lookup(name) !== false;\n\t    };\n\t \n\t    // keys : -> (listof symbol)\n\t    this.keys = this.bindings.keys;\n\t \n\t    // extend: binding -> env\n\t    this.extend = function(binding){\n\t      this.bindings.put(binding.name, binding);\n\t      return new plt.compiler.env(this.bindings);\n\t    };\n\t \n\t    // extendFunction : symbol (or/c string false) number boolean? Loc -> env\n\t    // Extends the environment with a new function binding\n\t    this.extendFunction = function(id, moduleSource, minArity, isVarArity, loc){\n\t      return this.extend(new functionBinding(id, moduleSource, minArity, isVarArity, [], false, loc));\n\t    };\n\t \n\t    // extendConstant : string (modulePath || false) Loc -> env\n\t    this.extendConstant = function(id, moduleSource, loc){\n\t      return this.extend(new constantBinding(id, moduleSource, [], loc));\n\t    };\n\t \n\t    // lookup_context: identifier -> (binding | false)\n\t    // Lookup an identifier, taking into account the context of the identifier.  If it has no existing\n\t    // context, look at the given env. In either case, either return a binding, or false.\n\t    this.lookup_context = function(id){\n\t      if(id.context instanceof env){\n\t        return id.context.contains(id)? id.context.lookup(id) : false;\n\t      } else {\n\t        return that.contains(id)? that.lookup(id) : false;\n\t      }\n\t    };\n\t \n\t    // traverse rthe bindings of the module\n\t    this.extendEnv_moduleBinding = function(module){\n\t      return module.bindings.reduceRight(function(env, binding){ return env.extend(binding);}, this);\n\t    };\n\t \n\t    this.toString = function(){\n\t      return this.bindings.values().reduce(function(s, b){\n\t        return s+\"\\n  |---\"+b.name;}, \"\");\n\t    };\n\t  }\n\t \n\t  // sub-classes of env\n\t  function emptyEnv(){\n\t    env.call(this);\n\t    this.lookup = function(name, depth){ return new plt.compiler.unboundStackReference(name); };\n\t  }\n\t  emptyEnv.prototype = heir(env.prototype);\n\t \n\t  function unnamedEnv(parent){\n\t    env.call(this);\n\t    this.parent = parent;\n\t    this.lookup = function(name, depth){ return this.parent.lookup(name, depth+1); };\n\t  }\n\t  unnamedEnv.prototype = heir(env.prototype);\n\t \n\t  function localEnv(name, boxed, parent){\n\t    env.call(this);\n\t    this.name   = name;\n\t    this.boxed  = boxed;\n\t    this.parent = parent;\n\t    this.lookup = function(name, depth){\n\t      return (name===this.name)? new plt.compiler.localStackReference(name, this.boxed, depth)\n\t                              : this.parent.lookup(name, depth+1);\n\t    };\n\t  }\n\t  localEnv.prototype = heir(env.prototype);\n\t \n\t  function globalEnv(names, boxed, parent){\n\t    env.call(this);\n\t    this.names  = names;\n\t    this.boxed  = boxed;\n\t    this.parent = parent;\n\t    var that = this;\n\t    this.lookup = function(name, depth){\n\t      var pos = this.names.indexOf(name);\n\t      return (pos > -1)? new plt.compiler.globalStackReference(name, depth, pos)\n\t                  : this.parent.lookup(name, depth+1);\n\t    };\n\t  }\n\t  globalEnv.prototype = heir(env.prototype);\n\t \n\t  // PINFO STRUCTS ////////////////////////////////////////////////////////////////\n\t  var defaultCurrentModulePath = \"\";\n\t \n\t  // default-module-resolver: symbol -> (module-binding | false)\n\t  // loop through known modules and see if we know this name\n\t  plt.compiler.defaultModuleResolver = function(name){\n\t    for(var i=0; i<plt.compiler.knownModules.length; i++){\n\t      if(plt.compiler.knownModules[i].name === name) return plt.compiler.knownModules[i];\n\t    }\n\t    return false;\n\t  }\n\t \n\t  // Compute the edit distance between the two given strings\n\t  // from http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance\n\t  function levenshteinDistance(a, b) {\n\t    if(a.length === 0) return b.length; \n\t    if(b.length === 0) return a.length; \n\t   \n\t    var matrix = [];\n\t   \n\t    // increment along the first column of each row\n\t    for(var i = 0; i <= b.length; i++){ matrix[i] = [i]; }\n\t   \n\t    // increment each column in the first row\n\t    for(var j = 0; j <= a.length; j++){ matrix[0][j] = j; }\n\t   \n\t    // Fill in the rest of the matrix\n\t    for(i = 1; i <= b.length; i++){\n\t      for(j = 1; j <= a.length; j++){\n\t        if(b.charAt(i-1) == a.charAt(j-1)){\n\t          matrix[i][j] = matrix[i-1][j-1];\n\t        } else {\n\t          matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, // substitution\n\t                                  Math.min(matrix[i][j-1] + 1, // insertion\n\t                                           matrix[i-1][j] + 1)); // deletion\n\t        }\n\t      }\n\t    }\n\t    return matrix[b.length][a.length];\n\t  };\n\t \n\t  // moduleGuess: symbol -> symbol\n\t  // loop through known modules and make best suggestion for a given name\n\t  plt.compiler.moduleGuess = function(wrongName){\n\t    return plt.compiler.knownModules.reduce(function(best, module){\n\t                                            var dist = levenshteinDistance(module.name, wrongName);\n\t                                            return (dist < best.distance)? {name: module.name, distance: dist} : best;\n\t      }, {name: wrongName, distance: 5});\n\t  }\n\t \n\t  // default-module-path-resolver: module-path module-path -> module-name\n\t  // Provides a default module resolver.\n\t  plt.compiler.defaultModulePathResolver = function(path, parentPath){\n\t/*    var name = (path instanceof symbolExpr)? path : modulePathJoin(parentPath, path)),\n\t        moduleName = knownModules.reduceRight(function(name, km){\n\t              return (km.source === modulePathJoin(parentPath, path))? km.name : name;}\n\t                                              , name);\n\t*/ \n\t    // anything of the form wescheme/w+, or that has a known collection AND module\n\t    var parts = path.toString().split(\"/\"),\n\t        collectionName = parts[0],\n\t        moduleName = parts.slice(1).join();\n\t    return ((plt.compiler.knownCollections.indexOf(collectionName) > -1)\n\t            && plt.compiler.defaultModuleResolver(path.toString()))\n\t          || /^wescheme\\/\\w+$/.exec(path);\n\t  }\n\t \n\t\n\t  // pinfo (program-info) is the \"world\" structure for the compilers;\n\t  // it captures the information we get from analyzing and compiling\n\t  // the program, and also maintains some auxillary structures.\n\t  function pinfo(env, modules, usedBindingsHash, freeVariables, gensymCounter,\n\t                 providedNames,definedNames, sharedExpressions,\n\t                 withLocationEmits, allowRedefinition,\n\t                 moduleResolver, modulePathResolver, currentModulePath,\n\t                 declaredPermissions){\n\t    this.env = env || new emptyEnv();                       // env\n\t    this.modules = modules || [];                           // (listof module-binding)\n\t    this.usedBindingsHash = usedBindingsHash || makeHash(); // (hashof symbol binding)\n\t    this.freeVariables = freeVariables || [];               // (listof symbol)\n\t    this.gensymCounter = gensymCounter || 0;                // number\n\t    this.providedNames = providedNames || makeHash();       // (hashof symbol provide-binding)\n\t    this.definedNames  = definedNames  || makeHash();       // (hashof symbol binding)\n\t \n\t    this.sharedExpressions = sharedExpressions || makeHash();// (hashof expression labeled-translation)\n\t    // Maintains a mapping between expressions and a labeled translation.  Acts\n\t    // as a symbol table to avoid duplicate construction of common literal values.\n\t\n\t    this.withLocationEmits = withLocationEmits || true;     // boolean\n\t    // If true, the compiler emits calls to plt.Kernel.setLastLoc to maintain\n\t    // source position during evaluation.\n\t\n\t    this.allowRedefinition = allowRedefinition || false;     // boolean\n\t    // If true, redefinition of a value that's already defined will not raise an error.\n\t \n\t    // For the module system.\n\t    // (module-name -> (module-binding | false))\n\t    this.moduleResolver = moduleResolver || plt.compiler.defaultModuleResolver;\n\t    // (string module-path -> module-name)\n\t    this.modulePathResolver = modulePathResolver || plt.compiler.defaultModulePathResolver;\n\t    // module-path\n\t    this.currentModulePath = currentModulePath || defaultCurrentModulePath;\n\t \n\t    this.declaredPermissions = declaredPermissions || [];   // (listof (listof symbol any/c))\n\t \n\t    /////////////////////////////////////////////////\n\t    // functions for manipulating pinfo objects\n\t    this.isRedefinition = function(name){ return this.env.lookup(name); };\n\t \n\t    // usedBindings: -> (listof binding)\n\t    // Returns the list of used bindings computed from the program analysis.\n\t    this.usedBindings =  this.usedBindingsHash.values;\n\t \n\t    this.accumulateDeclaredPermission = function(name, permission){\n\t      this.declaredPermissions = [[name, permission]].concat(this.declaredPermissions);\n\t      return this;\n\t    };\n\t \n\t    this.accumulateSharedExpression = function(expression, translation){\n\t      var labeledTranslation = makeLabeledTranslation(this.gensymCounter, translation);\n\t      this.sharedExpressions.put(labeledTranslation, expression);\n\t      return this;\n\t    };\n\t \n\t    // accumulateDefinedBinding: binding loc -> pinfo\n\t    // Adds a new defined binding to a pinfo's set.\n\t    this.accumulateDefinedBinding = function(binding, loc){\n\t      if(plt.compiler.keywords.indexOf(binding.name) > -1){\n\t        throwError(new types.Message([new types.ColoredPart(binding.name, binding.loc),\n\t                                  \": this is a reserved keyword and cannot be used\"+\n\t                                  \" as a variable or function name\"])\n\t                   ,binding.loc);\n\t      } else if(!this.allowRedefinition && this.isRedefinition(binding.name)){\n\t        var prevBinding = this.env.lookup(binding.name);\n\t        if(prevBinding.loc){\n\t          throwError(new types.Message([new types.ColoredPart(binding.name, binding.loc),\n\t                                    \": this name has a \",\n\t                                    new types.ColoredPart(\"previous definition\", prevBinding.loc),\n\t                                    \" and cannot be re-defined\"])\n\t                     ,binding.loc);\n\t \n\t        } else {\n\t          throwError(new types.Message([new types.ColoredPart(binding.name, binding.loc),\n\t                                    \": this name has a \",\n\t                                    \"previous definition\",\n\t                                    \" and cannot be re-defined\"])\n\t                     ,binding.loc);\n\t\n\t        }\n\t      } else {\n\t        this.env.extend(binding);\n\t        this.definedNames.put(binding.name, binding);\n\t        return this;\n\t      }\n\t    };\n\t \n\t    // accumulateBindings: (listof binding) Loc -> pinfo\n\t    // Adds a list of defined bindings to the pinfo's set.\n\t    this.accumulateDefinedBindings = function(bindings, loc){\n\t      var that = this;\n\t      bindings.forEach(function(b){that.accumulateDefinedBinding(b, loc);});\n\t      return this;\n\t    };\n\t \n\t \n\t    // accumuldateModuleBindings: (listof binding) -> pinfo\n\t    // Adds a list of module-imported bindings to the pinfo's known set of bindings, without\n\t    // including them within the set of defined names.\n\t    this.accumulateModuleBindings = function(bindings){\n\t      var that = this;\n\t      bindings.forEach(function(b){that.env.extend(b);});\n\t      return this;\n\t    };\n\t   \n\t    // accumulateModule: module-binding -> pinfo\n\t    // Adds a module to the pinfo's set.\n\t    this.accumulateModule = function(module){\n\t      this.modules = [module].concat(this.modules);\n\t      return this;\n\t    };\n\t\n\t    // accumulateBindingUse: binding -> pinfo\n\t    // Adds a binding's use to a pinfo's set, if it has not already been used as a global\n\t    // This qualifier allows a fn argument to shadow a global, without removing it from the environment\n\t    this.accumulateBindingUse = function(binding){\n\t      var alreadyExists = this.usedBindingsHash.get(binding.name);\n\t      // if it's a module binding, don't replace it with a different kind of binding\n\t      if(!(alreadyExists && alreadyExists.moduleSource)) this.usedBindingsHash.put(binding.name, binding);\n\t      return this;\n\t    };\n\t   \n\t    // accumulateFreeVariableUse: symbol -> pinfo\n\t    // Mark a free variable usage.\n\t    this.accumulateFreeVariableUse = function(sym){\n\t      this.freeVariables = ((this.freeVariables.indexOf(sym) > -1)?\n\t                            this.freeVariables : [sym].concat(this.freeVariables));\n\t      return this;\n\t    };\n\t   \n\t    // gensym: symbol -> [pinfo, symbol]\n\t    // Generates a unique symbol\n\t    this.gensym = function(label){\n\t      return [this, new symbolExpr(label+this.gensymCounter++)];\n\t    };\n\t \n\t    // permissions: -> (listof permission)\n\t    // Given a pinfo, collect the list of permissions.\n\t    this.permissions = function(){\n\t      // onlyUnique : v, idx, arr -> arr with unique elts\n\t      // from http://stackoverflow.com/questions/1960473/unique-values-in-an-array\n\t      function onlyUnique(value, index, self) { return self.indexOf(value) === index; }\n\t      // if it's a function or constant binding, add its permissions to the list\n\t      function reducePermissions(permissions, b){\n\t        return (((b instanceof functionBinding) || (b instanceof constantBinding))\n\t                && (b.permissions.length > 0))?\n\t              permissions.concat(b.permissions) : permissions;\n\t      }\n\t      return this.usedBindings().reduce(reducePermissions, []).filter(onlyUnique);\n\t    }\n\t\n\t    // getExposedBindings:  -> (listof binding)\n\t    // Extract the list of the defined bindings that are exposed by provide.\n\t    this.getExposedBindings = function(){\n\t      var that = this;\n\t      // lookupProvideBindingInDefinitionBindings: provide-binding compiled-program -> (listof binding)\n\t      // Lookup the provided bindings.\n\t      function lookupProvideBindingInDefinitionBindings(provideBinding){\n\t        // if it's not defined, throw an error\n\t        if(!that.definedNames.containsKey(provideBinding.symbl)){\n\t          throwError(new types.Message([\"provided-name-not-defined: \", provideBinding.symbl]));\n\t        }\n\t        // if it IS defined, let's examine it and make sure it is what it claims to be\n\t        var binding = checkBindingCompatibility(binding, that.definedNames.get(provideBinding.symbl));\n\t\n\t        // ref: symbol -> binding\n\t        // Lookup the binding, given the symbolic identifier.\n\t        function ref(id){ return that.definedNames.get(id); }\n\t\n\t        // if it's a struct provide, return a list containing the constructor and predicate,\n\t        // along with all the accessor and mutator functions\n\t        if(provideBinding instanceof plt.compiler.provideBindingStructId){\n\t          return [ref(binding.constructor), ref(binding.predicate)].concat(\n\t              binding.accessors.map(ref), binding.mutators.map(ref));\n\t        } else {\n\t          return [binding];\n\t        }\n\t      }\n\t \n\t      // decorateWithPermissions: binding -> binding\n\t      // THIS IS A HACK according to Danny's original sources...not sure why\n\t      function decorateWithPermissions(binding){\n\t        var bindingEntry = function(entry){return entry[0]===binding.name;},\n\t            filteredPermissions = that.declaredPermissions.filter(bindingEntry);\n\t        binding.permissions = filteredPermissions.map(function(p){return p[1];});\n\t        return binding;\n\t      }\n\t\n\t      // Make sure that if the provide says \"struct-out ...\", that the exported binding\n\t      // is really a structure.\n\t      function checkBindingCompatibility(binding, exportedBinding){\n\t        if(  (binding instanceof plt.compiler.provideBindingStructId)\n\t          && (!(exportedBinding instanceof structBinding))){\n\t            throwError(new types.Message([\"provided-structure-not-structure: \", exportedBinding.symbl]));\n\t        } else {\n\t          return exportedBinding;\n\t        }\n\t      }\n\t \n\t      // for each provide binding, ensure it's defined and then decorate with permissions\n\t      // concat all the permissions and bindings together, and return\n\t      bindings = bindings.reduce(function(acc, b){ return acc.concat(lookupProvideBindingInDefinitionBindings(b)); }, []);\n\t      return bindings.map(decorateWithPermissions);\n\t    };\n\t \n\t    this.toString = function(){\n\t       var s = \"pinfo-------------\";\n\t       s+= \"\\n**env****: \"+this.env.toString();\n\t       s+= \"\\n**modules**: \"+this.modules.join(\",\");\n\t       s+= \"\\n**used bindings**: \"+this.usedBindings();\n\t       s+= \"\\n**free variables**: \"+this.freeVariables.join(\",\");\n\t       s+= \"\\n**gensym counter**: \"+this.gensymCounter;\n\t       s+= \"\\n**provided names**: \"+this.providedNames.values();\n\t       s+= \"\\n**defined names**: \"+this.definedNames.values();\n\t       s+= \"\\n**permissions**: \"+this.permissions();\n\t       return s;\n\t    };\n\t }\n\t \n\t // getBasePinfo: symbol -> pinfo\n\t // Returns a pinfo that knows the base definitions. Language can be one of the following:\n\t // 'base\n\t // 'moby\n\t function getBasePinfo(language){\n\t    // fixme: use the language to limit what symbols get in the toplevel.\n\t    var baseConstantsEnv = [\"null\", \"empty\", \"true\"//effect:do-nothing\n\t                           , \"false\", \"eof\", \"pi\", \"e\",\"js-undefined\"\n\t                           , \"js-null\"].reduce(function(env, id){\n\t                                               return env.extendConstant(id.toString(), '\"moby/toplevel\"', false)\n\t                                               }, new emptyEnv());\n\t\n\t    var pinfo = new plt.compiler.pinfo(),\n\t        topLevelEnv = plt.compiler.topLevelModules.reduceRight(function(env, mod){\n\t                                                               return env.extendEnv_moduleBinding(mod);\n\t                                                               }, baseConstantsEnv);\n\t    if(language === \"moby\"){\n\t      pinfo.env = topLevelEnv.extendEnv_moduleBinding(mobyModuleBinding);\n\t    } else if(language === \"base\"){\n\t      pinfo.env = topLevelEnv;\n\t    }\n\t    return pinfo;\n\t }\n\t \n\t plt.compiler.throwError    = throwError;\n\t \n\t plt.compiler.Program       = Program;\n\t plt.compiler.couple        = couple;\n\t plt.compiler.defFunc       = defFunc;\n\t plt.compiler.defVar        = defVar;\n\t plt.compiler.defVars       = defVars;\n\t plt.compiler.defStruct     = defStruct;\n\t plt.compiler.beginExpr     = beginExpr;\n\t plt.compiler.lambdaExpr    = lambdaExpr;\n\t plt.compiler.localExpr     = localExpr;\n\t plt.compiler.letrecExpr    = letrecExpr;\n\t plt.compiler.letExpr       = letExpr;\n\t plt.compiler.letStarExpr   = letStarExpr;\n\t plt.compiler.condExpr      = condExpr;\n\t plt.compiler.caseExpr      = caseExpr;\n\t plt.compiler.andExpr       = andExpr;\n\t plt.compiler.orExpr        = orExpr;\n\t plt.compiler.callExpr      = callExpr;\n\t plt.compiler.ifExpr        = ifExpr;\n\t plt.compiler.whenUnlessExpr= whenUnlessExpr;\n\t plt.compiler.symbolExpr    = symbolExpr;\n\t plt.compiler.literal       = literal;\n\t plt.compiler.quotedExpr    = quotedExpr;\n\t plt.compiler.unquotedExpr  = unquotedExpr;\n\t plt.compiler.quasiquotedExpr=quasiquotedExpr;\n\t plt.compiler.unquoteSplice = unquoteSplice;\n\t plt.compiler.requireExpr   = requireExpr;\n\t plt.compiler.provideStatement = provideStatement;\n\t plt.compiler.unsupportedExpr= unsupportedExpr;\n\t\n\t plt.compiler.pinfo       = pinfo;\n\t plt.compiler.getBasePinfo= getBasePinfo;\n\t plt.compiler.isExpression= isExpression;\n\t plt.compiler.isDefinition= isDefinition;\n\t plt.compiler.env         = env;\n\t plt.compiler.emptyEnv    = emptyEnv;\n\t plt.compiler.localEnv    = localEnv;\n\t plt.compiler.globalEnv   = globalEnv;\n\t plt.compiler.moduleBinding  = moduleBinding;\n\t plt.compiler.functionBinding  = functionBinding;\n\t plt.compiler.constantBinding  = constantBinding;\n\t plt.compiler.structBinding  = structBinding;\n\t plt.compiler.unnamedEnv  = unnamedEnv;\n\t})();\n\t\n\tmodule.exports = plt.compiler;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//////////////////////////////////////////////////////////////////////\n\t// helper functions\n\t\n\tvar jsnums = __webpack_require__(4);\n\tvar _Hashtable = __webpack_require__(5);\n\t\n\tvar types = {};\n\t\n\t\n\t(function () {\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t\n\tvar appendChild = function(parent, child) {\n\t    parent.appendChild(child);\n\t};\n\t\n\t\n\t\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t\n\t\n\tvar _eqHashCodeCounter = 0;\n\tvar makeEqHashCode = function() {\n\t    _eqHashCodeCounter++;\n\t    return _eqHashCodeCounter;\n\t};\n\t\n\t    \n\t// getHashCode: any -> (or fixnum string)\n\t// Produces a hashcode appropriate for eq.\n\tvar getEqHashCode = function(x) {\n\t    if (x && !x._eqHashCode) {\n\t\tx._eqHashCode = makeEqHashCode();\n\t    }\n\t    if (x && x._eqHashCode) {\n\t\treturn x._eqHashCode;\n\t    }\n\t    if (typeof(x) == 'string') {\n\t\treturn x;\n\t    }\n\t    return 0;\n\t};\n\t\n\t\n\t// Union/find for circular equality testing.\n\t\n\tvar UnionFind = function() {\n\t\t// this.parenMap holds the arrows from an arbitrary pointer\n\t\t// to its parent.\n\t\tthis.parentMap = makeLowLevelEqHash();\n\t}\n\t\n\t// find: ptr -> UnionFindNode\n\t// Returns the representative for this ptr.\n\tUnionFind.prototype.find = function(ptr) {\n\t\tvar parent = (this.parentMap.containsKey(ptr) ? \n\t\t\t      this.parentMap.get(ptr) : ptr);\n\t\tif (parent === ptr) {\n\t\t    return parent;\n\t\t} else {\n\t\t    var rep = this.find(parent);\n\t\t    // Path compression:\n\t\t    this.parentMap.put(ptr, rep);\n\t\t    return rep;\n\t\t}\n\t};\n\t\n\t// merge: ptr ptr -> void\n\t// Merge the representative nodes for ptr1 and ptr2.\n\tUnionFind.prototype.merge = function(ptr1, ptr2) {\n\t\tthis.parentMap.put(this.find(ptr1), this.find(ptr2));\n\t};\n\t\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t// Class inheritance infrastructure\n\t\n\t// This code copied directly from http://ejohn.org/blog/simple-javascript-inheritance/\n\tvar Class = (function(){\n\t\tvar initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\\b_super\\b/ : /.*/;\n\t\t// The base Class implementation (does nothing)\n\t\tvar innerClass = function(){};\n\t\t\n\t\t// Create a new Class that inherits from this class\n\t\tinnerClass.extend = function(prop) {\n\t\t\tvar _super = this.prototype;\n\t\t\t\n\t\t\t// Instantiate a base class (but only create the instance,\n\t\t\t// don't run the init constructor)\n\t\t\tinitializing = true;\n\t\t\tvar prototype = new this();\n\t\t\tinitializing = false;\n\t\t\t\n\t\t\t// Copy the properties over onto the new prototype\n\t\t\tfor (var name in prop) {\n\t\t\t\t// Check if we're overwriting an existing function\n\t\t\t\tprototype[name] = typeof prop[name] == \"function\" && \n\t\t\t\t\ttypeof _super[name] == \"function\" && fnTest.test(prop[name]) ?\n\t\t\t\t\t(function(name, fn){\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar tmp = this._super;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Add a new ._super() method that is the same method\n\t\t\t\t\t\t\t// but on the super-class\n\t\t\t\t\t\t\tthis._super = _super[name];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// The method only need to be bound temporarily, so we\n\t\t\t\t\t\t\t// remove it when we're done executing\n\t\t\t\t\t\t\tvar ret = fn.apply(this, arguments);\t\t\t\t\n\t\t\t\t\t\t\tthis._super = tmp;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t};\n\t\t\t\t\t})(name, prop[name]) :\n\t\t\t\t\tprop[name];\n\t\t\t}\n\t\t\t\n\t\t\t// The dummy class constructor\n\t\t\tvar Dummy = function() {\n\t\t\t\t// All construction is actually done in the init method\n\t\t\t\tif ( !initializing && this.init )\n\t\t\t\t\tthis.init.apply(this, arguments);\n\t\t\t}\n\t\t\t\n\t\t\t// Populate our constructed prototype object\n\t\t\tDummy.prototype = prototype;\n\t\t\t\n\t\t\t// Enforce the constructor to be what we expect\n\t\t\tDummy.constructor = Dummy;\n\t\n\t\t\t// And make this class extendable\n\t\t\tDummy.extend = arguments.callee;\n\t\t\t\n\t\t\treturn Dummy;\n\t\t};\n\t\treturn innerClass;\n\t})();\n\t \n\tfunction makeLParen(){\n\t   var node = document.createElement('span');\n\t   node.appendChild(document.createTextNode(\"(\"));\n\t   node.className = \"lParen\";\n\t   return node;\n\t}\n\t\n\tfunction makeRParen(){\n\t   var node = document.createElement('span');\n\t   node.appendChild(document.createTextNode(\")\"));\n\t   node.className = \"rParen\";\n\t   return node;\n\t}\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t\n\tvar StructType = function(name, type, numberOfArgs, numberOfFields, firstField,\n\t\t\t      constructor, predicate, accessor, mutator) {\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.numberOfArgs = numberOfArgs;\n\t\tthis.numberOfFields = numberOfFields;\n\t\tthis.firstField = firstField;\n\t\n\t\tthis.constructor = constructor;\n\t\tthis.predicate = predicate;\n\t\tthis.accessor = accessor;\n\t\tthis.mutator = mutator;\n\t};\n\t\n\tStructType.prototype.toString = function() {\n\t\treturn '#<struct-type:' + this.name + '>';\n\t};\n\t\n\tStructType.prototype.isEqual = function(other, aUnionFind) {\n\t\treturn this === other;\n\t};\n\t\n\t\n\tvar makeStructureType = function(theName, parentType, initFieldCnt, autoFieldCnt, autoV, guard) {\n\t    // If no parent type given, then the parent type is Struct\n\t    if ( !parentType ) {\n\t\tparentType = ({type: Struct,\n\t\t\t       numberOfArgs: 0,\n\t\t\t       numberOfFields: 0,\n\t\t\t       firstField: 0});\n\t    }\n\t    var numParentArgs = parentType.numberOfArgs;\n\t\n\t    // Create a new struct type inheriting from the parent\n\t    var aStruct = parentType.type.extend({\n\t\tinit: function(name, initArgs) {\n\t\t\t// if there's no guard, construct a default one\n\t\n\t\t\tif (!guard) {\n\t\t\t\tguard = function(k) {\n\t\t\t\t\tif (arguments.length == 3) {\n\t\t\t\t\t\tk(arguments[1]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar args = [];\n\t\t\t\t\t\tvar i;\n\t\t\t\t\t\tfor(i = 1; i < arguments.length-1; i++) {\n\t\t\t\t\t\t\targs.push(arguments[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk(new ValuesWrapper(args));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar that = this;\n\t\t\tvar cont = function(guardRes) {\n\t\t\t\tvar guardedArgs;\n\t\t\t\tif ( guardRes instanceof ValuesWrapper ) {\n\t\t\t\t\tguardedArgs = guardRes.elts;\n\t\t\t\t} else {\n\t\t\t\t\tguardedArgs = [guardRes];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar parentArgs = guardedArgs.slice(0, numParentArgs);\n\t\t\t\tthat._super(name, parentArgs);\n\t\n\t\t\t\tfor (var i = 0; i < initFieldCnt; i++) {\n\t\t\t\t\tthat._fields.push(guardedArgs[i+numParentArgs]);\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < autoFieldCnt; i++) {\n\t\t\t\t\tthat._fields.push(autoV);\n\t\t\t\t}\n\t\t\t};\n\t\t\tinitArgs.unshift(cont);\n\t\t\tinitArgs.push(Symbol.makeInstance(name));\n\t\t\tguard.apply(null, initArgs);\n\t\t}\n\t    });\n\t    // Set type, necessary for equality checking\n\t    aStruct.prototype.type = aStruct;\n\t\n\t    // construct and return the new type\n\t    return new StructType(theName,\n\t\t\t\t  aStruct,\n\t\t\t\t  initFieldCnt + numParentArgs,\n\t\t\t\t  initFieldCnt + autoFieldCnt,\n\t\t\t\t  parentType.firstField + parentType.numberOfFields,\n\t\t\t\t  function() {\n\t\t\t\t  \tvar args = [];\n\t\t\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\t\t\targs.push(arguments[i]);\n\t\t\t\t\t}\n\t\t\t\t\treturn new aStruct(theName, args);\n\t\t\t\t  },\n\t\t\t\t  function(x) { return x instanceof aStruct; },\n\t\t\t\t  function(x, i) { return x._fields[i + this.firstField]; },\n\t\t\t\t  function(x, i, v) { x._fields[i + this.firstField] = v; });\n\t};\n\t\n\t// Structures.\n\tvar Struct = Class.extend({\n\t\tinit: function (constructorName, fields) {\n\t\t    this._constructorName = constructorName; \n\t\t    this._fields = [];\n\t\t},\n\t\n\t\ttoWrittenString: function(cache) { \n\t\t    //    cache.put(this, true);\n\t\t    var buffer = [];\n\t\t    var i;\n\t\t    buffer.push(\"(\");\n\t\t    buffer.push(this._constructorName);\n\t\t    for(i = 0; i < this._fields.length; i++) {\n\t\t\tbuffer.push(\" \");\n\t\t\tbuffer.push(toWrittenString(this._fields[i], cache));\n\t\t    }\n\t\t    buffer.push(\")\");\n\t\t    return buffer.join(\"\");\n\t\t},\n\t\n\t\ttoDisplayedString: function(cache) { return this.toWrittenString(cache); },\n\t\n\t\ttoDomNode: function(cache) {\n\t\t    //    cache.put(this, true);\n\t\t    var node = document.createElement(\"div\"),\n\t            constructor= document.createElement(\"span\");\n\t            constructor.appendChild(document.createTextNode(this._constructorName));\n\t\t    var i;\n\t\t    node.appendChild(makeLParen());\n\t\t    node.appendChild(constructor);\n\t\t    for(i = 0; i < this._fields.length; i++) {\n\t                appendChild(node, toDomNode(this._fields[i], cache));\n\t\t    }\n\t\t    node.appendChild(makeRParen());\n\t\t    return node;\n\t\t},\n\t\n\t\n\t\tisEqual: function(other, aUnionFind) {\n\t\t    if ( other.type == undefined ||\n\t\t\t this.type !== other.type ||\n\t\t\t !(other instanceof this.type) ) {\n\t\t\t    return false;\n\t\t    }\n\t\n\t\t    for (var i = 0; i < this._fields.length; i++) {\n\t\t\tif (! isEqual(this._fields[i],\n\t\t\t\t      other._fields[i],\n\t\t\t\t      aUnionFind)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t    }\n\t\t    return true;\n\t\t}\n\t});\n\tStruct.prototype.type = Struct;\n\t\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t// Regular expressions.\n\t\n\tvar RegularExpression = function(pattern) {\n\t    this.pattern = pattern;\n\t};\n\t\n\t\n\tvar ByteRegularExpression = function(pattern) {\n\t    this.pattern = pattern;\n\t};\n\t\n\t\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t// Paths\n\t\n\tvar Path = function(p) {\n\t    this.path = p;\n\t};\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t// Bytes\n\t\n\tvar Bytes = function(bts, mutable) {\n\t    this.bytes = bts;\n\t    this.mutable = (mutable === undefined) ? false : mutable;\n\t};\n\t\n\tBytes.prototype.get = function(i) {\n\t\treturn this.bytes[i];\n\t};\n\t\n\tBytes.prototype.set = function(i, b) {\n\t\tif (this.mutable) {\n\t\t\tthis.bytes[i] = b;\n\t\t}\n\t};\n\t\n\tBytes.prototype.length = function() {\n\t\treturn this.bytes.length;\n\t};\n\t\n\tBytes.prototype.copy = function(mutable) {\n\t\treturn new Bytes(this.bytes.slice(0), mutable);\n\t};\n\t\n\tBytes.prototype.subbytes = function(start, end) {\n\t\tif (end == null || end == undefined) {\n\t\t\tend = this.bytes.length;\n\t\t}\n\t\t\n\t\treturn new Bytes( this.bytes.slice(start, end), true );\n\t};\n\t\n\t\n\tBytes.prototype.toString = function() {\n\t\tvar ret = '';\n\t\tfor (var i = 0; i < this.bytes.length; i++) {\n\t\t\tret += String.fromCharCode(this.bytes[i]);\n\t\t}\n\t\n\t\treturn ret;\n\t};\n\t\n\tBytes.prototype.toDisplayedString = Bytes.prototype.toString;\n\t\n\tBytes.prototype.toWrittenString = function() {\n\t\tvar ret = ['#\"'];\n\t\tfor (var i = 0; i < this.bytes.length; i++) {\n\t\t\tret.push( escapeByte(this.bytes[i]) );\n\t\t}\n\t\tret.push('\"');\n\t\treturn ret.join('');\n\t};\n\t\n\tvar escapeByte = function(aByte) {\n\t\tvar ret = [];\n\t\tvar returnVal;\n\t\tswitch(aByte) {\n\t\t\tcase 7: returnVal = '\\\\a'; break;\n\t\t\tcase 8: returnVal = '\\\\b'; break;\n\t\t\tcase 9: returnVal = '\\\\t'; break;\n\t\t\tcase 10: returnVal = '\\\\n'; break;\n\t\t\tcase 11: returnVal = '\\\\v'; break;\n\t\t\tcase 12: returnVal = '\\\\f'; break;\n\t\t\tcase 13: returnVal = '\\\\r'; break;\n\t\t\tcase 34: returnVal = '\\\\\"'; break;\n\t\t\tcase 92: returnVal = '\\\\\\\\'; break;\n\t\t\tdefault: if (val >= 32 && val <= 126) {\n\t\t\t\t\t returnVal = String.fromCharCode(val);\n\t\t\t\t }\n\t\t\t\t else {\n\t\t\t\t\t ret.push( '\\\\' + val.toString(8) );\n\t\t\t\t }\n\t\t\t\t break;\n\t\t}\n\t\treturn returnVal;\n\t};\n\t\n\t\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t// Boxes\n\t    \n\tvar Box = function(x, mutable) {\n\t\tthis.val = x;\n\t\tthis.mutable = mutable;\n\t};\n\t\n\tBox.prototype.unbox = function() {\n\t    return this.val;\n\t};\n\t\n\tBox.prototype.set = function(newVal) {\n\t    if (this.mutable) {\n\t\t    this.val = newVal;\n\t    }\n\t};\n\t\n\tBox.prototype.toString = function() {\n\t    return \"#&\" + this.val.toString();\n\t};\n\t\n\tBox.prototype.toWrittenString = function(cache) {\n\t    return \"#&\" + toWrittenString(this.val, cache);\n\t};\n\t\n\tBox.prototype.toDisplayedString = function(cache) {\n\t    return \"#&\" + toDisplayedString(this.val, cache);\n\t};\n\t\n\tBox.prototype.toDomNode = function(cache) {\n\t    var parent = document.createElement(\"span\"),\n\t    boxSymbol = document.createElement(\"span\");\n\t    boxSymbol.appendChild(document.createTextNode(\"#&\"));\n\t    parent.className = \"wescheme-box\";\n\t    parent.appendChild(boxSymbol);\n\t    parent.appendChild(toDomNode(this.val, cache));\n\t    return parent;\n\t};\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t// We are reusing the built-in Javascript boolean class here.\n\tLogic = {\n\t    TRUE : true,\n\t    FALSE : false\n\t};\n\t\n\t// WARNING\n\t// WARNING: we are extending the built-in Javascript boolean class here!\n\t// WARNING\n\tBoolean.prototype.toWrittenString = function(cache) {\n\t    if (this.valueOf()) { return \"true\"; }\n\t    return \"false\";\n\t};\n\tBoolean.prototype.toDisplayedString = Boolean.prototype.toWrittenString;\n\t\n\tBoolean.prototype.toString = function() { return this.valueOf() ? \"true\" : \"false\"; };\n\t\n\tBoolean.prototype.isEqual = function(other, aUnionFind){\n\t    return this == other;\n\t};\n\t\n\t\n\t\n\t\n\t// Chars\n\t// Char: string -> Char\n\tChar = function(val){\n\t    this.val = val;\n\t};\n\t    \n\tChar.makeInstance = function(val){\n\t    return new Char(val);\n\t};\n\t\n\tChar.prototype.toString = function() {\n\t\tvar code = this.val.charCodeAt(0);\n\t\tvar returnVal;\n\t\tswitch (code) {\n\t\t\tcase 0: returnVal = '#\\\\nul'; break;\n\t\t\tcase 8: returnVal = '#\\\\backspace'; break;\n\t\t\tcase 9: returnVal = '#\\\\tab'; break;\n\t\t\tcase 10: returnVal = '#\\\\newline'; break;\n\t\t\tcase 11: returnVal = '#\\\\vtab'; break;\n\t\t\tcase 12: returnVal = '#\\\\page'; break;\n\t\t\tcase 13: returnVal = '#\\\\return'; break;\n\t\t\tcase 20: returnVal = '#\\\\space'; break;\n\t\t\tcase 127: returnVal = '#\\\\rubout'; break;\n\t\t\tdefault: if (code >= 32 && code <= 126) {\n\t\t\t\t\t returnVal = (\"#\\\\\" + this.val);\n\t\t\t\t }\n\t\t\t\t else {\n\t\t\t\t\t var numStr = code.toString(16).toUpperCase();\n\t\t\t\t\t while (numStr.length < 4) {\n\t\t\t\t\t\t numStr = '0' + numStr;\n\t\t\t\t\t }\n\t\t\t\t\t returnVal = ('#\\\\u' + numStr);\n\t\t\t\t }\n\t\t\t\t break;\n\t\t}\n\t\treturn returnVal;\n\t};\n\t\n\tChar.prototype.toWrittenString = Char.prototype.toString;\n\t\n\tChar.prototype.toDisplayedString = function (cache) {\n\t    return this.val;\n\t};\n\t\n\tChar.prototype.getValue = function() {\n\t    return this.val;\n\t};\n\t\n\tChar.prototype.isEqual = function(other, aUnionFind){\n\t    return other instanceof Char && this.val == other.val;\n\t};\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t    \n\t// Symbols\n\t\n\t//////////////////////////////////////////////////////////////////////\n\tvar Symbol = function(val) {\n\t    this.val = val;\n\t};\n\t\n\tvar symbolCache = {};\n\t    \n\t// makeInstance: string -> Symbol.\n\tSymbol.makeInstance = function(val) {\n\t    // To ensure that we can eq? symbols with equal values.\n\t    if (!(hasOwnProperty.call(symbolCache, val))) {\n\t\tsymbolCache[val] = new Symbol(val);\n\t    }\n\t    return symbolCache[val];\n\t};\n\t    \n\tSymbol.prototype.isEqual = function(other, aUnionFind) {\n\t    return other instanceof Symbol &&\n\t    this.val == other.val;\n\t};\n\t    \n\t\n\tSymbol.prototype.toString = function() {\n\t    return this.val;\n\t};\n\t\n\tSymbol.prototype.toWrittenString = function(cache) {\n\t    return this.val;\n\t};\n\t\n\tSymbol.prototype.toDisplayedString = function(cache) {\n\t    return this.val;\n\t};\n\t\n\tSymbol.prototype.toDomNode = function(cache) {\n\t    var wrapper = document.createElement(\"span\");\n\t    wrapper.className = \"wescheme-symbol\";\n\t    wrapper.style.fontFamily = 'monospace';\n\t    wrapper.style.whiteSpace = \"pre\";\n\t    wrapper.appendChild(document.createTextNode(\"'\" + this.val));\n\t    return wrapper;\n\t};\n\t\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t\n\t\n\t\n\t\n\t\n\t// Keywords\n\t\n\tvar Keyword = function(val) {\n\t    this.val = val;\n\t};\n\t\n\tvar keywordCache = {};\n\t    \n\t\n\t// makeInstance: string -> Keyword.\n\tKeyword.makeInstance = function(val) {\n\t    // To ensure that we can eq? symbols with equal values.\n\t    if (!(hasOwnProperty.call(keywordCache, val))) {\n\t\tkeywordCache[val] = new Keyword(val);\n\t    }\n\t    return keywordCache[val];\n\t};\n\t    \n\tKeyword.prototype.isEqual = function(other, aUnionFind) {\n\t    return other instanceof Keyword &&\n\t    this.val == other.val;\n\t};\n\t    \n\t\n\tKeyword.prototype.toString = function() {\n\t    return this.val;\n\t};\n\t\n\tKeyword.prototype.toWrittenString = function(cache) {\n\t    return this.val;\n\t};\n\t\n\tKeyword.prototype.toDisplayedString = function(cache) {\n\t    return this.val;\n\t};\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t\n\t    \n\t    \n\t    \n\tEmpty = function() {\n\t};\n\tEmpty.EMPTY = new Empty();\n\t\n\t\n\tEmpty.prototype.isEqual = function(other, aUnionFind) {\n\t    return other instanceof Empty;\n\t};\n\t\n\tEmpty.prototype.reverse = function() {\n\t    return this;\n\t};\n\t\n\tEmpty.prototype.first = function() {\n\t    throw new Error(\"first can't be applied on empty.\");\n\t};\n\tEmpty.prototype.rest = function() {\n\t    throw new Error(\"rest can't be applied on empty.\");\n\t};\n\tEmpty.prototype.isEmpty = function() {\n\t    return true;\n\t};\n\tEmpty.prototype.toWrittenString = function(cache) { return \"empty\"; };\n\tEmpty.prototype.toDisplayedString = function(cache) { return \"empty\"; };\n\tEmpty.prototype.toString = function(cache) { return \"()\"; };\n\t\n\t\n\t    \n\t// Empty.append: (listof X) -> (listof X)\n\tEmpty.prototype.append = function(b){\n\t    return b;\n\t};\n\t    \n\tCons = function(f, r) {\n\t    this.f = f;\n\t    this.r = r;\n\t};\n\t\n\tCons.prototype.reverse = function() {\n\t    var lst = this;\n\t    var ret = Empty.EMPTY;\n\t    while (!lst.isEmpty()){\n\t\tret = Cons.makeInstance(lst.first(), ret);\n\t\tlst = lst.rest();\n\t    }\n\t    return ret;\n\t};\n\t    \n\tCons.makeInstance = function(f, r) {\n\t    return new Cons(f, r);\n\t};\n\t\n\t\n\t// FIXME: can we reduce the recursion on this?\n\tCons.prototype.isEqual = function(other, aUnionFind) {\n\t    if (! (other instanceof Cons)) {\n\t\treturn Logic.FALSE;\n\t    }\n\t    return (isEqual(this.first(), other.first(), aUnionFind) &&\n\t\t    isEqual(this.rest(), other.rest(), aUnionFind));\n\t};\n\t    \n\tCons.prototype.first = function() {\n\t    return this.f;\n\t};\n\t    \n\tCons.prototype.rest = function() {\n\t    return this.r;\n\t};\n\t    \n\tCons.prototype.isEmpty = function() {\n\t    return false;\n\t};\n\t    \n\t// Cons.append: (listof X) -> (listof X)\n\tCons.prototype.append = function(b){\n\t    if (b === Empty.EMPTY)\n\t\treturn this;\n\t    var ret = b;\n\t    var lst = this.reverse();\n\t    while ( !lst.isEmpty() ) {\n\t\tret = Cons.makeInstance(lst.first(), ret);\n\t\tlst = lst.rest();\n\t    }\n\t\t\n\t    return ret;\n\t};\n\t    \n\t\n\tCons.prototype.toWrittenString = function(cache) {\n\t    //    cache.put(this, true);\n\t    var texts = [\"list\"];\n\t    var p = this;\n\t    while ( p instanceof Cons ) {\n\t\ttexts.push(toWrittenString(p.first(), cache));\n\t\tp = p.rest();\n\t    }\n\t    if ( p !== Empty.EMPTY ) {\n\t\t// If not a list, we've got to switch over to cons pair\n\t\t// representation.\n\t\treturn explicitConsString(this, cache, toWrittenString);\n\t    }\n\t    return \"(\" + texts.join(\" \") + \")\";\n\t};\n\t\n\tvar explicitConsString = function(p, cache, f) {\n\t    var texts = [];\n\t    var tails = []\n\t    while ( p instanceof Cons ) {\n\t\ttexts.push(\"(cons \");\n\t\ttexts.push(f(p.first(), cache));\n\t\ttexts.push(\" \");\n\t\n\t\ttails.push(\")\");\n\t\tp = p.rest();\n\t    }\n\t    texts.push(f(p, cache));\n\t    return (texts.join(\"\") + tails.join(\"\"));\n\t};\n\t\n\t\n\tCons.prototype.toString = Cons.prototype.toWrittenString;\n\t\n\tCons.prototype.toDisplayedString = function(cache) {\n\t    //    cache.put(this, true);\n\t    var texts = [\"list\"];\n\t    var p = this;\n\t    while ( p instanceof Cons ) {\n\t\ttexts.push(toDisplayedString(p.first(), cache));\n\t\tp = p.rest();\n\t    }\n\t    if ( p !== Empty.EMPTY ) {\n\t\treturn explicitConsString(this, cache, toDisplayedString);\n\t    }\n\t//    while (true) {\n\t//\tif ((!(p instanceof Cons)) && (!(p instanceof Empty))) {\n\t//\t    texts.push(\".\");\n\t//\t    texts.push(toDisplayedString(p, cache));\n\t//\t    break;\n\t//\t}\n\t//\tif (p.isEmpty()) \n\t//\t    break;\n\t//\ttexts.push(toDisplayedString(p.first(), cache));\n\t//\tp = p.rest();\n\t//    }\n\t    return \"(\" + texts.join(\" \") + \")\";\n\t};\n\t\n\t\n\t\n\tCons.prototype.toDomNode = function(cache) {\n\t    //    cache.put(this, true);\n\t    var node = document.createElement(\"span\"),\n\t        abbr = document.createElement(\"span\");\n\t    node.className = \"wescheme-cons\";\n\t    abbr.appendChild(document.createTextNode(\"list\"));\n\t \n\t     node.appendChild(makeLParen());\n\t     node.appendChild(abbr);\n\t    var p = this;\n\t    while ( p instanceof Cons ) {\n\t      appendChild(node, toDomNode(p.first(), cache));\n\t      p = p.rest();\n\t    }\n\t    if ( p !== Empty.EMPTY ) {\n\t\treturn explicitConsDomNode(this, cache);\n\t    }\n\t node.appendChild(makeRParen());\n\t    return node;\n\t};\n\t\n\tvar explicitConsDomNode = function(p, cache) {\n\t    var topNode = document.createElement(\"span\");\n\t    var node = topNode, constructor = document.createElement(\"span\");\n\t       constructor.appendChild(document.createTextNode(\"cons\"));\n\t\n\t    node.className = \"wescheme-cons\";\n\t    while ( p instanceof Cons ) {\n\t      node.appendChild(makeLParen());\n\t      node.appendChild(constructor);\n\t      appendChild(node, toDomNode(p.first(), cache));\n\t\n\t      var restSpan = document.createElement(\"span\");\n\t      node.appendChild(restSpan);\n\t      node.appendChild(makeRParen());\n\t      node = restSpan;\n\t      p = p.rest();\n\t    }\n\t    appendChild(node, toDomNode(p, cache));\n\t    return topNode;\n\t};\n\t\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\tVector = function(n, initialElements) {\n\t    this.elts = new Array(n);\n\t    if (initialElements) {\n\t\tfor (var i = 0; i < n; i++) {\n\t\t    this.elts[i] = initialElements[i];\n\t\t}\n\t    } else {\n\t\tfor (var i = 0; i < n; i++) {\n\t\t    this.elts[i] = undefined;\n\t\t}\n\t    }\n\t    this.mutable = true;\n\t};\n\tVector.makeInstance = function(n, elts) {\n\t    return new Vector(n, elts);\n\t}\n\t    Vector.prototype.length = function() {\n\t\treturn this.elts.length;\n\t    };\n\tVector.prototype.ref = function(k) {\n\t    return this.elts[k];\n\t};\n\tVector.prototype.set = function(k, v) {\n\t    this.elts[k] = v;\n\t};\n\t\n\tVector.prototype.isEqual = function(other, aUnionFind) {\n\t    if (other != null && other != undefined && other instanceof Vector) {\n\t\tif (other.length() != this.length()) {\n\t\t    return false\n\t\t}\n\t\tfor (var i = 0; i <  this.length(); i++) {\n\t\t    if (! isEqual(this.elts[i], other.elts[i], aUnionFind)) {\n\t\t\treturn false;\n\t\t    }\n\t\t}\n\t\treturn true;\n\t    } else {\n\t\treturn false;\n\t    }\n\t};\n\t\n\tVector.prototype.toList = function() {\n\t    var ret = Empty.EMPTY;\n\t    for (var i = this.length() - 1; i >= 0; i--) {\n\t\tret = Cons.makeInstance(this.elts[i], ret);\t    \n\t    }\t\n\t    return ret;\n\t};\n\t\n\tVector.prototype.toWrittenString = function(cache) {\n\t    //    cache.put(this, true);\n\t    var texts = [];\n\t    for (var i = 0; i < this.length(); i++) {\n\t\ttexts.push(toWrittenString(this.ref(i), cache));\n\t    }\n\t    return \"#(\" + texts.join(\" \") + \")\";\n\t};\n\t\n\tVector.prototype.toDisplayedString = function(cache) {\n\t    //    cache.put(this, true);\n\t    var texts = [];\n\t    for (var i = 0; i < this.length(); i++) {\n\t\ttexts.push(toDisplayedString(this.ref(i), cache));\n\t    }\n\t    return \"#(\" + texts.join(\" \") + \")\";\n\t};\n\t\n\tVector.prototype.toDomNode = function(cache) {\n\t    //    cache.put(this, true);\n\t    var node = document.createElement(\"span\"),\n\t        lVect = document.createElement(\"span\"),\n\t        rVect = document.createElement(\"span\");\n\t    lVect.appendChild(document.createTextNode(\"#(\"));\n\t    lVect.className = \"lParen\";\n\t    rVect.appendChild(document.createTextNode(\")\"));\n\t    rVect.className = \"rParen\";\n\t    node.className = \"wescheme-vector\";\n\t    node.appendChild(lVect);\n\t    for (var i = 0; i < this.length(); i++) {\n\t      appendChild(node, toDomNode(this.ref(i), cache));\n\t    }\n\t    node.appendChild(rVect);\n\t    return node;\n\t};\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t\n\t\n\t\n\t\n\t\n\t// Now using mutable strings\n\tvar Str = function(chars) {\n\t\tthis.chars = chars;\n\t\tthis.length = chars.length;\n\t\tthis.mutable = true;\n\t}\n\t\n\tStr.makeInstance = function(chars) {\n\t\treturn new Str(chars);\n\t}\n\t\n\tStr.fromString = function(s) {\n\t\treturn Str.makeInstance(s.split(\"\"));\n\t}\n\t\n\tStr.prototype.toString = function() {\n\t\treturn this.chars.join(\"\");\n\t}\n\t\n\tStr.prototype.toWrittenString = function(cache) {\n\t    return escapeString(this.toString());\n\t}\n\t\n\tStr.prototype.toDisplayedString = Str.prototype.toString;\n\t\n\tStr.prototype.copy = function() {\n\t\treturn Str.makeInstance(this.chars.slice(0));\n\t}\n\t\n\tStr.prototype.substring = function(start, end) {\n\t\tif (end == null || end == undefined) {\n\t\t\tend = this.length;\n\t\t}\n\t\t\n\t\treturn Str.makeInstance( this.chars.slice(start, end) );\n\t}\n\t\n\tStr.prototype.charAt = function(index) {\n\t\treturn this.chars[index];\n\t}\n\t\n\tStr.prototype.charCodeAt = function(index) {\n\t\treturn this.chars[index].charCodeAt(0);\n\t}\n\t\n\tStr.prototype.replace = function(expr, newStr) {\n\t\treturn Str.fromString( this.toString().replace(expr, newStr) );\n\t}\n\t\n\t\n\tStr.prototype.isEqual = function(other, aUnionFind) {\n\t\tif ( !(other instanceof Str || typeof(other) == 'string') ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.toString() === other.toString();\n\t}\n\t\n\t\n\tStr.prototype.set = function(i, c) {\n\t\tthis.chars[i] = c;\n\t}\n\t\n\tStr.prototype.toUpperCase = function() {\n\t\treturn Str.fromString( this.chars.join(\"\").toUpperCase() );\n\t}\n\t\n\tStr.prototype.toLowerCase = function() {\n\t\treturn Str.fromString( this.chars.join(\"\").toLowerCase() );\n\t}\n\t\n\tStr.prototype.match = function(regexpr) {\n\t\treturn this.toString().match(regexpr);\n\t}\n\t\n\t\n\t//var _quoteReplacingRegexp = new RegExp(\"[\\\"\\\\\\\\]\", \"g\");\n\tvar escapeString = function(s) {\n\t    return '\"' + replaceUnprintableStringChars(s) + '\"';\n\t//    return '\"' + s.replace(_quoteReplacingRegexp,\n\t//\t\t\t      function(match, submatch, index) {\n\t//\t\t\t\t  return \"\\\\\" + match;\n\t//\t\t\t      }) + '\"';\n\t};\n\t\n\tvar replaceUnprintableStringChars = function(s) {\n\t\tvar ret = [];\n\t\tfor (var i = 0; i < s.length; i++) {\n\t\t\tvar val = s.charCodeAt(i);\n\t\t\tswitch(val) {\n\t\t\t\tcase 7: ret.push('\\\\a'); break;\n\t\t\t\tcase 8: ret.push('\\\\b'); break;\n\t\t\t\tcase 9: ret.push('\\\\t'); break;\n\t\t\t\tcase 10: ret.push('\\\\n'); break;\n\t\t\t\tcase 11: ret.push('\\\\v'); break;\n\t\t\t\tcase 12: ret.push('\\\\f'); break;\n\t\t\t\tcase 13: ret.push('\\\\r'); break;\n\t\t\t\tcase 34: ret.push('\\\\\"'); break;\n\t\t\t\tcase 92: ret.push('\\\\\\\\'); break;\n\t\t\t\tdefault: if (val >= 32 && val <= 126) {\n\t\t\t\t\t\t ret.push( s.charAt(i) );\n\t\t\t\t\t }\n\t\t\t\t\t else {\n\t\t\t\t\t\t var numStr = val.toString(16).toUpperCase();\n\t\t\t\t\t\t while (numStr.length < 4) {\n\t\t\t\t\t\t\t numStr = '0' + numStr;\n\t\t\t\t\t\t }\n\t\t\t\t\t\t ret.push('\\\\u' + numStr);\n\t\t\t\t\t }\n\t\t\t\t\t break;\n\t\t\t}\n\t\t}\n\t\treturn ret.join('');\n\t};\n\t\n\t\n\t/*\n\t// Strings\n\t// For the moment, we just reuse Javascript strings.\n\tString = String;\n\tString.makeInstance = function(s) {\n\t    return s.valueOf();\n\t};\n\t    \n\t    \n\t// WARNING\n\t// WARNING: we are extending the built-in Javascript string class here!\n\t// WARNING\n\tString.prototype.isEqual = function(other, aUnionFind){\n\t    return this == other;\n\t};\n\t    \n\tvar _quoteReplacingRegexp = new RegExp(\"[\\\"\\\\\\\\]\", \"g\");\n\tString.prototype.toWrittenString = function(cache) {\n\t    return '\"' + this.replace(_quoteReplacingRegexp,\n\t\t\t\t      function(match, submatch, index) {\n\t\t\t\t\t  return \"\\\\\" + match;\n\t\t\t\t      }) + '\"';\n\t};\n\t\n\tString.prototype.toDisplayedString = function(cache) {\n\t    return this;\n\t};\n\t*/\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t// makeLowLevelEqHash: -> hashtable\n\t// Constructs an eq hashtable that uses Moby's getEqHashCode function.\n\tvar makeLowLevelEqHash = function() {\n\t    return new _Hashtable(function(x) { return getEqHashCode(x); },\n\t\t\t\t  function(x, y) { return x === y; });\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t// Hashtables\n\tvar EqHashTable = function(inputHash) {\n\t    this.hash = makeLowLevelEqHash();\n\t    this.mutable = true;\n\t\n\t};\n\tEqHashTable = EqHashTable;\n\t\n\tEqHashTable.prototype.toWrittenString = function(cache) {\n\t    var keys = this.hash.keys();\n\t    var ret = [];\n\t    for (var i = 0; i < keys.length; i++) {\n\t\t    var keyStr = types.toWrittenString(keys[i], cache);\n\t\t    var valStr = types.toWrittenString(this.hash.get(keys[i]), cache);\n\t\t    ret.push('(' + keyStr + ' . ' + valStr + ')');\n\t    }\n\t    return ('#hasheq(' + ret.join(' ') + ')');\n\t};\n\t\n\tEqHashTable.prototype.toDisplayedString = function(cache) {\n\t    var keys = this.hash.keys();\n\t    var ret = [];\n\t    for (var i = 0; i < keys.length; i++) {\n\t\t    var keyStr = types.toDisplayedString(keys[i], cache);\n\t\t    var valStr = types.toDisplayedString(this.hash.get(keys[i]), cache);\n\t\t    ret.push('(' + keyStr + ' . ' + valStr + ')');\n\t    }\n\t    return ('#hasheq(' + ret.join(' ') + ')');\n\t};\n\t\n\tEqHashTable.prototype.isEqual = function(other, aUnionFind) {\n\t    if ( !(other instanceof EqHashTable) ) {\n\t\treturn false; \n\t    }\n\t\n\t    if (this.hash.keys().length != other.hash.keys().length) { \n\t\treturn false;\n\t    }\n\t\n\t    var keys = this.hash.keys();\n\t    for (var i = 0; i < keys.length; i++){\n\t\tif ( !(other.hash.containsKey(keys[i]) &&\n\t\t       isEqual(this.hash.get(keys[i]),\n\t\t\t       other.hash.get(keys[i]),\n\t\t\t       aUnionFind)) ) {\n\t\t\treturn false;\n\t\t}\n\t    }\n\t    return true;\n\t};\n\t\n\t\n\t\n\tvar EqualHashTable = function(inputHash) {\n\t\tthis.hash = new _Hashtable(function(x) {\n\t\t\t\treturn toWrittenString(x); \n\t\t\t},\n\t\t\tfunction(x, y) {\n\t\t\t\treturn isEqual(x, y, new UnionFind()); \n\t\t\t});\n\t\tthis.mutable = true;\n\t};\n\t\n\tEqualHashTable = EqualHashTable;\n\t\n\tEqualHashTable.prototype.toWrittenString = function(cache) {\n\t    var keys = this.hash.keys();\n\t    var ret = [];\n\t    for (var i = 0; i < keys.length; i++) {\n\t\t    var keyStr = types.toWrittenString(keys[i], cache);\n\t\t    var valStr = types.toWrittenString(this.hash.get(keys[i]), cache);\n\t\t    ret.push('(' + keyStr + ' . ' + valStr + ')');\n\t    }\n\t    return ('#hash(' + ret.join(' ') + ')');\n\t};\n\tEqualHashTable.prototype.toDisplayedString = function(cache) {\n\t    var keys = this.hash.keys();\n\t    var ret = [];\n\t    for (var i = 0; i < keys.length; i++) {\n\t\t    var keyStr = types.toDisplayedString(keys[i], cache);\n\t\t    var valStr = types.toDisplayedString(this.hash.get(keys[i]), cache);\n\t\t    ret.push('(' + keyStr + ' . ' + valStr + ')');\n\t    }\n\t    return ('#hash(' + ret.join(' ') + ')');\n\t};\n\t\n\tEqualHashTable.prototype.isEqual = function(other, aUnionFind) {\n\t    if ( !(other instanceof EqualHashTable) ) {\n\t\treturn false; \n\t    }\n\t\n\t    if (this.hash.keys().length != other.hash.keys().length) { \n\t\treturn false;\n\t    }\n\t\n\t    var keys = this.hash.keys();\n\t    for (var i = 0; i < keys.length; i++){\n\t\tif (! (other.hash.containsKey(keys[i]) &&\n\t\t       isEqual(this.hash.get(keys[i]),\n\t\t\t       other.hash.get(keys[i]),\n\t\t\t       aUnionFind))) {\n\t\t    return false;\n\t\t}\n\t    }\n\t    return true;\n\t};\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\tvar JsObject = function(name, obj) {\n\t\tthis.name = name;\n\t\tthis.obj = obj;\n\t};\n\t\n\tJsObject.prototype.toString = function() {\n\t\treturn '#<js-object:' + typeof(this.obj) + ':' + this.name + '>';\n\t};\n\t\n\tJsObject.prototype.isEqual = function(other, aUnionFind) {\n\t\treturn (this.obj === other.obj);\n\t};\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\tvar WorldConfig = function(startup, shutdown, args) {\n\t\tthis.startup = startup;\n\t\tthis.shutdown = shutdown;\n\t\tthis.startupArgs = args;\n\t\tthis.shutdownArg = undefined;\n\t};\n\t\n\tWorldConfig.prototype.toString = function() {\n\t\treturn '#<world-config>';\n\t};\n\t\n\tWorldConfig.prototype.isEqual = function(other, aUnionFind) {\n\t\tif ( ! isEqual(this.startup, other.startup, aUnionFind) ||\n\t\t     ! isEqual(this.shutdown, other.shutdown, aUnionFind) ||\n\t\t     this.startupArgs.length != other.startupArgs.length || \n\t\t     ! isEqual(this.shutdownArg, other.shutdownArg, aUnionFind) ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\tif ( !isEqual(this.startupArgs[i], other.startupArgs[i], aUnionFind) )\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\t\n\t\n\tvar Effect = makeStructureType('effect', false, 0, 0, false, false);\n\tEffect.type.prototype.invokeEffect = function(k) {\n\t\thelpers.raise(types.incompleteExn(\n\t\t\t\ttypes.exnFail,\n\t\t\t\t'effect type created without using make-effect-type',\n\t\t\t\t[]));\n\t};\n\t//Effect.handlerIndices = [];\n\t\n\t\n\t//var wrapHandler = function(handler, caller, changeWorld) {\n\t//\treturn types.jsObject('function', function() {\n\t//\t\tvar externalArgs = arguments;\n\t//\t\tchangeWorld(function(w, k) {\n\t//\t\t\tvar args = helpers.map(helpers.wrapJsObject, externalArgs);\n\t//\t\t\targs.unshift(w);\n\t//\t\t\tcaller(handler, args, k);\n\t//\t\t});\n\t//\t});\n\t//};\n\t\n\t\n\tvar makeEffectType = function(name, superType, initFieldCnt, impl, guard, caller) {\n\t\tif ( !superType ) {\n\t\t\tsuperType = Effect;\n\t\t}\n\t\t\n\t\tvar newType = makeStructureType(name, superType, initFieldCnt, 0, false, guard);\n\t\tvar lastFieldIndex = newType.firstField + newType.numberOfFields;\n\t\n\t\tnewType.type.prototype.invokeEffect = function(changeWorld, k) {\n\t\t\tvar schemeChangeWorld = new PrimProc('update-world', 1, false, true,\n\t\t\t\tfunction(aState, worldUpdater) {\n\t\t\t\t\thelpers.check(aState, worldUpdater, helpers.procArityContains(1),\n\t\t\t\t\t\t      'update-world', 'procedure (arity 1)', 1);\n\t\t\t\t\t\n\t\t\t\t\tchangeWorld(function(w, k2) { interpret.call(aState,\n\t\t\t\t\t\t\t\t\t\t     worldUpdater, [w],\n\t\t\t\t\t\t\t\t\t\t     k2,\n\t\t\t\t\t\t\t\t\t\t     function(e) { throw e; }); },\n\t\t\t\t\t\t    function() { aState.v = VOID_VALUE; });\n\t\t\t\t});\n\t\n\t\t\tvar args = this._fields.slice(0, lastFieldIndex);\n\t\t\targs.unshift(schemeChangeWorld);\n\t\t\tcaller(impl, args, k);\n\t\t}\n\t\n\t\treturn newType;\n\t};\n\t\n\t\n\tvar RenderEffect = makeStructureType('render-effect', false, 0, 0, false, false);\n\tRenderEffect.type.prototype.callImplementation = function(caller, k) {\n\t\thelpers.raise(types.incompleteExn(\n\t\t\t\ttypes.exnFail,\n\t\t\t\t'render effect created without using make-render-effect-type',\n\t\t\t\t[]));\n\t};\n\t\n\tvar makeRenderEffectType = function(name, superType, initFieldCnt, impl, guard) {\n\t\tif ( !superType ) {\n\t\t\tsuperType = RenderEffect;\n\t\t}\n\t\t\n\t\tvar newType = makeStructureType(name, superType, initFieldCnt, 0, false, guard);\n\t\tvar lastFieldIndex = newType.firstField + newType.numberOfFields;\n\t\n\t\tnewType.type.prototype.callImplementation = function(caller, k) {\n\t\t\tvar args = this._fields.slice(0, lastFieldIndex);\n\t\t\tcaller(impl, args, k);\n\t\t}\n\t\n\t\treturn newType;\n\t};\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar toWrittenString = function(x, cache) {\n\t    if (! cache) { \n\t     \tcache = makeLowLevelEqHash();\n\t    }\n\t\n\t    if (typeof(x) == 'object') {\n\t\t    if (cache.containsKey(x)) {\n\t\t\t    return \"...\";\n\t\t    } else {\n\t\t        cache.put(x, true);\n\t            }\n\t    }\n\t\n\t    if (x == undefined || x == null) {\n\t\treturn \"#<undefined>\";\n\t    }\n\t    if (typeof(x) == 'string') {\n\t\treturn escapeString(x.toString());\n\t    }\n\t    if (typeof(x) != 'object' && typeof(x) != 'function') {\n\t\treturn x.toString();\n\t    }\n\t\n\t    var returnVal;\n\t    if (typeof(x.toWrittenString) !== 'undefined') {\n\t\treturnVal = x.toWrittenString(cache);\n\t    } else if (typeof(x.toDisplayedString) !== 'undefined') {\n\t\treturnVal = x.toDisplayedString(cache);\n\t    } else {\n\t\treturnVal = x.toString();\n\t    }\n\t    cache.remove(x);\n\t    return returnVal;\n\t};\n\t\n\t\n\t\n\tvar toDisplayedString = function(x, cache) {\n\t    if (! cache) {\n\t    \tcache = makeLowLevelEqHash();\n\t    }\n\t    if (typeof(x) == 'object') {\n\t\t    if (cache.containsKey(x)) {\n\t\t\t    return \"...\";\n\t\t    }\n\t\t    cache.put(x, true);\n\t    }\n\t\n\t    if (x == undefined || x == null) {\n\t\treturn \"#<undefined>\";\n\t    }\n\t    if (typeof(x) == 'string') {\n\t\treturn x;\n\t    }\n\t    if (typeof(x) != 'object' && typeof(x) != 'function') {\n\t\treturn x.toString();\n\t    }\n\t\n\t    var returnVal;\n\t    if (typeof(x.toDisplayedString) !== 'undefined') {\n\t\treturnVal = x.toDisplayedString(cache);\n\t    } else if (typeof(x.toWrittenString) !== 'undefined') {\n\t\treturnVal = x.toWrittenString(cache);\n\t    } else {\n\t\treturnVal = x.toString();\n\t    }\n\t    cache.remove(x);\n\t    return returnVal;\n\t};\n\t\n\t\n\t\n\t// toDomNode: scheme-value -> dom-node\n\tvar toDomNode = function(x, cache) {\n\t    if (! cache) {\n\t    \tcache = makeLowLevelEqHash();\n\t    }\n\t    \n\t    if (isNumber(x)) {\n\t\treturn numberToDomNode(x);\n\t    }\n\t\n\t    if (typeof(x) == 'object') {\n\t\t    if (cache.containsKey(x)) {\n\t        var node = document.createElement(\"span\");\n\t        node.style['font-family'] = 'monospace';\n\t        node.appendChild(document.createTextNode(\"...\"));\n\t        return node;\n\t\t    }\n\t\t    cache.put(x, true);\n\t    }\n\t\n\t    if (x == undefined || x == null) {\n\t      var node = document.createElement(\"span\");\n\t      node.style['font-family'] = 'monospace';\n\t      node.appendChild(document.createTextNode(\"#<undefined>\"));\n\t      return node;\n\t    }\n\t    if (typeof(x) == 'string') {\n\t        return textToDomNode(toWrittenString(x));\n\t    }\n\t    if (typeof(x) != 'object' && typeof(x) != 'function') {\n\t        return textToDomNode(x.toString());\n\t    }\n\t\n\t    var returnVal;\n\t    if (x.nodeType) {\n\t\treturnVal =  x;\n\t    } else if (typeof(x.toDomNode) !== 'undefined') {\n\t\treturnVal =  x.toDomNode(cache);\n\t    } else if (typeof(x.toWrittenString) !== 'undefined') {\t\n\t        returnVal = textToDomNode(x.toWrittenString(cache))\n\t    } else if (typeof(x.toDisplayedString) !== 'undefined') {\n\t        returnVal = textToDomNode(x.toDisplayedString(cache));\n\t    } else {\n\t        returnVal = textToDomNode(x.toString());\n\t    }\n\t    cache.remove(x);\n\t    return returnVal;\n\t};\n\t\n\t\n\tvar textToDomNode = function(text) {\n\t    var chunks = text.split(\"\\n\");\n\t    var i;\n\t    var wrapper = document.createElement(\"span\");\n\t    var newlineDiv;\n\t    wrapper.className = (text===\"true\" || text===\"false\")? \"wescheme-boolean\" : \"wescheme-string\";\n\t    wrapper.style.fontFamily = 'monospace';\n\t    wrapper.style.whiteSpace = \"pre\";\n\t    if (chunks.length > 0) {\n\t        wrapper.appendChild(document.createTextNode(chunks[0]));\n\t    }\n\t    for (i = 1; i < chunks.length; i++) {\n\t        newlineDiv = document.createElement(\"br\");\n\t        newlineDiv.style.clear = 'left';\n\t        wrapper.appendChild(newlineDiv);\n\t        wrapper.appendChild(document.createTextNode(chunks[i]));\n\t    }\n\t    return wrapper;\n\t};\n\t\n\t\n\t\n\t// numberToDomNode: jsnum -> dom\n\t// Given a jsnum, produces a dom-node representation.\n\tvar numberToDomNode = function(n) {\n\t    var node;\n\t    if (jsnums.isExact(n)) {\n\t      if (jsnums.isInteger(n)) {\n\t          node = document.createElement(\"span\");\n\t          node.className = \"wescheme-number Integer\";\n\t          node.appendChild(document.createTextNode(n.toString()));\n\t          return node;\n\t      } else if (jsnums.isRational(n)) {\n\t          return rationalToDomNode(n);\n\t      } else if (isComplex(n)) {\n\t          node = document.createElement(\"span\");\n\t          node.className = \"wescheme-number Complex\";\n\t          node.appendChild(document.createTextNode(n.toString()));\n\t          return node;\n\t      } else {\n\t          node = document.createElement(\"span\");\n\t          node.className = \"wescheme-number\";\n\t          node.appendChild(document.createTextNode(n.toString()));\n\t          return node;\n\t      }\n\t    } else {\n\t      node = document.createElement(\"span\");\n\t      node.className = \"wescheme-number\";\n\t      node.appendChild(document.createTextNode(n.toString()));\n\t      return node;\n\t    }\n\t};\n\t\n\t// rationalToDomNode: rational -> dom-node\n\tvar rationalToDomNode = function(n) {\n\t    var repeatingDecimalNode = document.createElement(\"span\");\n\t    var chunks = jsnums.toRepeatingDecimal(jsnums.numerator(n),\n\t\t\t\t\t\t   jsnums.denominator(n),\n\t\t\t\t\t\t   {limit: 25});\n\t    var firstPart = document.createElement(\"span\");\n\t    firstPart.appendChild(document.createTextNode(chunks[0] + '.' + chunks[1]));\n\t    repeatingDecimalNode.appendChild(firstPart);\n\t    if (chunks[2] === '...') {\n\t      firstPart.appendChild(document.createTextNode(chunks[2]));\n\t    } else if (chunks[2] !== '0') {\n\t      var overlineSpan = document.createElement(\"span\");\n\t      overlineSpan.style.textDecoration = 'overline';\n\t      overlineSpan.appendChild(document.createTextNode(chunks[2]));\n\t      repeatingDecimalNode.appendChild(overlineSpan);\n\t    }\n\t\n\t\n\t    var fractionalNode = document.createElement(\"span\");\n\t    var numeratorNode = document.createElement(\"sup\");\n\t    numeratorNode.appendChild(document.createTextNode(String(jsnums.numerator(n))));\n\t    var denominatorNode = document.createElement(\"sub\");\n\t    denominatorNode.appendChild(document.createTextNode(String(jsnums.denominator(n))));\n\t    var barNode = document.createElement(\"span\");\n\t    barNode.appendChild(document.createTextNode(\"/\"));\n\t\n\t    fractionalNode.appendChild(numeratorNode);\n\t    fractionalNode.appendChild(barNode);\n\t    fractionalNode.appendChild(denominatorNode);\n\t\n\t    \n\t    var numberNode = document.createElement(\"span\");\n\t    numberNode.appendChild(repeatingDecimalNode);\n\t    numberNode.appendChild(fractionalNode);\n\t    fractionalNode.style['display'] = 'none';\n\t\n\t    var showingRepeating = true;\n\t\n\t    numberNode.onclick = function(e) {\n\t\tshowingRepeating = !showingRepeating;\n\t\trepeatingDecimalNode.style['display'] = \n\t\t    (showingRepeating ? 'inline' : 'none')\n\t\tfractionalNode.style['display'] = \n\t\t    (!showingRepeating ? 'inline' : 'none')\n\t    };\n\t    numberNode.style['cursor'] = 'pointer';\n\t    numberNode.className = \"wescheme-number Rational\";\n\t    return numberNode;\n\t\n\t};\n\t\n\t    // Alternative: use <sup> and <sub> tags\n\t\n\t\n\t\n\t\n\t\n\tvar isNumber = jsnums.isSchemeNumber;\n\tvar isComplex = isNumber;\n\tvar isString = function(s) {\n\t\treturn (typeof s === 'string' || s instanceof Str);\n\t}\n\t\n\t\n\t// isEqual: X Y -> boolean\n\t// Returns true if the objects are equivalent; otherwise, returns false.\n\tvar isEqual = function(x, y, aUnionFind) {\n\t    if (x === y) { return true; }\n\t\n\t    if (isNumber(x) && isNumber(y)) {\n\t\treturn jsnums.equals(x, y);\n\t    }\n\t\n\t    if (isString(x) && isString(y)) {\n\t\treturn x.toString() === y.toString();\n\t    }\n\t\n\t    if (x == undefined || x == null) {\n\t\treturn (y == undefined || y == null);\n\t    }\n\t\n\t    if ( typeof(x) == 'object' &&\n\t\t typeof(y) == 'object' &&\n\t\t x.isEqual &&\n\t\t y.isEqual) {\n\t\tif (aUnionFind.find(x) === aUnionFind.find(y)) {\n\t\t    return true;\n\t\t}\n\t\telse {\n\t\t    aUnionFind.merge(x, y); \n\t\t    return x.isEqual(y, aUnionFind);\n\t\t}\n\t    }\n\t    return false;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t// liftToplevelToFunctionValue: primitive-function string fixnum scheme-value -> scheme-value\n\t// Lifts a primitive toplevel or module-bound value to a scheme value.\n\tvar liftToplevelToFunctionValue = function(primitiveF,\n\t\t\t\t\t       name,\n\t\t\t\t\t       minArity, \n\t\t\t\t\t       procedureArityDescription) {\n\t    if (! primitiveF._mobyLiftedFunction) {\n\t\tvar lifted = function(args) {\n\t\t    return primitiveF.apply(null, args.slice(0, minArity).concat([args.slice(minArity)]));\n\t\t};\n\t\tlifted.isEqual = function(other, cache) { \n\t\t    return this === other; \n\t\t}\n\t\tlifted.toWrittenString = function(cache) { \n\t\t    return \"#<function:\" + name + \">\";\n\t\t};\n\t\tlifted.toDisplayedString = lifted.toWrittenString;\n\t\tlifted.procedureArity = procedureArityDescription;\n\t\tprimitiveF._mobyLiftedFunction = lifted;\n\t\t    \n\t    } \n\t    return primitiveF._mobyLiftedFunction;\n\t};\n\t\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\tvar ThreadCell = function(v, isPreserved) {\n\t    this.v = v;\n\t    this.isPreserved = isPreserved || false;\n\t};\n\t\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t\n\t// Wrapper around functions that return multiple values.\n\tvar ValuesWrapper = function(elts) {\n\t    this.elts = elts;\n\t};\n\t\n\tValuesWrapper.prototype.toDomNode = function(cache) {\n\t    var parent = document.createElement(\"span\");\n\t    parent.style.whiteSpace = \"pre\";\n\t    if ( this.elts.length > 0 ) {\n\t\t    parent.appendChild( toDomNode(this.elts[0], cache) );\n\t\t    for (var i = 1; i < this.elts.length; i++) {\n\t\t\t    parent.appendChild( document.createTextNode('\\n') );\n\t\t\t    parent.appendChild( toDomNode(this.elts[i], cache) );\n\t\t    }\n\t    }\n\t    return parent;\n\t};\n\t\n\t\n\tvar UndefinedValue = function() {\n\t};\n\tUndefinedValue.prototype.toString = function() {\n\t    return \"#<undefined>\";\n\t};\n\tvar UNDEFINED_VALUE = new UndefinedValue();\n\t\n\tvar VoidValue = function() {};\n\tVoidValue.prototype.toString = function() {\n\t\treturn \"#<void>\";\n\t};\n\t\n\tvar VOID_VALUE = new VoidValue();\n\t\n\t\n\tvar EofValue = function() {};\n\tEofValue.prototype.toString = function() {\n\t\treturn \"#<eof>\";\n\t}\n\t\n\tvar EOF_VALUE = new EofValue();\n\t\n\t\n\tvar ClosureValue = function(name, locs, numParams, paramTypes, isRest, closureVals, body) {\n\t    this.name = name;\n\t    this.locs = locs;\n\t    this.numParams = numParams;\n\t    this.paramTypes = paramTypes;\n\t    this.isRest = isRest;\n\t    this.closureVals = closureVals;\n\t    this.body = body;\n\t};\n\t\n\t\n\t\n\t\n\tClosureValue.prototype.toString = function() {\n\t    if (this.name !== Empty.EMPTY) {\n\t\treturn helpers.format(\"#<function:~a>\", [this.name]);\n\t    } else {\n\t\treturn \"#<function>\";\n\t    }\n\t};\n\t\n\t\n\tvar CaseLambdaValue = function(name, closures) {\n\t    this.name = name;\n\t    this.closures = closures;\n\t};\n\t\n\tCaseLambdaValue.prototype.toString = function() {\n\t    if (this.name !== Empty.EMPTY) {\n\t\treturn helpers.format(\"#<case-lambda-procedure:~a>\", [this.name]);\n\t    } else {\n\t\treturn \"#<case-lambda-procedure>\";\n\t    }\n\t};\n\t\n\t\n\t\n\tvar ContinuationClosureValue = function(vstack, cstack) {\n\t    this.name = false;\n\t    this.vstack = vstack.slice(0);\n\t    this.cstack = cstack.slice(0);\n\t};\n\t\n\tContinuationClosureValue.prototype.toString = function() {\n\t    if (this.name !== Empty.EMPTY) {\n\t\treturn helpers.format(\"#<function:~a>\", [this.name]);\n\t    } else {\n\t\treturn \"#<function>\";\n\t    }\n\t};\n\t\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t\n\t\n\tvar PrefixValue = function() {\n\t    this.slots = [];\n\t    this.definedMask = [];\n\t};\n\t\n\tPrefixValue.prototype.addSlot = function(v) {\n\t    if (v === undefined) { \n\t\tthis.slots.push(types.UNDEFINED);\n\t\tthis.definedMask.push(false);\n\t    } else {\n\t        this.slots.push(v);\n\t\tif (v instanceof GlobalBucket) {\n\t\t    if (v.value === types.UNDEFINED) {\n\t\t\tthis.definedMask.push(false);\n\t\t    } else {\n\t\t\tthis.definedMask.push(true);\n\t\t    }\n\t\t} else {\n\t\t    this.definedMask.push(true);\n\t\t}\n\t    }\n\t};\n\t\n\tPrefixValue.prototype.ref = function(n, srcloc) {\n\t    if (this.slots[n] instanceof GlobalBucket) {\n\t    \tif (this.definedMask[n]) {\n\t    \t    return this.slots[n].value;\n\t    \t} else {\n\t    \t    helpers.raise(types.incompleteExn(\n\t    \t\t\ttypes.exnFailContractVariable,\n\t    \t\t\tnew Message([new ColoredPart(this.slots[n].name, srcloc),\n\t                            \": this variable is not defined\"]),\n\t    \t\t\t[this.slots[n].name]));\n\t    \t}\n\t        } else {\n\t    \tif (this.definedMask[n]) {\n\t    \t    return this.slots[n];\n\t    \t} else {\n\t    \t    helpers.raise(types.incompleteExn(\n\t    \t\t\ttypes.exnFailContractVariable,\n\t    \t\t\t\"variable has not been defined\",\n\t    \t\t\t[false]));\n\t    \t}\n\t    }\n\t};\n\t\n\tPrefixValue.prototype.set = function(n, v) {\n\t    if (this.slots[n] instanceof GlobalBucket) {\n\t\tthis.slots[n].value = v;\n\t\tthis.definedMask[n] = true;\n\t    } else {\n\t\tthis.slots[n] = v;\n\t\tthis.definedMask[n] = true;\n\t    }\n\t};\n\t\n\t\n\tPrefixValue.prototype.length = function() { \n\t    return this.slots.length;\n\t};\n\t\n\t\n\tvar GlobalBucket = function(name, value) {\n\t    this.name = name;\n\t    this.value = value;\n\t};\n\t\n\t\n\t\n\tvar ModuleVariableRecord = function(resolvedModuleName,\n\t\t\t\t\t    variableName) {\n\t    this.resolvedModuleName = resolvedModuleName;\n\t    this.variableName = variableName;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t\n\tvar VariableReference = function(prefix, pos) {\n\t    this.prefix = prefix;\n\t    this.pos = pos;\n\t};\n\t\n\tVariableReference.prototype.ref = function() {\n\t    return this.prefix.ref(this.pos);\n\t};\n\t\n\tVariableReference.prototype.set = function(v) {\n\t    this.prefix.set(this.pos, v);\n\t}\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t// Continuation Marks\n\t\n\tvar ContMarkRecordControl = function(dict) {\n\t    this.dict = dict || {};\n\t};\n\t\n\tContMarkRecordControl.prototype.invoke = function(state) {\n\t    // No-op: the record will simply pop off the control stack.\n\t};\n\t\n\tContMarkRecordControl.prototype.update = function(key, val) {\n\t /*\n\t    var newDict = makeLowLevelEqHash();\n\t    // FIXME: what's the javascript idiom for hash key copy?\n\t    // Maybe we should use a rbtree instead?\n\t    var oldKeys = this.dict.keys();\n\t    for (var i = 0; i < oldKeys.length; i++) {\n\t\t    newDict.put( oldKeys[i], this.dict.get(oldKeys[i]) );\n\t    }\n\t    newDict.put(key, val);\n\t    return new ContMarkRecordControl(newDict);\n\t  */\n\t  this.dict[key.val] = val;\n\t  return this;\n\t};\n\t\n\t\n\t\n\tvar ContinuationMarkSet = function(dict) {\n\t    this.dict = dict;\n\t}\n\t\n\tContinuationMarkSet.prototype.toDomNode = function(cache) {\n\t    var dom = document.createElement(\"span\");\n\t    dom.appendChild(document.createTextNode('#<continuation-mark-set>'));\n\t    return dom;\n\t};\n\t\n\tContinuationMarkSet.prototype.toWrittenString = function(cache) {\n\t    return '#<continuation-mark-set>';\n\t};\n\t\n\tContinuationMarkSet.prototype.toDisplayedString = function(cache) {\n\t    return '#<continuation-mark-set>';\n\t};\n\t\n\tContinuationMarkSet.prototype.ref = function(key) {\n\t    if ( this.dict.containsKey(key) ) {\n\t\t    return this.dict.get(key);\n\t    }\n\t    return [];\n\t};\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\tvar ContinuationPrompt = function() {\n\t};\n\t\n\tvar defaultContinuationPrompt = new ContinuationPrompt();\n\t\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\tvar PrimProc = function(name, numParams, isRest, assignsToValueRegister, impl) {\n\t    this.name = name;\n\t    this.numParams = numParams;\n\t    this.isRest = isRest;\n\t    this.assignsToValueRegister = assignsToValueRegister;\n\t    this.impl = impl;\n\t};\n\t\n\tPrimProc.prototype.toString = function() {\n\t    return (\"#<function:\" + this.name + \">\");\n\t};\n\t\n\tPrimProc.prototype.toWrittenString = function(cache) {\n\t    return (\"#<function:\" + this.name + \">\");\n\t};\n\t\n\tPrimProc.prototype.toDisplayedString = function(cache) {\n\t    return (\"#<function:\" + this.name + \">\");\n\t};\n\t\n\t\n\tPrimProc.prototype.toDomNode = function(cache) {\n\t    var node = document.createElement(\"span\");\n\t    node.className = \"wescheme-primproc\";\n\t    node.appendChild(document.createTextNode(\"#<function:\"+ this.name +\">\"));\n\t    return node;\n\t};\n\t\n\t\n\tvar CasePrimitive = function(name, cases) {\n\t    this.name = name;\n\t    this.cases = cases;\n\t};\n\t\n\t\n\tCasePrimitive.prototype.toDomNode = function(cache) {\n\t    var node = document.createElement(\"span\");\n\t    node.className = \"wescheme-caseprimitive\";\n\t    node.appendChild(document.createTextNode(\"#<function:\"+ this.name +\">\"));\n\t    return node;\n\t};\n\t\n\tCasePrimitive.prototype.toWrittenString = function(cache) {\n\t    return (\"#<function:\" + this.name + \">\");\n\t};\n\t\n\tCasePrimitive.prototype.toDisplayedString = function(cache) {\n\t    return (\"#<function:\" + this.name + \">\");\n\t};\n\t\n\t\n\t\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t// Colored Error Message Support\n\t\n\tvar Message = function(args) {\n\t  this.args = args;\n\t};\n\t\n\tMessage.prototype.toString = function() {\n\t  var toReturn = [];\n\t  var i;\n\t  for(i = 0; i < this.args.length; i++) {\n\t      toReturn.push(''+this.args[i]);\n\t  }\n\t  \n\t  return toReturn.join(\"\");\n\t};\n\t\n\tvar isMessage = function(o) {\n\t  return o instanceof Message;\n\t};\n\t\n\tvar ColoredPart = function(text, location) {\n\t  this.text = text;\n\t  this.location = location;\n\t};\n\t\n\tvar isColoredPart = function(o) {\n\t  return o instanceof ColoredPart;\n\t};\n\t\n\tColoredPart.prototype.toString = function() {\n\t    return this.text+'';\n\t};\n\t\n\tvar GradientPart = function(coloredParts) {\n\t    this.coloredParts = coloredParts;\n\t};\n\t\n\tvar isGradientPart = function(o) {\n\t  return o instanceof GradientPart;\n\t};\n\t\n\tGradientPart.prototype.toString = function() {\n\t\tvar i;\n\t\tvar resultArray = [];\n\t\tfor(i = 0; i < this.coloredParts.length; i++){\n\t\t\tresultArray.push(this.coloredParts[i].text+'');\n\t\t}\n\t\treturn resultArray.join(\"\");\n\t\n\t};\n\t\n\tvar MultiPart = function(text, locations, solid) {\n\t    this.text = text;\n\t    this.locations = locations;\n\t    this.solid = solid;\n\t};\n\t\n\tvar isMultiPart = function(o) {\n\t  return o instanceof MultiPart;\n\t};\n\t\n\tMultiPart.prototype.toString = function() {\n\t\treturn this.text;\n\t};\n\t\n\t\n\t//////////////////////////////////////////////////////////////////////\n\t\n\t\n\t\n\t\n\t\n\tvar makeList = function(args) {\n\t    var result = Empty.EMPTY;\n\t    var i;\n\t    for(i = args.length-1; i >= 0; i--) {\n\t\tresult = Cons.makeInstance(args[i], result);\n\t    }\n\t    return result;\n\t};\n\t\n\t\n\tvar makeVector = function(args) {\n\t    return Vector.makeInstance(args.length, args);\n\t};\n\t\n\tvar makeString = function(s) {\n\t\tif (s instanceof Str) {\n\t\t\treturn s;\n\t\t}\n\t\telse if (s instanceof Array) {\n\t//\t\tfor (var i = 0; i < s.length; i++) {\n\t//\t\t\tif ( typeof s[i] !== 'string' || s[i].length != 1 ) {\n\t//\t\t\t\treturn undefined;\n\t//\t\t\t}\n\t//\t\t}\n\t\t\treturn Str.makeInstance(s);\n\t\t}\n\t\telse if (typeof s === 'string') {\n\t\t\treturn Str.fromString(s);\n\t\t}\n\t\telse {\n\t\t\tthrow types.internalError('makeString expects and array of 1-character strings or a string;' +\n\t\t\t\t\t\t  ' given ' + s.toString(),\n\t\t\t\t\t\t  false);\n\t\t}\n\t};\n\t\n\t\n\tvar makeHashEq = function(lst) {\n\t\tvar newHash = new EqHashTable();\n\t\twhile ( !lst.isEmpty() ) {\n\t\t\tnewHash.hash.put(lst.first().first(), lst.first().rest());\n\t\t\tlst = lst.rest();\n\t\t}\n\t\treturn newHash;\n\t};\n\t\n\t\n\tvar makeHashEqual = function(lst) {\n\t\tvar newHash = new EqualHashTable();\n\t\twhile ( !lst.isEmpty() ) {\n\t\t\tnewHash.hash.put(lst.first().first(), lst.first().rest());\n\t\t\tlst = lst.rest();\n\t\t}\n\t\treturn newHash;\n\t};\n\t\n\t\n\t//if there is not enough location information available,\n\t//this allows for highlighting to be turned off\n\tvar NoLocation = makeVector(['<no-location>', 0,0,0,0]);\n\t\n\tvar isNoLocation = function(o) {\n\t  return o === NoLocation;\n\t};\n\t\n\t\n\t\n\tvar Posn = makeStructureType('posn', false, 2, 0, false, false);\n\tvar Color = makeStructureType('color', false, 4, 0, false, false);\n\tvar ArityAtLeast = makeStructureType('arity-at-least', false, 1, 0, false,\n\t\t\tfunction(k, n, name) {\n\t\t\t\thelpers.check(undefined, n, function(x) { return ( jsnums.isExact(x) &&\n\t\t\t\t\t\t\t\t\tjsnums.isInteger(x) &&\n\t\t\t\t\t\t\t\t\tjsnums.greaterThanOrEqual(x, 0) ); },\n\t\t\t\t\t      name, 'exact non-negative integer', 1);\n\t\t\t\tk(n);\n\t\t\t});\n\t\n\t\n\ttypes.symbol = Symbol.makeInstance;\n\ttypes.rational = jsnums.makeRational;\n\ttypes['float'] = jsnums.makeFloat;\n\ttypes.complex = jsnums.makeComplex;\n\ttypes.bignum = jsnums.makeBignum;\n\ttypes.list = makeList;\n\ttypes.vector = makeVector;\n\ttypes.regexp = function(p) { return new RegularExpression(p) ; }\n\ttypes.byteRegexp = function(p) { return new ByteRegularExpression(p) ; }\n\ttypes['char'] = Char.makeInstance;\n\ttypes['string'] = makeString;\n\ttypes.box = function(x) { return new Box(x, true); };\n\ttypes.boxImmutable = function(x) { return new Box(x, false); };\n\ttypes.path = function(x) { return new Path(x); };\n\ttypes.bytes = function(x, mutable) { return new Bytes(x, mutable); };\n\ttypes.keyword = function(k) { return new Keyword(k); };\n\ttypes.pair = function(x, y) { return Cons.makeInstance(x, y); };\n\ttypes.hash = makeHashEqual;\n\ttypes.hashEq = makeHashEq;\n\ttypes.jsObject = function(name, obj) { return new JsObject(name, obj); };\n\t\n\ttypes.toWrittenString = toWrittenString;\n\ttypes.toDisplayedString = toDisplayedString;\n\ttypes.toDomNode = toDomNode;\n\t\n\ttypes.posn = Posn.constructor;\n\ttypes.posnX = function(psn) { return Posn.accessor(psn, 0); };\n\ttypes.posnY = function(psn) { return Posn.accessor(psn, 1); };\n\t\n\ttypes.color = function(r, g, b, a) { \n\t    if (a === undefined) {\n\t        a = 255;\n\t    }\n\t    return Color.constructor(r, g, b, a);\n\t};\n\ttypes.colorRed = function(x) { return Color.accessor(x, 0); };\n\ttypes.colorGreen = function(x) { return Color.accessor(x, 1); };\n\ttypes.colorBlue = function(x) { return Color.accessor(x, 2); };\n\ttypes.colorAlpha = function(x) { return Color.accessor(x, 3); };\n\t\n\ttypes.arityAtLeast = ArityAtLeast.constructor;\n\ttypes.arityValue = function(arity) { return ArityAtLeast.accessor(arity, 0); };\n\t\n\t\n\ttypes.FALSE = Logic.FALSE;\n\ttypes.TRUE = Logic.TRUE;\n\ttypes.EMPTY = Empty.EMPTY;\n\t\n\ttypes.isEqual = isEqual;\n\ttypes.isNumber = isNumber;\n\ttypes.isSymbol = function(x) { return x instanceof Symbol; };\n\ttypes.isChar = function(x) { return x instanceof Char; };\n\ttypes.isString = isString;\n\ttypes.isPair = function(x) { return x instanceof Cons; };\n\ttypes.isVector = function(x) { return x instanceof Vector; };\n\ttypes.isBox = function(x) { return x instanceof Box; };\n\ttypes.isHash = function(x) { return (x instanceof EqHashTable ||\n\t\t\t\t\t     x instanceof EqualHashTable); };\n\ttypes.isByteString = function(x) { return x instanceof Bytes; };\n\ttypes.isStruct = function(x) { return x instanceof Struct; };\n\ttypes.isPosn = Posn.predicate;\n\ttypes.isArityAtLeast = ArityAtLeast.predicate;\n\ttypes.isColor = Color.predicate;\n\ttypes.isFunction = function(x) {\n\t\treturn (x instanceof PrimProc ||\n\t\t\tx instanceof CasePrimitive ||\n\t\t\tx instanceof ClosureValue ||\n\t\t\tx instanceof CaseLambdaValue ||\n\t\t\tx instanceof ContinuationClosureValue);\n\t};\n\ttypes.getProcedureType = function(x){\n\t return (x instanceof PrimProc)? \"PrimProc\" :\n\t       (x instanceof CasePrimitive)? \"CasePrimitive\" :\n\t       (x instanceof ClosureValue)? \"ClosureValue\" :\n\t       (x instanceof CaseLambdaValue)? \"CaseLambdaValue\" :\n\t       (x instanceof ContinuationClosureValue)? \"ContinuationClosureValue\" :\n\t       /* else */ false;\n\t};\n\t \n\ttypes.isJsObject = function(x) { return x instanceof JsObject; };\n\t\n\ttypes.UnionFind = UnionFind;\n\ttypes.cons = Cons.makeInstance;\n\t\n\ttypes.UNDEFINED = UNDEFINED_VALUE;\n\ttypes.VOID = VOID_VALUE;\n\ttypes.EOF = EOF_VALUE;\n\t\n\ttypes.ValuesWrapper = ValuesWrapper;\n\ttypes.ClosureValue = ClosureValue;\n\ttypes.ContinuationPrompt = ContinuationPrompt;\n\ttypes.defaultContinuationPrompt = defaultContinuationPrompt;\n\ttypes.ContinuationClosureValue = ContinuationClosureValue;\n\ttypes.CaseLambdaValue = CaseLambdaValue;\n\ttypes.PrimProc = PrimProc;\n\ttypes.CasePrimitive = CasePrimitive;\n\t\n\ttypes.contMarkRecordControl = function(dict) { return new ContMarkRecordControl(dict); };\n\ttypes.isContMarkRecordControl = function(x) { return x instanceof ContMarkRecordControl; };\n\ttypes.continuationMarkSet = function(dict) { return new ContinuationMarkSet(dict); };\n\ttypes.isContinuationMarkSet = function(x) { return x instanceof ContinuationMarkSet; };\n\t\n\t\n\ttypes.PrefixValue = PrefixValue;\n\ttypes.GlobalBucket = GlobalBucket;\n\ttypes.ModuleVariableRecord = ModuleVariableRecord;\n\ttypes.VariableReference = VariableReference;\n\t\n\ttypes.Box = Box;\n\ttypes.ThreadCell = ThreadCell;\n\t\n\t\n\t\n\ttypes.Class = Class;\n\t\n\t\n\ttypes.makeStructureType = makeStructureType;\n\ttypes.isStructType = function(x) { return x instanceof StructType; };\n\t\n\t\n\ttypes.makeLowLevelEqHash = makeLowLevelEqHash;\n\t\n\t\n\t// Error type exports\n\tvar InternalError = function(val, contMarks) {\n\t\tthis.val = val;\n\t\tthis.contMarks = (contMarks ? contMarks : false);\n\t}\n\ttypes.internalError = function(v, contMarks) { return new InternalError(v, contMarks); };\n\ttypes.isInternalError = function(x) { return x instanceof InternalError; };\n\t\n\tvar SchemeError = function(val) {\n\t\tthis.val = val;\n\t}\n\ttypes.schemeError = function(v) { return new SchemeError(v); };\n\ttypes.isSchemeError = function(v) { return v instanceof SchemeError; };\n\t\n\t\n\tvar IncompleteExn = function(constructor, msg, otherArgs) {\n\t\tthis.constructor = constructor;\n\t\tthis.msg = msg;\n\t\tthis.otherArgs = otherArgs;\n\t};\n\ttypes.incompleteExn = function(constructor, msg, args) { return new IncompleteExn(constructor, msg, args); };\n\ttypes.isIncompleteExn = function(x) { return x instanceof IncompleteExn; };\n\t\n\tvar Exn = makeStructureType('exn', false, 2, 0, false,\n\t\t\tfunction(k, msg, contMarks, name) {\n\t\t\t\t// helpers.check(msg, isString, name, 'string', 1, [msg, contMarks]);\n\t\t\t\thelpers.check(undefined, contMarks, types.isContinuationMarkSet, name, 'continuation mark set', 2);\n\t\t\t\tk( new ValuesWrapper([msg, contMarks]) );\n\t\t\t});\n\ttypes.exn = Exn.constructor;\n\ttypes.isExn = Exn.predicate;\n\ttypes.exnMessage = function(exn) { return Exn.accessor(exn, 0); };\n\ttypes.exnContMarks = function(exn) { return Exn.accessor(exn, 1); };\n\ttypes.exnSetContMarks = function(exn, v) { Exn.mutator(exn, 1, v); };\n\t\n\t// (define-struct (exn:break exn) (continuation))\n\tvar ExnBreak = makeStructureType('exn:break', Exn, 1, 0, false,\n\t\t\tfunction(k, msg, contMarks, cont, name) {\n\t\t\t// FIXME: what type is a continuation here?\n\t//\t\t\thelpers.check(cont, isContinuation, name, 'continuation', 3);\n\t\t\t\tk( new ValuesWrapper([msg, contMarks, cont]) );\n\t\t\t});\n\ttypes.exnBreak = ExnBreak.constructor;\n\ttypes.isExnBreak = ExnBreak.predicate;\n\ttypes.exnBreakContinuation = function(exn) {\n\t    return ExnBreak.accessor(exn, 0); };\n\t\n\tvar ExnFail = makeStructureType('exn:fail', Exn, 0, 0, false, false);\n\ttypes.exnFail = ExnFail.constructor;\n\ttypes.isExnFail = ExnFail.predicate;\n\t\n\tvar ExnFailContract = makeStructureType('exn:fail:contract', ExnFail, 0, 0, false, false);\n\ttypes.exnFailContract = ExnFailContract.constructor;\n\ttypes.isExnFailContract = ExnFailContract.predicate;\n\t\n\tvar ExnFailContractArity = makeStructureType('exn:fail:contract:arity', ExnFailContract, 0, 0, false, false);\n\ttypes.exnFailContractArity = ExnFailContract.constructor;\n\ttypes.isExnFailContractArity = ExnFailContract.predicate;\n\t\n\tvar ExnFailContractVariable = makeStructureType('exn:fail:contract:variable', ExnFailContract, 1, 0, false, false);\n\ttypes.exnFailContractVariable = ExnFailContract.constructor;\n\ttypes.isExnFailContractVariable = ExnFailContract.predicate;\n\ttypes.exnFailContractVariableId = function(exn) { return ExnFailContractVariable.accessor(exn, 0); };\n\t\n\tvar ExnFailContractDivisionByZero = makeStructureType('exn:fail:contract:division-by-zero', ExnFailContract, 0, 0, false, false);\n\ttypes.exnFailContractDivisionByZero = ExnFailContractDivisionByZero.constructor;\n\ttypes.isExnFailContractDivisionByZero = ExnFailContractDivisionByZero.predicate;\n\t\n\tvar ExnFailContractArityWithPosition = makeStructureType('exn:fail:contract:arity:position', ExnFailContractArity, 1, 0, false, false);\n\ttypes.exnFailContractArityWithPosition = ExnFailContractArityWithPosition.constructor;\n\ttypes.isExnFailContractArityWithPosition = ExnFailContractArityWithPosition.predicate;\n\t\n\ttypes.exnFailContractArityWithPositionLocations = function(exn) { return ExnFailContractArityWithPosition.accessor(exn, 0); };\n\t\n\t\n\t///////////////////////////////////////\n\t// World-specific exports\n\t\n\ttypes.worldConfig = function(startup, shutdown, args) { return new WorldConfig(startup, shutdown, args); };\n\ttypes.isWorldConfig = function(x) { return x instanceof WorldConfig; };\n\t\n\ttypes.makeEffectType = makeEffectType;\n\ttypes.isEffectType = function(x) {\n\t\treturn (x instanceof StructType && x.type.prototype.invokeEffect) ? true : false;\n\t};\n\t\n\t\n\ttypes.isEffect = Effect.predicate;\n\t\n\t//types.EffectDoNothing = makeEffectType('effect:do-nothing',\n\t//\t\t\t\t       false,\n\t//\t\t\t\t       0,\n\t//\t\t\t\t       function(k) { k(); },\n\t//\t\t\t\t       [],\n\t//\t\t\t\t       function(k) { k(new ValuesWrapper([])); },\n\t//\t\t\t\t       function(f, args, k) { f(k); });\n\t//types.effectDoNothing = EffectDoNothing.constructor;\n\t//types.isEffectDoNothing = EffectDoNothing.predicate;\n\t\n\t\n\t//RenderEffect = makeStructureType('render-effect', false, 2, 0, false,\n\t//\t\tfunction(k, domNode, effects, name) {\n\t//\t\t\thelpers.checkListOf(effects, helpers.procArityContains(0), name, 'procedure (arity 0)', 2);\n\t//\t\t\tk( new ValuesWrapper([domNode, effects]) );\n\t//\t\t});\n\t\n\ttypes.makeRenderEffectType = makeRenderEffectType;\n\ttypes.isRenderEffectType = function(x) {\n\t\treturn (x instanceof StructType && x.type.prototype.callImplementation) ? true : false;\n\t};\n\t\n\t//types.RenderEffect = RenderEffect;\n\t//types.makeRenderEffect = RenderEffect.constructor;\n\ttypes.isRenderEffect = RenderEffect.predicate;\n\t//types.renderEffectDomNode = function(x) { return RenderEffect.accessor(x, 0); };\n\t//types.renderEffectEffects = function(x) { return RenderEffect.accessor(x, 1); };\n\t//types.setRenderEffectEffects = function(x, v) { RenderEffect.mutator(x, 1, v); };\n\t\n\t\n\ttypes.NoLocation = NoLocation;\n\ttypes.isNoLocation = isNoLocation;\n\t\n\t\n\t\n\ttypes.ColoredPart = ColoredPart;\n\ttypes.Message = Message;\n\ttypes.isColoredPart = isColoredPart;\n\ttypes.isMessage = isMessage;\n\ttypes.GradientPart = GradientPart;\n\ttypes.isGradientPart = isGradientPart;\n\ttypes.MultiPart = MultiPart;\n\ttypes.isMultiPart = isMultiPart;\n\ttypes.Vector = Vector;\n\t\n\t\n\t})();\n\t\n\tmodule.exports = types;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Scheme numbers.\n\t\n\t\n\tvar __PLTNUMBERS_TOP__;\n\tif (true) {\n\t    __PLTNUMBERS_TOP__ = exports;\n\t} else {\n\t    if (! this['jsnums']) {\n\t \tthis['jsnums'] = {};\n\t    }\n\t    __PLTNUMBERS_TOP__  = this['jsnums'];\n\t}\n\t\n\t//var jsnums = {};\n\t\n\t\n\t// The numeric tower has the following levels:\n\t//     integers\n\t//     rationals\n\t//     floats\n\t//     complex numbers\n\t//\n\t// with the representations:\n\t//     integers: fixnum or BigInteger [level=0]\n\t//     rationals: Rational [level=1]\n\t//     floats: FloatPoint [level=2]\n\t//     complex numbers: Complex [level=3]\n\t\n\t// We try to stick with the unboxed fixnum representation for\n\t// integers, since that's what scheme programs commonly deal with, and\n\t// we want that common type to be lightweight.\n\t\n\t\n\t// A boxed-scheme-number is either BigInteger, Rational, FloatPoint, or Complex.\n\t// An integer-scheme-number is either fixnum or BigInteger.\n\t\n\t\n\t(function() {\n\t    'use strict';\n\t    // Abbreviation\n\t    var Numbers = __PLTNUMBERS_TOP__;\n\t    //var Numbers = jsnums;\n\t\n\t\n\t    // makeNumericBinop: (fixnum fixnum -> any) (scheme-number scheme-number -> any) -> (scheme-number scheme-number) X\n\t    // Creates a binary function that works either on fixnums or boxnums.\n\t    // Applies the appropriate binary function, ensuring that both scheme numbers are\n\t    // lifted to the same level.\n\t    var makeNumericBinop = function(onFixnums, onBoxednums, options) {\n\t\toptions = options || {};\n\t\treturn function(x, y) {\n\t\t    if (options.isXSpecialCase && options.isXSpecialCase(x))\n\t\t\treturn options.onXSpecialCase(x, y);\n\t\t    if (options.isYSpecialCase && options.isYSpecialCase(y))\n\t\t\treturn options.onYSpecialCase(x, y);\n\t\n\t\t    if (typeof(x) === 'number' &&\n\t\t\ttypeof(y) === 'number') {\n\t\t\treturn onFixnums(x, y);\n\t\t    }\n\t\t    if (typeof(x) === 'number') {\n\t\t\tx = liftFixnumInteger(x, y);\n\t\t    }\n\t\t    if (typeof(y) === 'number') {\n\t\t\ty = liftFixnumInteger(y, x);\n\t\t    }\n\t\n\t\t    if (x.level < y.level) x = x.liftTo(y);\n\t\t    if (y.level < x.level) y = y.liftTo(x);\n\t\t    return onBoxednums(x, y);\n\t\t};\n\t    }\n\t    \n\t    \n\t    // fromFixnum: fixnum -> scheme-number\n\t    var fromFixnum = function(x) {\n\t\tif (isNaN(x) || (! isFinite(x))) {\n\t\t    return FloatPoint.makeInstance(x);\n\t\t}\n\t\tvar nf = Math.floor(x);\n\t\tif (nf === x) {\n\t            if (isOverflow(nf)) {\n\t\t\treturn makeBignum(expandExponent(x+''));\n\t            } else {\n\t\t\treturn nf;\n\t\t    }\n\t\t} else {\n\t            return FloatPoint.makeInstance(x);\n\t\t}\n\t    };\n\t\n\t    var expandExponent = function(s) {\n\t\tvar match = s.match(scientificPattern(digitsForRadix(10), expMarkForRadix(10))), mantissaChunks, exponent;\n\t\tif (match) {\n\t\t    mantissaChunks = match[1].match(/^([^.]*)(.*)$/);\n\t\t    exponent = Number(match[2]);\n\t\n\t\t    if (mantissaChunks[2].length === 0) {\n\t\t\treturn mantissaChunks[1] + zfill(exponent);\n\t\t    }\n\t\n\t\t    if (exponent >= mantissaChunks[2].length - 1) {\n\t\t\treturn (mantissaChunks[1] + \n\t\t\t\tmantissaChunks[2].substring(1) + \n\t\t\t\tzfill(exponent - (mantissaChunks[2].length - 1)));\n\t\t    } else {\n\t\t\treturn (mantissaChunks[1] +\n\t\t\t\tmantissaChunks[2].substring(1, 1+exponent));\n\t\t    }\n\t\t} else {\n\t\t    return s;\n\t\t}\n\t    };\n\t\n\t    // zfill: integer -> string\n\t    // builds a string of \"0\"'s of length n.\n\t    var zfill = function(n) {\n\t\tvar buffer = [];\n\t\tbuffer.length = n;\n\t\tfor (var i = 0; i < n; i++) {\n\t\t    buffer[i] = '0';\n\t\t}\n\t\treturn buffer.join('');\n\t    };\n\t    \n\t\n\t    \n\t    // liftFixnumInteger: fixnum-integer boxed-scheme-number -> boxed-scheme-number\n\t    // Lifts up fixnum integers to a boxed type.\n\t    var liftFixnumInteger = function(x, other) {\n\t\tswitch(other.level) {\n\t\tcase 0: // BigInteger\n\t\t    return makeBignum(x);\n\t\tcase 1: // Rational\n\t\t    return new Rational(x, 1);\n\t\tcase 2: // FloatPoint\n\t\t    return new FloatPoint(x);\n\t\tcase 3: // Complex\n\t\t    return new Complex(x, 0);\n\t\tdefault:\n\t\t    throwRuntimeError(\"IMPOSSIBLE: cannot lift fixnum integer to \" + other.toString(), x, other);\n\t\t}\n\t    };\n\t    \n\t    \n\t    // throwRuntimeError: string (scheme-number | undefined) (scheme-number | undefined) -> void\n\t    // Throws a runtime error with the given message string.\n\t    var throwRuntimeError = function(msg, x, y) {\n\t\tNumbers['onThrowRuntimeError'](msg, x, y);\n\t    };\n\t\n\t\n\t\n\t    // onThrowRuntimeError: string (scheme-number | undefined) (scheme-number | undefined) -> void\n\t    // By default, will throw a new Error with the given message.\n\t    // Override Numbers['onThrowRuntimeError'] if you need to do something special.\n\t    var onThrowRuntimeError = function(msg, x, y) {\n\t\tthrow new Error(msg);\n\t    };\n\t\n\t\n\t    // isSchemeNumber: any -> boolean\n\t    // Returns true if the thing is a scheme number.\n\t    var isSchemeNumber = function(thing) {\n\t\treturn (typeof(thing) === 'number'\n\t\t\t|| (thing instanceof Rational ||\n\t\t\t    thing instanceof FloatPoint ||\n\t\t\t    thing instanceof Complex ||\n\t\t\t    thing instanceof BigInteger));\n\t    };\n\t\n\t\n\t    // isRational: scheme-number -> boolean\n\t    var isRational = function(n) {\n\t\treturn (typeof(n) === 'number' ||\n\t\t\t(isSchemeNumber(n) && n.isRational()));\n\t    };\n\t\n\t    // isReal: scheme-number -> boolean\n\t    var isReal = function(n) {\n\t\treturn (typeof(n) === 'number' ||\n\t\t\t(isSchemeNumber(n) && n.isReal()));\n\t    };\n\t\n\t    // isExact: scheme-number -> boolean\n\t    var isExact = function(n) {\n\t\treturn (typeof(n) === 'number' || \n\t\t\t(isSchemeNumber(n) && n.isExact()));\n\t    };\n\t\n\t    // isExact: scheme-number -> boolean\n\t    var isInexact = function(n) {\n\t\tif (typeof(n) === 'number') {\n\t\t    return false;\n\t\t} else {\n\t\t    return (isSchemeNumber(n) && n.isInexact());\n\t\t}\n\t    };\n\t\n\t    // isInteger: scheme-number -> boolean\n\t    var isInteger = function(n) {\n\t\treturn (typeof(n) === 'number' ||\n\t\t\t(isSchemeNumber(n) && n.isInteger()));\n\t    };\n\t\n\t    // isExactInteger: scheme-number -> boolean\n\t    var isExactInteger = function(n) {\n\t\treturn (typeof(n) === 'number' ||\n\t\t\t(isSchemeNumber(n) && \n\t\t\t n.isInteger() && \n\t\t\t n.isExact()));\n\t    }\n\t\n\t\n\t\n\t    // toFixnum: scheme-number -> javascript-number\n\t    var toFixnum = function(n) {\n\t\tif (typeof(n) === 'number')\n\t\t    return n;\n\t\treturn n.toFixnum();\n\t    };\n\t\n\t    // toExact: scheme-number -> scheme-number\n\t    var toExact = function(n) {\n\t\tif (typeof(n) === 'number')\n\t\t    return n;\n\t\treturn n.toExact();\n\t    };\n\t\n\t\n\t    // toExact: scheme-number -> scheme-number\n\t    var toInexact = function(n) {\n\t\tif (typeof(n) === 'number')\n\t\t    return FloatPoint.makeInstance(n);\n\t\treturn n.toInexact();\n\t    };\n\t\n\t\n\t\n\t    //////////////////////////////////////////////////////////////////////\n\t\n\t\n\t    // add: scheme-number scheme-number -> scheme-number\n\t    var add = function(x, y) {\n\t        var sum;\n\t        if (typeof(x) === 'number' && typeof(y) === 'number') {\n\t            sum = x + y;\n\t            if (isOverflow(sum)) {\n\t\t\treturn (makeBignum(x)).add(makeBignum(y));\n\t            }\n\t        }\n\t        if (x instanceof FloatPoint && y instanceof FloatPoint) {\n\t            return x.add(y);\n\t        }\n\t        return addSlow(x, y);        \n\t    };\n\t\n\t    var addSlow = makeNumericBinop(\n\t\tfunction(x, y) {\n\t\t    var sum = x + y;\n\t\t    if (isOverflow(sum)) {\n\t\t\treturn (makeBignum(x)).add(makeBignum(y));\n\t\t    } else {\n\t\t\treturn sum;\n\t\t    }\n\t\t},\n\t\tfunction(x, y) {\n\t\t    return x.add(y);\n\t\t},\n\t\t{isXSpecialCase: function(x) { \n\t\t    return isExactInteger(x) && _integerIsZero(x) },\n\t\t onXSpecialCase: function(x, y) { return y; },\n\t\t isYSpecialCase: function(y) { \n\t\t     return isExactInteger(y) && _integerIsZero(y) },\n\t\t onYSpecialCase: function(x, y) { return x; }\n\t\t});\n\t\n\t\n\t    // subtract: scheme-number scheme-number -> scheme-number\n\t    var subtract = makeNumericBinop(\n\t\tfunction(x, y) {\n\t\t    var diff = x - y;\n\t\t    if (isOverflow(diff)) {\n\t\t\treturn (makeBignum(x)).subtract(makeBignum(y));\n\t\t    } else {\n\t\t\treturn diff;\n\t\t    }\n\t\t},\n\t\tfunction(x, y) {\n\t\t    return x.subtract(y);\n\t\t},\n\t\t{isXSpecialCase: function(x) { \n\t\t    return isExactInteger(x) && _integerIsZero(x) },\n\t\t onXSpecialCase: function(x, y) { return negate(y); },\n\t\t isYSpecialCase: function(y) { \n\t\t     return isExactInteger(y) && _integerIsZero(y) },\n\t\t onYSpecialCase: function(x, y) { return x; }\n\t\t});\n\t\n\t\n\t    // mulitply: scheme-number scheme-number -> scheme-number\n\t    var multiply = function(x, y) {\n\t        var prod;\n\t        if (typeof(x) === 'number' && typeof(y) === 'number') {\n\t\t    prod = x * y;\n\t\t    if (isOverflow(prod)) {\n\t\t\treturn (makeBignum(x)).multiply(makeBignum(y));\n\t            } else {\n\t                return prod;\n\t            }\n\t        }\n\t        if (x instanceof FloatPoint && y instanceof FloatPoint) {\n\t            return x.multiply(y);\n\t        }\n\t        return multiplySlow(x, y);\n\t    };\n\t    var multiplySlow = makeNumericBinop(\n\t\tfunction(x, y) {\n\t\t    var prod = x * y;\n\t\t    if (isOverflow(prod)) {\n\t\t\treturn (makeBignum(x)).multiply(makeBignum(y));\n\t\t    } else {\n\t\t\treturn prod;\n\t\t    }\n\t\t},\n\t\tfunction(x, y) {\n\t\t    return x.multiply(y);\n\t\t},\n\t\t{isXSpecialCase: function(x) { \n\t\t    return (isExactInteger(x) && \n\t\t\t    (_integerIsZero(x) || _integerIsOne(x) || _integerIsNegativeOne(x))) },\n\t\t onXSpecialCase: function(x, y) { \n\t\t     if (_integerIsZero(x))\n\t\t\t return 0;\n\t\t     if (_integerIsOne(x))\n\t\t\t return y;\n\t\t     if (_integerIsNegativeOne(x))\n\t\t\t return negate(y);\n\t\t },\n\t\t isYSpecialCase: function(y) { \n\t\t     return (isExactInteger(y) && \n\t\t\t     (_integerIsZero(y) || _integerIsOne(y) || _integerIsNegativeOne(y)))},\n\t\t onYSpecialCase: function(x, y) { \n\t\t     if (_integerIsZero(y))\n\t\t\t return 0;\n\t\t     if (_integerIsOne(y))\n\t\t\t return x;\n\t\t     if (_integerIsNegativeOne(y)) \n\t\t\t return negate(x);\n\t\t }\n\t\t});\n\t\n\t    \n\t    // divide: scheme-number scheme-number -> scheme-number\n\t    var divide = makeNumericBinop(\n\t\tfunction(x, y) {\n\t\t    if (_integerIsZero(y))\n\t\t\tthrowRuntimeError(\"/: division by zero\", x, y);\n\t\t    var div = x / y;\n\t\t    if (isOverflow(div)) {\n\t\t\treturn (makeBignum(x)).divide(makeBignum(y));\n\t\t    } else if (Math.floor(div) !== div) {\n\t\t\treturn Rational.makeInstance(x, y);\n\t\t    } else {\n\t\t\treturn div;\n\t\t    }\n\t\t},\n\t\tfunction(x, y) {\n\t\t    return x.divide(y);\n\t\t},\n\t\t{ isXSpecialCase: function(x) {\n\t\t    return (eqv(x, 0));\n\t\t},\n\t\t  onXSpecialCase: function(x, y) {\n\t\t      if (eqv(y, 0)) {\n\t\t\t  throwRuntimeError(\"/: division by zero\", x, y);\n\t\t      }\n\t\t      return 0;\n\t\t  },\n\t\t  isYSpecialCase: function(y) { \n\t\t    return (eqv(y, 0)); },\n\t\t  onYSpecialCase: function(x, y) {\n\t\t      throwRuntimeError(\"/: division by zero\", x, y);\n\t\t  }\n\t\t});\n\t    \n\t    \n\t    // equals: scheme-number scheme-number -> boolean\n\t    var equals = makeNumericBinop(\n\t\tfunction(x, y) {\n\t\t    return x === y;\n\t\t},\n\t\tfunction(x, y) {\n\t\t    return x.equals(y);\n\t\t});\n\t\n\t\n\t    // eqv: scheme-number scheme-number -> boolean\n\t    var eqv = function(x, y) {\n\t\tif (x === y)\n\t\t    return true;\n\t\tif (typeof(x) === 'number' && typeof(y) === 'number')\n\t\t    return x === y;\n\t\tif (x === NEGATIVE_ZERO || y === NEGATIVE_ZERO)\n\t\t    return x === y;\n\t\tif (x instanceof Complex || y instanceof Complex) {\n\t\t    return (eqv(realPart(x), realPart(y)) &&\n\t\t\t    eqv(imaginaryPart(x), imaginaryPart(y)));\n\t\t}\n\t\tvar ex = isExact(x), ey = isExact(y);\n\t\treturn (((ex && ey) || (!ex && !ey)) && equals(x, y));\n\t    };\n\t\n\t    // approxEqual: scheme-number scheme-number scheme-number -> boolean\n\t    var approxEquals = function(x, y, delta) {\n\t\treturn lessThan(abs(subtract(x, y)),\n\t                        delta);\n\t    };\n\t\n\t    // greaterThanOrEqual: scheme-number scheme-number -> boolean\n\t    var greaterThanOrEqual = makeNumericBinop(\n\t\tfunction(x, y) {\n\t\t    return x >= y;\n\t\t},\n\t\tfunction(x, y) {\n\t\t    if (!(isReal(x) && isReal(y)))\n\t\t\tthrowRuntimeError(\n\t\t\t    \">=: couldn't be applied to complex number\", x, y);\n\t\t    return x.greaterThanOrEqual(y);\n\t\t});\n\t\n\t\n\t    // lessThanOrEqual: scheme-number scheme-number -> boolean\n\t    var lessThanOrEqual = makeNumericBinop(\n\t\tfunction(x, y){\n\t\n\t\t    return x <= y;\n\t\t},\n\t\tfunction(x, y) {\n\t\t    if (!(isReal(x) && isReal(y)))\n\t\t\tthrowRuntimeError(\"<=: couldn't be applied to complex number\", x, y);\n\t\t    return x.lessThanOrEqual(y);\n\t\t});\n\t\n\t\n\t    // greaterThan: scheme-number scheme-number -> boolean\n\t    var greaterThan = makeNumericBinop(\n\t\tfunction(x, y){\n\t\t    return x > y;\n\t\t},\n\t\tfunction(x, y) {\n\t\t    if (!(isReal(x) && isReal(y)))\n\t\t\tthrowRuntimeError(\">: couldn't be applied to complex number\", x, y);\n\t\t    return x.greaterThan(y);\n\t\t});\n\t\n\t\n\t    // lessThan: scheme-number scheme-number -> boolean\n\t    var lessThan = makeNumericBinop(\n\t\tfunction(x, y){\n\t\n\t\t    return x < y;\n\t\t},\n\t\tfunction(x, y) {\n\t\t    if (!(isReal(x) && isReal(y)))\n\t\t\tthrowRuntimeError(\"<: couldn't be applied to complex number\", x, y);\n\t\t    return x.lessThan(y);\n\t\t});\n\t\n\t\n\t\n\t    // expt: scheme-number scheme-number -> scheme-number\n\t    var expt = (function() {\n\t\tvar _expt = makeNumericBinop(\n\t\t    function(x, y){\n\t\t\tvar pow = Math.pow(x, y);\n\t\t\tif (isOverflow(pow)) {\n\t\t\t    return (makeBignum(x)).expt(makeBignum(y));\n\t\t\t} else {\n\t\t\t    return pow;\n\t\t\t}\n\t\t    },\n\t\t    function(x, y) {\n\t\t\tif (equals(y, 0)) {\n\t\t\t    return add(y, 1);\n\t\t\t} else {\n\t\t\t    return x.expt(y);\n\t\t\t}\n\t\t    });\n\t\treturn function(x, y) {\n\t\t    if (equals(y, 0)) \n\t\t\treturn add(y, 1);\n\t\t    if (isReal(y) && lessThan(y, 0)) {\n\t\t\treturn _expt(divide(1, x), negate(y));\n\t\t    }\n\t\t    return _expt(x, y);\n\t\t};\n\t    })();\n\t\n\t\n\t    // exp: scheme-number -> scheme-number\n\t    var exp = function(n) {\n\t\tif ( eqv(n, 0) ) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (typeof(n) === 'number') {\n\t\t    return FloatPoint.makeInstance(Math.exp(n));\n\t\t}\n\t\treturn n.exp();\n\t    };\n\t\n\t\n\t    // modulo: scheme-number scheme-number -> scheme-number\n\t    var modulo = function(m, n) {\n\t\tif (! isInteger(m)) {\n\t\t    throwRuntimeError('modulo: the first argument '\n\t\t\t\t      + m + \" is not an integer.\", m, n);\n\t\t}\n\t\tif (! isInteger(n)) {\n\t\t    throwRuntimeError('modulo: the second argument '\n\t\t\t\t      + n + \" is not an integer.\", m, n);\n\t\t}\n\t\tvar result;\n\t\tif (typeof(m) === 'number') {\n\t\t    result = m % n;\n\t\t    if (n < 0) {\n\t\t\tif (result <= 0)\n\t\t\t    return result;\n\t\t\telse\n\t\t\t    return result + n;\n\t\t    } else {\n\t\t\tif (result < 0)\n\t\t\t    return result + n;\n\t\t\telse\n\t\t\t    return result;\n\t\t    }\n\t\t}\n\t\tresult = _integerModulo(floor(m), floor(n));\n\t\t// The sign of the result should match the sign of n.\n\t\tif (lessThan(n, 0)) {\n\t\t    if (lessThanOrEqual(result, 0)) {\n\t\t\treturn result;\n\t\t    }\n\t\t    return add(result, n);\n\t\n\t\t} else {\n\t\t    if (lessThan(result, 0)) {\n\t\t\treturn add(result, n);\n\t\t    }\n\t\t    return result;\n\t\t}\n\t    };\n\t\n\t\n\t\n\t    // numerator: scheme-number -> scheme-number\n\t    var numerator = function(n) {\n\t\tif (typeof(n) === 'number')\n\t\t    return n;\n\t\treturn n.numerator();\n\t    };\n\t\n\t\n\t    // denominator: scheme-number -> scheme-number\n\t    var denominator = function(n) {\n\t\tif (typeof(n) === 'number')\n\t\t    return 1;\n\t\treturn n.denominator();\n\t    };\n\t\n\t    // sqrt: scheme-number -> scheme-number\n\t    var sqrt = function(n) {\n\t\tif (typeof(n) === 'number') {\n\t\t    if (n >= 0) {\n\t\t\tvar result = Math.sqrt(n);\n\t\t\tif (Math.floor(result) === result) {\n\t\t\t    return result;\n\t\t\t} else {\n\t\t\t    return FloatPoint.makeInstance(result);\n\t\t\t}\n\t\t    } else {\n\t\t\treturn (Complex.makeInstance(0, sqrt(-n)));\n\t\t    }\n\t\t}\n\t\treturn n.sqrt();\n\t    };\n\t\n\t    // abs: scheme-number -> scheme-number\n\t    var abs = function(n) {\n\t\tif (typeof(n) === 'number') {\n\t\t    return Math.abs(n);\n\t\t}\n\t\treturn n.abs();\n\t    };\n\t\n\t    // floor: scheme-number -> scheme-number\n\t    var floor = function(n) {\n\t\tif (typeof(n) === 'number')\n\t\t    return n;\n\t\treturn n.floor();\n\t    };\n\t\n\t    // ceiling: scheme-number -> scheme-number\n\t    var ceiling = function(n) {\n\t\tif (typeof(n) === 'number')\n\t\t    return n;\n\t\treturn n.ceiling();\n\t    };\n\t\n\t    // conjugate: scheme-number -> scheme-number\n\t    var conjugate = function(n) {\n\t\tif (typeof(n) === 'number')\n\t\t    return n;\n\t\treturn n.conjugate();\n\t    };\n\t\n\t    // magnitude: scheme-number -> scheme-number\n\t    var magnitude = function(n) {\n\t\tif (typeof(n) === 'number')\n\t\t    return Math.abs(n);\n\t\treturn n.magnitude();\n\t    };\n\t\n\t\n\t    // log: scheme-number -> scheme-number\n\t    var log = function(n) {\n\t\tif ( eqv(n, 1) ) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (typeof(n) === 'number') {\n\t\t    return FloatPoint.makeInstance(Math.log(n));\n\t\t}\n\t\treturn n.log();\n\t    };\n\t\n\t    // angle: scheme-number -> scheme-number\n\t    var angle = function(n) {\n\t\tif (typeof(n) === 'number') {\n\t\t    if (n > 0)\n\t\t\treturn 0;\n\t\t    else\n\t\t\treturn FloatPoint.pi;\n\t\t}\n\t\treturn n.angle();\n\t    };\n\t\n\t    // tan: scheme-number -> scheme-number\n\t    var tan = function(n) {\n\t\tif (eqv(n, 0)) { return 0; }\n\t\tif (typeof(n) === 'number') {\n\t\t    return FloatPoint.makeInstance(Math.tan(n));\n\t\t}\n\t\treturn n.tan();\n\t    };\n\t\n\t    // atan: scheme-number -> scheme-number\n\t    var atan = function(n) {\n\t\tif (eqv(n, 0)) { return 0; }\n\t\tif (typeof(n) === 'number') {\n\t\t    return FloatPoint.makeInstance(Math.atan(n));\n\t\t}\n\t\treturn n.atan();\n\t    };\n\t\n\t    // cos: scheme-number -> scheme-number\n\t    var cos = function(n) {\n\t\tif (eqv(n, 0)) { return 1; }\n\t\tif (typeof(n) === 'number') {\n\t\t    return FloatPoint.makeInstance(Math.cos(n));\n\t\t}\n\t\treturn n.cos();\n\t    };\n\t\n\t    // sin: scheme-number -> scheme-number\n\t    var sin = function(n) {\n\t\tif (eqv(n, 0)) { return 0; }\n\t\tif (typeof(n) === 'number') {\n\t\t    return FloatPoint.makeInstance(Math.sin(n));\n\t\t}\n\t\treturn n.sin();\n\t    };\n\t\n\t    // acos: scheme-number -> scheme-number\n\t    var acos = function(n) {\n\t\tif (eqv(n, 1)) { return 0; }\n\t\tif (typeof(n) === 'number') {\n\t\t    return FloatPoint.makeInstance(Math.acos(n));\n\t\t}\n\t\treturn n.acos();\n\t    };\n\t\n\t    // asin: scheme-number -> scheme-number\n\t    var asin = function(n) {\n\t        if (eqv(n, 0)) { return 0; }\n\t\tif (typeof(n) === 'number') {\n\t\t    return FloatPoint.makeInstance(Math.asin(n));\n\t\t}\n\t\treturn n.asin();\n\t    };\n\t\n\t    // imaginaryPart: scheme-number -> scheme-number\n\t    var imaginaryPart = function(n) {\n\t\tif (typeof(n) === 'number') {\n\t\t    return 0;\n\t\t}\n\t\treturn n.imaginaryPart();\n\t    };\n\t\n\t    // realPart: scheme-number -> scheme-number\n\t    var realPart = function(n) {\n\t\tif (typeof(n) === 'number') {\n\t\t    return n;\n\t\t}\n\t\treturn n.realPart();\n\t    };\n\t\n\t    // round: scheme-number -> scheme-number\n\t    var round = function(n) {\n\t\tif (typeof(n) === 'number') {\n\t\t    return n;\n\t\t}\n\t\treturn n.round();\n\t    };\n\t\n\t\n\t\n\t    // sqr: scheme-number -> scheme-number\n\t    var sqr = function(x) {\n\t\treturn multiply(x, x);\n\t    };\n\t\n\t\n\t    // integerSqrt: scheme-number -> scheme-number\n\t    var integerSqrt = function(x) {\n\t\tif (! isInteger(x)) {\n\t\t    throwRuntimeError('integer-sqrt: the argument ' + x.toString() +\n\t\t\t\t      \" is not an integer.\", x);\n\t\t}\n\t\tif (typeof (x) === 'number') {\n\t\t    if(x < 0) {\n\t\t        return Complex.makeInstance(0,\n\t\t\t\t\t\t    Math.floor(Math.sqrt(-x)))\n\t\t    } else {\n\t\t\treturn Math.floor(Math.sqrt(x));\n\t\t    }\n\t\t}\n\t\treturn x.integerSqrt();\n\t    };\n\t\n\t\n\t    // gcd: scheme-number [scheme-number ...] -> scheme-number\n\t    var gcd = function(first, rest) {\n\t\tif (! isInteger(first)) {\n\t\t    throwRuntimeError('gcd: the argument ' + first.toString() +\n\t\t\t\t      \" is not an integer.\", first);\n\t\t}\n\t\tvar a = abs(first), t, b;\n\t\tfor(var i = 0; i < rest.length; i++) {\n\t\t    b = abs(rest[i]);\t\n\t\t    if (! isInteger(b)) {\n\t\t\tthrowRuntimeError('gcd: the argument ' + b.toString() +\n\t\t\t\t\t  \" is not an integer.\", b);\n\t\t    }\n\t\t    while (! _integerIsZero(b)) {\n\t\t\tt = a;\n\t\t\ta = b;\n\t\t\tb = _integerModulo(t, b);\n\t\t    }\n\t\t}\n\t\treturn a;\n\t    };\n\t\n\t    // lcm: scheme-number [scheme-number ...] -> scheme-number\n\t    var lcm = function(first, rest) {\n\t\tif (! isInteger(first)) {\n\t\t    throwRuntimeError('lcm: the argument ' + first.toString() +\n\t\t\t\t      \" is not an integer.\", first);\n\t\t}\n\t\tvar result = abs(first);\n\t\tif (_integerIsZero(result)) { return 0; }\n\t\tfor (var i = 0; i < rest.length; i++) {\n\t\t    if (! isInteger(rest[i])) {\n\t\t\tthrowRuntimeError('lcm: the argument ' + rest[i].toString() +\n\t\t\t\t\t  \" is not an integer.\", rest[i]);\n\t\t    }\n\t\t    var divisor = _integerGcd(result, rest[i]);\n\t\t    if (_integerIsZero(divisor)) {\n\t\t\treturn 0;\n\t\t    }\n\t\t    result = divide(multiply(result, rest[i]), divisor);\n\t\t}\n\t\treturn result;\n\t    };\n\t    \n\t\n\t    var quotient = function(x, y) {\n\t \tif (! isInteger(x)) {\n\t\t    throwRuntimeError('quotient: the first argument ' + x.toString() +\n\t\t\t\t      \" is not an integer.\", x);\n\t\t}\n\t\tif (! isInteger(y)) {\n\t\t    throwRuntimeError('quotient: the second argument ' + y.toString() +\n\t\t\t\t      \" is not an integer.\", y);\n\t\t}\n\t\treturn _integerQuotient(x, y);\n\t    };\n\t\n\t    \n\t    var remainder = function(x, y) {\n\t\tif (! isInteger(x)) {\n\t\t    throwRuntimeError('remainder: the first argument ' + x.toString() +\n\t\t\t\t      \" is not an integer.\", x);\n\t\t}\n\t\tif (! isInteger(y)) {\n\t\t    throwRuntimeError('remainder: the second argument ' + y.toString() +\n\t\t\t\t      \" is not an integer.\", y);\n\t\t}\n\t\treturn _integerRemainder(x, y);\n\t    };\n\t\n\t\n\t    // Implementation of the hyperbolic functions\n\t    // http://en.wikipedia.org/wiki/Hyperbolic_cosine\n\t    var cosh = function(x) {\n\t\tif (eqv(x, 0)) {\n\t\t    return FloatPoint.makeInstance(1.0);\n\t\t}\n\t\treturn divide(add(exp(x), exp(negate(x))),\n\t\t\t      2);\n\t    };\n\t\t\n\t    var sinh = function(x) {\n\t\treturn divide(subtract(exp(x), exp(negate(x))),\n\t\t\t      2);\n\t    };\n\t\n\t\n\t        \n\t    var makeComplexPolar = function(r, theta) {\n\t\t// special case: if theta is zero, just return\n\t\t// the scalar.\n\t\tif (eqv(theta, 0)) {\n\t\t    return r;\n\t\t}\n\t\treturn Complex.makeInstance(multiply(r, cos(theta)),\n\t\t\t\t\t    multiply(r, sin(theta)));\n\t    };\n\t\n\t\n\t\n\t    //////////////////////////////////////////////////////////////////////\n\t\n\t    // Helpers\n\t\n\t\n\t    // IsFinite: scheme-number -> boolean\n\t    // Returns true if the scheme number is finite or not.\n\t    var isSchemeNumberFinite = function(n) {\n\t\tif (typeof(n) === 'number') {\n\t\t    return isFinite(n);\n\t\t} else {\n\t\t    return n.isFinite();\n\t\t}\n\t    };\n\t\n\t    // isOverflow: javascript-number -> boolean\n\t    // Returns true if we consider the number an overflow.\n\t    var MIN_FIXNUM = -(9e15);\n\t    var MAX_FIXNUM = (9e15);\n\t    var isOverflow = function(n) {\n\t\treturn (n < MIN_FIXNUM ||  MAX_FIXNUM < n);\n\t    };\n\t\n\t\n\t    // negate: scheme-number -> scheme-number\n\t    // multiplies a number times -1.\n\t    var negate = function(n) {\n\t\tif (typeof(n) === 'number') {\n\t\t    return -n;\n\t\t}\n\t\treturn n.negate();\n\t    };\n\t\n\t\n\t    // halve: scheme-number -> scheme-number\n\t    // Divide a number by 2.\n\t    var halve = function(n) {\n\t\treturn divide(n, 2);\n\t    };\n\t\n\t\n\t    // timesI: scheme-number scheme-number\n\t    // multiplies a number times i.\n\t    var timesI = function(x) {\n\t\treturn multiply(x, plusI);\n\t    };\n\t\n\t\n\t    // fastExpt: computes n^k by squaring.\n\t    // n^k = (n^2)^(k/2)\n\t    // Assumes k is non-negative integer.\n\t    var fastExpt = function(n, k) {\n\t\tvar acc = 1;\n\t\twhile (true) {\n\t\t    if (_integerIsZero(k)) {\n\t\t\treturn acc;\n\t\t    }\n\t\t    if (equals(modulo(k, 2), 0)) {\n\t\t\tn = multiply(n, n);\n\t\t\tk = divide(k, 2);\n\t\t    } else {\n\t\t\tacc = multiply(acc, n);\n\t\t\tk = subtract(k, 1);\n\t\t    }\n\t\t}\n\t    };\n\t\n\t\n\t\n\t    //////////////////////////////////////////////////////////////////////\n\t    //////////////////////////////////////////////////////////////////////\n\t    //////////////////////////////////////////////////////////////////////\n\t    //////////////////////////////////////////////////////////////////////\n\t    //////////////////////////////////////////////////////////////////////\n\t\n\t\n\t    // Integer operations\n\t    // Integers are either represented as fixnums or as BigIntegers.\n\t\n\t    // makeIntegerBinop: (fixnum fixnum -> X) (BigInteger BigInteger -> X) -> X\n\t    // Helper to collect the common logic for coersing integer fixnums or bignums to a\n\t    // common type before doing an operation.\n\t    var makeIntegerBinop = function(onFixnums, onBignums, options) {\n\t\toptions = options || {};\n\t\treturn (function(m, n) {\n\t\t    if (m instanceof Rational) {\n\t\t\tm = numerator(m);\n\t\t    } else if (m instanceof Complex) {\n\t\t\tm = realPart(m);\n\t\t    }\n\t\n\t\t    if (n instanceof Rational) {\n\t\t\tn = numerator(n);\n\t\t    }else if (n instanceof Complex) {\n\t\t\tn = realPart(n);\n\t\t    }\n\t\n\t\t    if (typeof(m) === 'number' && typeof(n) === 'number') {\n\t\t\tvar result = onFixnums(m, n);\n\t\t\tif (! isOverflow(result) ||\n\t\t\t    (options.ignoreOverflow)) {\n\t\t\t    return result;\n\t\t\t}\n\t\t    }\n\t\t    if (m instanceof FloatPoint || n instanceof FloatPoint) {\n\t\t\tif (options.doNotCoerseToFloating) {\n\t\t\t    return onFixnums(toFixnum(m), toFixnum(n));\n\t\t\t}\n\t\t\telse {\n\t\t\t    return FloatPoint.makeInstance(\n\t\t\t\tonFixnums(toFixnum(m), toFixnum(n)));\n\t\t\t}\n\t\t    }\n\t\t    if (typeof(m) === 'number') {\n\t\t\tm = makeBignum(m);\n\t\t    }\n\t\t    if (typeof(n) === 'number') {\n\t\t\tn = makeBignum(n);\n\t\t    }\n\t\t    return onBignums(m, n);\n\t\t});\n\t    };\n\t\n\t\n\t    var makeIntegerUnOp = function(onFixnums, onBignums, options) {\n\t\toptions = options || {};\n\t\treturn (function(m) {\n\t\t    if (m instanceof Rational) {\n\t\t\tm = numerator(m);\n\t\t    } else if (m instanceof Complex) {\n\t\t\tm = realPart(m);\n\t\t    }\n\t\n\t\t    if (typeof(m) === 'number') {\n\t\t\tvar result = onFixnums(m);\n\t\t\tif (! isOverflow(result) ||\n\t\t\t    (options.ignoreOverflow)) {\n\t\t\t    return result;\n\t\t\t}\n\t\t    }\n\t\t    if (m instanceof FloatPoint) {\n\t\t\treturn onFixnums(toFixnum(m));\n\t\t    }\n\t\t    if (typeof(m) === 'number') {\n\t\t\tm = makeBignum(m);\n\t\t    }\n\t\t    return onBignums(m);\n\t\t});\n\t    };\n\t\n\t\n\t\n\t    // _integerModulo: integer-scheme-number integer-scheme-number -> integer-scheme-number\n\t    var _integerModulo = makeIntegerBinop(\n\t\tfunction(m, n) {\n\t\t    return m % n;\n\t\t},\n\t\tfunction(m, n) {\n\t\t    return bnMod.call(m, n);\n\t\t});\n\t\n\t\n\t    // _integerGcd: integer-scheme-number integer-scheme-number -> integer-scheme-number\n\t    var _integerGcd = makeIntegerBinop(\n\t\tfunction(a, b) {\n\t\t    var t;\n\t\t    while (b !== 0) {\n\t\t\tt = a;\n\t\t\ta = b;\n\t\t\tb = t % b;\n\t\t    }\n\t\t    return a;\n\t\t},\n\t\tfunction(m, n) {\n\t\t    return bnGCD.call(m, n);\n\t\t});\n\t\n\t\n\t    // _integerIsZero: integer-scheme-number -> boolean\n\t    // Returns true if the number is zero.\n\t    var _integerIsZero = makeIntegerUnOp(\n\t\tfunction(n){\n\t\t    return n === 0;\n\t\t},\n\t\tfunction(n) {\n\t\t    return bnEquals.call(n, BigInteger.ZERO);\n\t\t}\n\t    );\n\t\n\t\n\t    // _integerIsOne: integer-scheme-number -> boolean\n\t    var _integerIsOne = makeIntegerUnOp(\n\t\tfunction(n) {\n\t\t    return n === 1;\n\t\t},\n\t\tfunction(n) {\n\t\t    return bnEquals.call(n, BigInteger.ONE);\n\t\t});\n\t    \n\t\n\t \n\t    // _integerIsNegativeOne: integer-scheme-number -> boolean\n\t    var _integerIsNegativeOne = makeIntegerUnOp(\n\t\tfunction(n) {\n\t\t    return n === -1;\n\t\t},\n\t\tfunction(n) {\n\t\t    return bnEquals.call(n, BigInteger.NEGATIVE_ONE);\n\t\t});\n\t    \n\t\n\t\n\t    // _integerAdd: integer-scheme-number integer-scheme-number -> integer-scheme-number\n\t    var _integerAdd = makeIntegerBinop(\n\t\tfunction(m, n) {\n\t\t    return m + n;\n\t\t},\n\t\tfunction(m, n) {\n\t\t    return bnAdd.call(m, n);\n\t\t});\n\t\n\t    // _integerSubtract: integer-scheme-number integer-scheme-number -> integer-scheme-number\n\t    var _integerSubtract = makeIntegerBinop(\n\t\tfunction(m, n) {\n\t\t    return m - n;\n\t\t},\n\t\tfunction(m, n) {\n\t\t    return bnSubtract.call(m, n);\n\t\t});\n\t\n\t    // _integerMultiply: integer-scheme-number integer-scheme-number -> integer-scheme-number\n\t    var _integerMultiply = makeIntegerBinop(\n\t\tfunction(m, n) {\n\t\t    return m * n;\n\t\t},\n\t\tfunction(m, n) {\n\t\t    return bnMultiply.call(m, n);\n\t\t});\n\t\n\t    //_integerQuotient: integer-scheme-number integer-scheme-number -> integer-scheme-number\n\t    var _integerQuotient = makeIntegerBinop(\n\t\tfunction(m, n) {\n\t\t    return ((m - (m % n))/ n);\n\t\t},\n\t\tfunction(m, n) {\n\t            return bnDivide.call(m, n);\n\t\t});\n\t\n\t    var _integerRemainder = makeIntegerBinop(\n\t\tfunction(m, n) {\n\t\t    return m % n;\n\t\t},\n\t\tfunction(m, n) {\n\t\t    return bnRemainder.call(m, n);\n\t\t});\n\t\n\t\n\t    // _integerDivideToFixnum: integer-scheme-number integer-scheme-number -> fixnum\n\t    var _integerDivideToFixnum = makeIntegerBinop(\n\t\tfunction(m, n) {\n\t\t    return m / n;\n\t\t},\n\t\tfunction(m, n) {\n\t\t    return toFixnum(m) / toFixnum(n);\n\t\t},\n\t\t{ignoreOverflow: true,\n\t\t doNotCoerseToFloating: true});\n\t\n\t\n\t    // _integerEquals: integer-scheme-number integer-scheme-number -> boolean\n\t    var _integerEquals = makeIntegerBinop(\n\t\tfunction(m, n) {\n\t\t    return m === n;\n\t\t},\n\t\tfunction(m, n) {\n\t\t    return bnEquals.call(m, n);\n\t\t},\n\t\t{doNotCoerseToFloating: true});\n\t\n\t    // _integerGreaterThan: integer-scheme-number integer-scheme-number -> boolean\n\t    var _integerGreaterThan = makeIntegerBinop(\n\t\tfunction(m, n) {\n\t\t    return m > n;\n\t\t},\n\t\tfunction(m, n) {\n\t\t    return bnCompareTo.call(m, n) > 0;\n\t\t},\n\t\t{doNotCoerseToFloating: true});\n\t\n\t    // _integerLessThan: integer-scheme-number integer-scheme-number -> boolean\n\t    var _integerLessThan = makeIntegerBinop(\n\t\tfunction(m, n) {\n\t\t    return m < n;\n\t\t},\n\t\tfunction(m, n) {\n\t\t    return bnCompareTo.call(m, n) < 0;\n\t\t},\n\t\t{doNotCoerseToFloating: true});\n\t\n\t    // _integerGreaterThanOrEqual: integer-scheme-number integer-scheme-number -> boolean\n\t    var _integerGreaterThanOrEqual = makeIntegerBinop(\n\t\tfunction(m, n) {\n\t\t    return m >= n;\n\t\t},\n\t\tfunction(m, n) {\n\t\t    return bnCompareTo.call(m, n) >= 0;\n\t\t},\n\t\t{doNotCoerseToFloating: true});\n\t\n\t    // _integerLessThanOrEqual: integer-scheme-number integer-scheme-number -> boolean\n\t    var _integerLessThanOrEqual = makeIntegerBinop(\n\t\tfunction(m, n) {\n\t\t    return m <= n;\n\t\t},\n\t\tfunction(m, n) {\n\t\t    return bnCompareTo.call(m, n) <= 0;\n\t\t},\n\t\t{doNotCoerseToFloating: true});\n\t\n\t\n\t\n\t    //////////////////////////////////////////////////////////////////////\n\t    // The boxed number types are expected to implement the following\n\t    // interface.\n\t    //\n\t    // toString: -> string\n\t\n\t    // level: number\n\t\n\t    // liftTo: scheme-number -> scheme-number\n\t\n\t    // isFinite: -> boolean\n\t\n\t    // isInteger: -> boolean\n\t    // Produce true if this number can be coersed into an integer.\n\t\n\t    // isRational: -> boolean\n\t    // Produce true if the number is rational.\n\t\n\t    // isReal: -> boolean\n\t    // Produce true if the number is real.\n\t\n\t    // isExact: -> boolean\n\t    // Produce true if the number is exact\n\t\n\t    // toExact: -> scheme-number\n\t    // Produce an exact number.\n\t\n\t    // toFixnum: -> javascript-number\n\t    // Produce a javascript number.\n\t\n\t    // greaterThan: scheme-number -> boolean\n\t    // Compare against instance of the same type.\n\t\n\t    // greaterThanOrEqual: scheme-number -> boolean\n\t    // Compare against instance of the same type.\n\t\n\t    // lessThan: scheme-number -> boolean\n\t    // Compare against instance of the same type.\n\t\n\t    // lessThanOrEqual: scheme-number -> boolean\n\t    // Compare against instance of the same type.\n\t\n\t    // add: scheme-number -> scheme-number\n\t    // Add with an instance of the same type.\n\t\n\t    // subtract: scheme-number -> scheme-number\n\t    // Subtract with an instance of the same type.\n\t\n\t    // multiply: scheme-number -> scheme-number\n\t    // Multiply with an instance of the same type.\n\t\n\t    // divide: scheme-number -> scheme-number\n\t    // Divide with an instance of the same type.\n\t\n\t    // numerator: -> scheme-number\n\t    // Return the numerator.\n\t\n\t    // denominator: -> scheme-number\n\t    // Return the denominator.\n\t\n\t    // integerSqrt: -> scheme-number\n\t    // Produce the integer square root.\n\t\n\t    // sqrt: -> scheme-number\n\t    // Produce the square root.\n\t\n\t    // abs: -> scheme-number\n\t    // Produce the absolute value.\n\t\n\t    // floor: -> scheme-number\n\t    // Produce the floor.\n\t\n\t    // ceiling: -> scheme-number\n\t    // Produce the ceiling.\n\t\n\t    // conjugate: -> scheme-number\n\t    // Produce the conjugate.\n\t\n\t    // magnitude: -> scheme-number\n\t    // Produce the magnitude.\n\t\n\t    // log: -> scheme-number\n\t    // Produce the log.\n\t\n\t    // angle: -> scheme-number\n\t    // Produce the angle.\n\t\n\t    // atan: -> scheme-number\n\t    // Produce the arc tangent.\n\t\n\t    // cos: -> scheme-number\n\t    // Produce the cosine.\n\t\n\t    // sin: -> scheme-number\n\t    // Produce the sine.\n\t\n\t    // expt: scheme-number -> scheme-number\n\t    // Produce the power to the input.\n\t\n\t    // exp: -> scheme-number\n\t    // Produce e raised to the given power.\n\t\n\t    // acos: -> scheme-number\n\t    // Produce the arc cosine.\n\t\n\t    // asin: -> scheme-number\n\t    // Produce the arc sine.\n\t\n\t    // imaginaryPart: -> scheme-number\n\t    // Produce the imaginary part\n\t\n\t    // realPart: -> scheme-number\n\t    // Produce the real part.\n\t\n\t    // round: -> scheme-number\n\t    // Round to the nearest integer.\n\t\n\t    // equals: scheme-number -> boolean\n\t    // Produce true if the given number of the same type is equal.\n\t\n\t\n\t\n\t    //////////////////////////////////////////////////////////////////////\n\t\n\t    // Rationals\n\t\n\t\n\t    var Rational = function(n, d) {\n\t\tthis.n = n;\n\t\tthis.d = d;\n\t    };\n\t\n\t\n\t    Rational.prototype.toString = function() {\n\t\tif (_integerIsOne(this.d)) {\n\t\t    return this.n.toString() + \"\";\n\t\t} else {\n\t\t    return this.n.toString() + \"/\" + this.d.toString();\n\t\t}\n\t    };\n\t\n\t\n\t    Rational.prototype.level = 1;\n\t\n\t\n\t    Rational.prototype.liftTo = function(target) {\n\t\tif (target.level === 2)\n\t\t    return new FloatPoint(\n\t\t\t_integerDivideToFixnum(this.n, this.d));\n\t\tif (target.level === 3)\n\t\t    return new Complex(this, 0);\n\t\treturn throwRuntimeError(\"invalid level of Number\", this, target);\n\t    };\n\t\n\t    Rational.prototype.isFinite = function() {\n\t\treturn true;\n\t    };\n\t\n\t    Rational.prototype.equals = function(other) {\n\t\treturn (other instanceof Rational &&\n\t\t\t_integerEquals(this.n, other.n) &&\n\t\t\t_integerEquals(this.d, other.d));\n\t    };\n\t\n\t\n\t\n\t    Rational.prototype.isInteger = function() {\n\t\treturn _integerIsOne(this.d);\n\t    };\n\t\n\t    Rational.prototype.isRational = function() {\n\t        return true;\n\t    };\n\t\n\t    Rational.prototype.isReal = function() {\n\t\treturn true;\n\t    };\n\t\n\t\n\t    Rational.prototype.add = function(other) {\n\t\treturn Rational.makeInstance(_integerAdd(_integerMultiply(this.n, other.d),\n\t\t\t\t\t\t\t _integerMultiply(this.d, other.n)),\n\t\t\t\t\t     _integerMultiply(this.d, other.d));\n\t    };\n\t\n\t    Rational.prototype.subtract = function(other) {\n\t\treturn Rational.makeInstance(_integerSubtract(_integerMultiply(this.n, other.d),\n\t\t\t\t\t\t\t      _integerMultiply(this.d, other.n)),\n\t\t\t\t\t     _integerMultiply(this.d, other.d));\n\t    };\n\t\n\t    Rational.prototype.negate = function() { \n\t\treturn Rational.makeInstance(-this.n, this.d) \n\t    };\n\t\n\t    Rational.prototype.multiply = function(other) {\n\t\treturn Rational.makeInstance(_integerMultiply(this.n, other.n),\n\t\t\t\t\t     _integerMultiply(this.d, other.d));\n\t    };\n\t\n\t    Rational.prototype.divide = function(other) {\n\t\tif (_integerIsZero(this.d) || _integerIsZero(other.n)) {\n\t\t    throwRuntimeError(\"/: division by zero\", this, other);\n\t\t}\n\t\treturn Rational.makeInstance(_integerMultiply(this.n, other.d),\n\t\t\t\t\t     _integerMultiply(this.d, other.n));\n\t    };\n\t\n\t\n\t    Rational.prototype.toExact = function() {\n\t\treturn this;\n\t    };\n\t\n\t    Rational.prototype.toInexact = function() {\n\t\treturn FloatPoint.makeInstance(this.toFixnum());\n\t    };\n\t\n\t\n\t    Rational.prototype.isExact = function() {\n\t        return true;\n\t    };\n\t\n\t    Rational.prototype.isInexact = function() {\n\t        return false;\n\t    };\n\t\n\t\n\t    Rational.prototype.toFixnum = function() {\n\t\treturn _integerDivideToFixnum(this.n, this.d);\n\t    };\n\t\n\t    Rational.prototype.numerator = function() {\n\t\treturn this.n;\n\t    };\n\t\n\t    Rational.prototype.denominator = function() {\n\t\treturn this.d;\n\t    };\n\t\n\t    Rational.prototype.greaterThan = function(other) {\n\t\treturn _integerGreaterThan(_integerMultiply(this.n, other.d),\n\t\t\t\t\t   _integerMultiply(this.d, other.n));\n\t    };\n\t\n\t    Rational.prototype.greaterThanOrEqual = function(other) {\n\t\treturn _integerGreaterThanOrEqual(_integerMultiply(this.n, other.d),\n\t\t\t\t\t\t  _integerMultiply(this.d, other.n));\n\t    };\n\t\n\t    Rational.prototype.lessThan = function(other) {\n\t\treturn _integerLessThan(_integerMultiply(this.n, other.d),\n\t\t\t\t\t_integerMultiply(this.d, other.n));\n\t    };\n\t\n\t    Rational.prototype.lessThanOrEqual = function(other) {\n\t\treturn _integerLessThanOrEqual(_integerMultiply(this.n, other.d),\n\t\t\t\t\t       _integerMultiply(this.d, other.n));\n\t    };\n\t\n\t    Rational.prototype.integerSqrt = function() {\n\t\tvar result = sqrt(this);\n\t\tif (isRational(result)) {\n\t\t    return toExact(floor(result));\n\t\t} else if (isReal(result)) {\n\t\t    return toExact(floor(result));\n\t\t} else {\n\t\t    return Complex.makeInstance(toExact(floor(realPart(result))),\n\t\t\t\t\t\ttoExact(floor(imaginaryPart(result))));\n\t\t}\n\t    };\n\t\n\t\n\t    Rational.prototype.sqrt = function() {\n\t\tif (_integerGreaterThanOrEqual(this.n,  0)) {\n\t\t    var newN = sqrt(this.n);\n\t\t    var newD = sqrt(this.d);\n\t\t    if (equals(floor(newN), newN) &&\n\t\t\tequals(floor(newD), newD)) {\n\t\t\treturn Rational.makeInstance(newN, newD);\n\t\t    } else {\n\t\t\treturn FloatPoint.makeInstance(_integerDivideToFixnum(newN, newD));\n\t\t    }\n\t\t} else {\n\t\t    var newN = sqrt(negate(this.n));\n\t\t    var newD = sqrt(this.d);\n\t\t    if (equals(floor(newN), newN) &&\n\t\t\tequals(floor(newD), newD)) {\n\t\t\treturn Complex.makeInstance(\n\t\t\t    0,\n\t\t\t    Rational.makeInstance(newN, newD));\n\t\t    } else {\n\t\t\treturn Complex.makeInstance(\n\t\t\t    0,\n\t\t\t    FloatPoint.makeInstance(_integerDivideToFixnum(newN, newD)));\n\t\t    }\n\t\t}\n\t    };\n\t\n\t    Rational.prototype.abs = function() {\n\t\treturn Rational.makeInstance(abs(this.n),\n\t\t\t\t\t     this.d);\n\t    };\n\t\n\t\n\t    Rational.prototype.floor = function() {\n\t\tvar quotient = _integerQuotient(this.n, this.d);\n\t\tif (_integerLessThan(this.n, 0)) {\n\t\t    return subtract(quotient, 1);\n\t\t} else {\n\t\t    return quotient;\n\t\t}\n\t    };\n\t\n\t\n\t    Rational.prototype.ceiling = function() {\n\t\tvar quotient = _integerQuotient(this.n, this.d);\n\t\tif (_integerLessThan(this.n, 0)) {\n\t\t    return quotient;\n\t\t} else {\n\t\t    return add(quotient, 1);\n\t\t}\n\t    };\n\t\n\t    Rational.prototype.conjugate = function() {\n\t\treturn this;\n\t    };\n\t\n\t    Rational.prototype.magnitude = Rational.prototype.abs;\n\t\n\t    Rational.prototype.log = function(){\n\t\treturn FloatPoint.makeInstance(Math.log(this.n / this.d));\n\t    };\n\t\n\t    Rational.prototype.angle = function(){\n\t\tif (_integerIsZero(this.n))\n\t\t    return 0;\n\t\tif (_integerGreaterThan(this.n, 0))\n\t\t    return 0;\n\t\telse\n\t\t    return FloatPoint.pi;\n\t    };\n\t\n\t    Rational.prototype.tan = function(){\n\t\treturn FloatPoint.makeInstance(Math.tan(_integerDivideToFixnum(this.n, this.d)));\n\t    };\n\t\n\t    Rational.prototype.atan = function(){\n\t\treturn FloatPoint.makeInstance(Math.atan(_integerDivideToFixnum(this.n, this.d)));\n\t    };\n\t\n\t    Rational.prototype.cos = function(){\n\t\treturn FloatPoint.makeInstance(Math.cos(_integerDivideToFixnum(this.n, this.d)));\n\t    };\n\t\n\t    Rational.prototype.sin = function(){\n\t\treturn FloatPoint.makeInstance(Math.sin(_integerDivideToFixnum(this.n, this.d)));\n\t    };\n\t\n\t    Rational.prototype.expt = function(a){\n\t\tif (isExactInteger(a) && greaterThanOrEqual(a, 0)) {\n\t\t    return fastExpt(this, a);\n\t\t}\n\t\treturn FloatPoint.makeInstance(Math.pow(_integerDivideToFixnum(this.n, this.d),\n\t\t\t\t\t\t\t_integerDivideToFixnum(a.n, a.d)));\n\t    };\n\t\n\t    Rational.prototype.exp = function(){\n\t\treturn FloatPoint.makeInstance(Math.exp(_integerDivideToFixnum(this.n, this.d)));\n\t    };\n\t\n\t    Rational.prototype.acos = function(){\n\t\treturn FloatPoint.makeInstance(Math.acos(_integerDivideToFixnum(this.n, this.d)));\n\t    };\n\t\n\t    Rational.prototype.asin = function(){\n\t\treturn FloatPoint.makeInstance(Math.asin(_integerDivideToFixnum(this.n, this.d)));\n\t    };\n\t\n\t    Rational.prototype.imaginaryPart = function(){\n\t\treturn 0;\n\t    };\n\t\n\t    Rational.prototype.realPart = function(){\n\t\treturn this;\n\t    };\n\t\n\t\n\t   Rational.prototype.round = function() {\n\t     var halfintp = equals(this.d, 2);\n\t     var negativep = _integerLessThan(this.n, 0);\n\t     var n = this.n;\n\t     if (negativep) {\n\t       n = negate(n);\n\t     }\n\t     var quo = _integerQuotient(n, this.d);\n\t     if (halfintp) {\n\t       // rounding half to away from 0\n\t       // uncomment following if rounding half to even\n\t       // if (_integerIsOne(_integerModulo(quo, 2)))\n\t       quo = add(quo, 1);\n\t     } else {\n\t       var rem = _integerRemainder(n, this.d);\n\t       if (greaterThan(multiply(rem, 2), this.d)) {\n\t         quo = add(quo, 1);\n\t       }\n\t     }\n\t     if (negativep) {\n\t       quo = negate(quo);\n\t     }\n\t     return quo;\n\t   };\n\t\n\t    Rational.makeInstance = function(n, d) {\n\t\tif (n === undefined)\n\t\t    throwRuntimeError(\"n undefined\", n, d);\n\t\n\t\tif (d === undefined) { d = 1; }\n\t\n\t\tif (_integerIsZero(d)) {\n\t\t    throwRuntimeError(\"division by zero: \"+n+\"/\"+d);\n\t\t}\n\t\n\t  if (_integerLessThan(d, 0)) {\n\t\t    n = negate(n);\n\t\t    d = negate(d);\n\t\t}\n\t\n\t\tvar divisor = _integerGcd(abs(n), abs(d));\n\t\tn = _integerQuotient(n, divisor);\n\t\td = _integerQuotient(d, divisor);\n\t\n\t\t// Optimization: if we can get around construction the rational\n\t\t// in favor of just returning n, do it:\n\t\tif (_integerIsOne(d) || _integerIsZero(n)) {\n\t\t    return n;\n\t\t}\n\t\n\t\treturn new Rational(n, d);\n\t    };\n\t\n\t\n\t\n\t    // Floating Point numbers\n\t    var FloatPoint = function(n) {\n\t\tthis.n = n;\n\t    };\n\t    FloatPoint = FloatPoint;\n\t\n\t\n\t    var NaN = new FloatPoint(Number.NaN);\n\t    var inf = new FloatPoint(Number.POSITIVE_INFINITY);\n\t    var neginf = new FloatPoint(Number.NEGATIVE_INFINITY);\n\t\n\t    // We use these two constants to represent the floating-point coersion\n\t    // of bignums that can't be represented with fidelity.\n\t    var TOO_POSITIVE_TO_REPRESENT = new FloatPoint(Number.POSITIVE_INFINITY);\n\t    var TOO_NEGATIVE_TO_REPRESENT = new FloatPoint(Number.NEGATIVE_INFINITY);\n\t\n\t    // Negative zero is a distinguished value representing -0.0.\n\t    // There should only be one instance for -0.0.\n\t    var NEGATIVE_ZERO = new FloatPoint(-0.0);\n\t    var INEXACT_ZERO = new FloatPoint(0.0);\n\t\n\t    FloatPoint.pi = new FloatPoint(Math.PI);\n\t    FloatPoint.e = new FloatPoint(Math.E);\n\t    FloatPoint.nan = NaN;\n\t    FloatPoint.inf = inf;\n\t    FloatPoint.neginf = neginf;\n\t\n\t    FloatPoint.makeInstance = function(n) {\n\t\tif (isNaN(n)) {\n\t\t    return FloatPoint.nan;\n\t\t} else if (n === Number.POSITIVE_INFINITY) {\n\t\t    return FloatPoint.inf;\n\t\t} else if (n === Number.NEGATIVE_INFINITY) {\n\t\t    return FloatPoint.neginf;\n\t\t} else if (n === 0) {\n\t\t    if ((1/n) === -Infinity) {\n\t\t\treturn NEGATIVE_ZERO;\n\t\t    } else {\n\t\t\treturn INEXACT_ZERO;\n\t\t    }\n\t\t}\n\t\treturn new FloatPoint(n);\n\t    };\n\t\n\t\n\t    FloatPoint.prototype.isExact = function() {\n\t\treturn false;\n\t    };\n\t\n\t    FloatPoint.prototype.isInexact = function() {\n\t\treturn true;\n\t    };\n\t\n\t\n\t    FloatPoint.prototype.isFinite = function() {\n\t\treturn (isFinite(this.n) ||\n\t\t\tthis === TOO_POSITIVE_TO_REPRESENT ||\n\t\t\tthis === TOO_NEGATIVE_TO_REPRESENT);\n\t    };\n\t\n\t\n\t    FloatPoint.prototype.toExact = function() {\n\t\t// The precision of ieee is about 16 decimal digits, which we use here.\n\t\tif (! isFinite(this.n) || isNaN(this.n)) {\n\t\t    throwRuntimeError(\"toExact: no exact representation for \" + this, this);\n\t\t}\n\t\n\t\tvar stringRep = this.n.toString();\n\t\tvar match = stringRep.match(/^(.*)\\.(.*)$/);\n\t\tif (match) {\n\t\t    var intPart = parseInt(match[1]);\n\t\t    var fracPart = parseInt(match[2]);\n\t\t    var tenToDecimalPlaces = Math.pow(10, match[2].length);\n\t\t    return Rational.makeInstance(Math.round(this.n * tenToDecimalPlaces),\n\t\t\t\t\t\t tenToDecimalPlaces);\n\t\t}\n\t\telse {\n\t\t    return this.n;\n\t\t}\n\t    };\n\t\n\t    FloatPoint.prototype.toInexact = function() {\n\t\treturn this;\n\t    };\n\t\n\t    FloatPoint.prototype.isInexact = function() {\n\t\treturn true;\n\t    };\n\t\n\t\n\t    FloatPoint.prototype.level = 2;\n\t\n\t\n\t    FloatPoint.prototype.liftTo = function(target) {\n\t\tif (target.level === 3)\n\t\t    return new Complex(this, 0);\n\t\treturn throwRuntimeError(\"invalid level of Number\", this, target);\n\t    };\n\t\n\t    FloatPoint.prototype.toString = function() {\n\t\tif (isNaN(this.n))\n\t\t    return \"+nan.0\";\n\t\tif (this.n === Number.POSITIVE_INFINITY)\n\t\t    return \"+inf.0\";\n\t\tif (this.n === Number.NEGATIVE_INFINITY)\n\t\t    return \"-inf.0\";\n\t\tif (this === NEGATIVE_ZERO)\n\t\t    return \"-0.0\";\n\t\tvar partialResult = this.n.toString();\n\t\tif (! partialResult.match('\\\\.')) {\n\t\t    return partialResult + \".0\";\n\t\t} else {\n\t\t    return partialResult;\n\t\t}\n\t    };\n\t\n\t\n\t    FloatPoint.prototype.equals = function(other, aUnionFind) {\n\t\treturn ((other instanceof FloatPoint) &&\n\t\t\t((this.n === other.n)));\n\t    };\n\t\n\t\n\t\n\t    FloatPoint.prototype.isRational = function() {\n\t        return this.isFinite();\n\t    };\n\t\n\t    FloatPoint.prototype.isInteger = function() {\n\t\treturn this.isFinite() && this.n === Math.floor(this.n);\n\t    };\n\t\n\t    FloatPoint.prototype.isReal = function() {\n\t\treturn true;\n\t    };\n\t\n\t\n\t    // sign: Number -> {-1, 0, 1}\n\t    var sign = function(n) {\n\t\tif (lessThan(n, 0)) {\n\t\t    return -1;\n\t\t} else if (greaterThan(n, 0)) {\n\t\t    return 1;\n\t\t} else if (n === NEGATIVE_ZERO) {\n\t\t    return -1;\n\t\t} else {\n\t\t    return 0;\n\t\t}\n\t    };\n\t\n\t\n\t    FloatPoint.prototype.add = function(other) {\n\t\tif (this.isFinite() && other.isFinite()) {\n\t\t    return FloatPoint.makeInstance(this.n + other.n);\n\t\t} else {\n\t\t    if (isNaN(this.n) || isNaN(other.n)) {\n\t\t\treturn NaN;\n\t\t    } else if (this.isFinite() && ! other.isFinite()) {\n\t\t\treturn other;\n\t\t    } else if (!this.isFinite() && other.isFinite()) {\n\t\t\treturn this;\n\t\t    } else {\n\t\t\treturn ((sign(this) * sign(other) === 1) ?\n\t\t\t\tthis : NaN);\n\t\t    };\n\t\t}\n\t    };\n\t\n\t    FloatPoint.prototype.subtract = function(other) {\n\t\tif (this.isFinite() && other.isFinite()) {\n\t\t    return FloatPoint.makeInstance(this.n - other.n);\n\t\t} else if (isNaN(this.n) || isNaN(other.n)) {\n\t\t    return NaN;\n\t\t} else if (! this.isFinite() && ! other.isFinite()) {\n\t\t    if (sign(this) === sign(other)) {\n\t\t\treturn NaN;\n\t\t    } else {\n\t\t\treturn this;\n\t\t    }\n\t\t} else if (this.isFinite()) {\n\t\t    return multiply(other, -1);\n\t\t} else {  // other.isFinite()\n\t\t    return this;\n\t\t}\n\t    };\n\t\n\t\n\t    FloatPoint.prototype.negate = function() {\n\t\treturn FloatPoint.makeInstance(-this.n);\n\t    };\n\t\n\t    FloatPoint.prototype.multiply = function(other) {\n\t\treturn FloatPoint.makeInstance(this.n * other.n);\n\t    };\n\t\n\t    FloatPoint.prototype.divide = function(other) {\n\t        return FloatPoint.makeInstance(this.n / other.n);\n\t    };\n\t\n\t\n\t    FloatPoint.prototype.toFixnum = function() {\n\t\treturn this.n;\n\t    };\n\t\n\t    FloatPoint.prototype.numerator = function() {\n\t\tvar stringRep = this.n.toString();\n\t\tvar match = stringRep.match(/^(.*)\\.(.*)$/);\n\t\tif (match) {\n\t\t    var afterDecimal = parseInt(match[2]);\n\t\t    var factorToInt = Math.pow(10, match[2].length);\n\t\t    var extraFactor = _integerGcd(factorToInt, afterDecimal);\n\t\t    var multFactor = factorToInt / extraFactor;\n\t\t    return FloatPoint.makeInstance( Math.round(this.n * multFactor) );\n\t\t} else {\n\t\t    return this;\n\t\t}\n\t    };\n\t\n\t    FloatPoint.prototype.denominator = function() {\n\t\tvar stringRep = this.n.toString();\n\t\tvar match = stringRep.match(/^(.*)\\.(.*)$/);\n\t\tif (match) {\n\t\t    var afterDecimal = parseInt(match[2]);\n\t\t    var factorToInt = Math.pow(10, match[2].length);\n\t\t    var extraFactor = _integerGcd(factorToInt, afterDecimal);\n\t\t    return FloatPoint.makeInstance( Math.round(factorToInt/extraFactor) );\n\t\t} else {\n\t\t    return FloatPoint.makeInstance(1);\n\t\t}\n\t    };\n\t\n\t\n\t    FloatPoint.prototype.floor = function() {\n\t\treturn FloatPoint.makeInstance(Math.floor(this.n));\n\t    };\n\t\n\t    FloatPoint.prototype.ceiling = function() {\n\t\treturn FloatPoint.makeInstance(Math.ceil(this.n));\n\t    };\n\t\n\t\n\t    FloatPoint.prototype.greaterThan = function(other) {\n\t\treturn this.n > other.n;\n\t    };\n\t\n\t    FloatPoint.prototype.greaterThanOrEqual = function(other) {\n\t\treturn this.n >= other.n;\n\t    };\n\t\n\t    FloatPoint.prototype.lessThan = function(other) {\n\t\treturn this.n < other.n;\n\t    };\n\t\n\t    FloatPoint.prototype.lessThanOrEqual = function(other) {\n\t\treturn this.n <= other.n;\n\t    };\n\t\n\t\n\t    FloatPoint.prototype.integerSqrt = function() {\n\t\tif (this === NEGATIVE_ZERO) { return this; }\n\t\tif (isInteger(this)) {\n\t\t    if(this.n >= 0) {\n\t\t        return FloatPoint.makeInstance(Math.floor(Math.sqrt(this.n)));\n\t\t    } else {\n\t\t        return Complex.makeInstance(\n\t\t\t    INEXACT_ZERO,\n\t\t\t    FloatPoint.makeInstance(Math.floor(Math.sqrt(-this.n))));\n\t\t    }\n\t\t} else {\n\t\t    throwRuntimeError(\"integerSqrt: can only be applied to an integer\", this);\n\t\t}\n\t    };\n\t\n\t    FloatPoint.prototype.sqrt = function() {\n\t\tif (this.n < 0) {\n\t\t    var result = Complex.makeInstance(\n\t\t\t0,\n\t\t\tFloatPoint.makeInstance(Math.sqrt(-this.n)));\n\t\t    return result;\n\t\t} else {\n\t\t    return FloatPoint.makeInstance(Math.sqrt(this.n));\n\t\t}\n\t    };\n\t\n\t    FloatPoint.prototype.abs = function() {\n\t\treturn FloatPoint.makeInstance(Math.abs(this.n));\n\t    };\n\t\n\t\n\t\n\t    FloatPoint.prototype.log = function(){\n\t\tif (this.n < 0)\n\t\t    return (new Complex(this, 0)).log();\n\t\telse\n\t\t    return FloatPoint.makeInstance(Math.log(this.n));\n\t    };\n\t\n\t    FloatPoint.prototype.angle = function(){\n\t\tif (0 === this.n)\n\t\t    return 0;\n\t\tif (this.n > 0)\n\t\t    return 0;\n\t\telse\n\t\t    return FloatPoint.pi;\n\t    };\n\t\n\t    FloatPoint.prototype.tan = function(){\n\t\treturn FloatPoint.makeInstance(Math.tan(this.n));\n\t    };\n\t\n\t    FloatPoint.prototype.atan = function(){\n\t\treturn FloatPoint.makeInstance(Math.atan(this.n));\n\t    };\n\t\n\t    FloatPoint.prototype.cos = function(){\n\t\treturn FloatPoint.makeInstance(Math.cos(this.n));\n\t    };\n\t\n\t    FloatPoint.prototype.sin = function(){\n\t\treturn FloatPoint.makeInstance(Math.sin(this.n));\n\t    };\n\t\n\t    FloatPoint.prototype.expt = function(a){\n\t\tif (this.n === 1) {\n\t\t    if (a.isFinite()) {\n\t\t\treturn this;\n\t\t    } else if (isNaN(a.n)){\n\t\t\treturn this;\n\t\t    } else {\n\t\t\treturn this;\n\t\t    }\n\t\t} else {\n\t\t    return FloatPoint.makeInstance(Math.pow(this.n, a.n));\n\t\t}\n\t    };\n\t\n\t    FloatPoint.prototype.exp = function(){\n\t\treturn FloatPoint.makeInstance(Math.exp(this.n));\n\t    };\n\t\n\t    FloatPoint.prototype.acos = function(){\n\t\treturn FloatPoint.makeInstance(Math.acos(this.n));\n\t    };\n\t\n\t    FloatPoint.prototype.asin = function(){\n\t\treturn FloatPoint.makeInstance(Math.asin(this.n));\n\t    };\n\t\n\t    FloatPoint.prototype.imaginaryPart = function(){\n\t\treturn 0;\n\t    };\n\t\n\t    FloatPoint.prototype.realPart = function(){\n\t\treturn this;\n\t    };\n\t\n\t\n\t    FloatPoint.prototype.round = function(){\n\t\tif (isFinite(this.n)) {\n\t\t    if (this === NEGATIVE_ZERO) {\n\t\t\treturn this;\n\t\t    }\n\t\t    if (Math.abs(Math.floor(this.n) - this.n) === 0.5) {\n\t\t\tif (Math.floor(this.n) % 2 === 0)\n\t\t\t    return FloatPoint.makeInstance(Math.floor(this.n));\n\t\t\treturn FloatPoint.makeInstance(Math.ceil(this.n));\n\t\t    } else {\n\t\t\treturn FloatPoint.makeInstance(Math.round(this.n));\n\t\t    }\n\t\t} else {\n\t\t    return this;\n\t\t}\n\t    };\n\t\n\t\n\t    FloatPoint.prototype.conjugate = function() {\n\t\treturn this;\n\t    };\n\t\n\t    FloatPoint.prototype.magnitude = FloatPoint.prototype.abs;\n\t\n\t\n\t\n\t    //////////////////////////////////////////////////////////////////////\n\t    // Complex numbers\n\t    //////////////////////////////////////////////////////////////////////\n\t\n\t    var Complex = function(r, i){\n\t\tthis.r = r;\n\t\tthis.i = i;\n\t    };\n\t\n\t    // Constructs a complex number from two basic number r and i.  r and i can\n\t    // either be plt.type.Rational or plt.type.FloatPoint.\n\t    Complex.makeInstance = function(r, i){\n\t\tif (i === undefined) { i = 0; }\n\t\tif (isExact(i) && isInteger(i) && _integerIsZero(i)) {\n\t\t    return r;\n\t\t}\n\t\tif (isInexact(r) || isInexact(i)) {\n\t\t    r = toInexact(r);\n\t\t    i = toInexact(i);\n\t\t}\n\t\treturn new Complex(r, i);\n\t    };\n\t\n\t    Complex.prototype.toString = function() {\n\t\tvar realPart = this.r.toString(), imagPart = this.i.toString();\n\t\tif (imagPart[0] === '-' || imagPart[0] === '+') {\n\t\t    return realPart + imagPart + 'i';\n\t\t} else {\n\t\t    return realPart + \"+\" + imagPart + 'i';\n\t\t}\n\t    };\n\t\n\t\n\t    Complex.prototype.isFinite = function() {\n\t\treturn isSchemeNumberFinite(this.r) && isSchemeNumberFinite(this.i);\n\t    };\n\t\n\t\n\t    Complex.prototype.isRational = function() {\n\t\treturn isRational(this.r) && eqv(this.i, 0);\n\t    };\n\t\n\t    Complex.prototype.isInteger = function() {\n\t\treturn (isInteger(this.r) &&\n\t\t\teqv(this.i, 0));\n\t    };\n\t\n\t    Complex.prototype.toExact = function() {\n\t\treturn Complex.makeInstance( toExact(this.r), toExact(this.i) );\n\t    };\n\t\n\t    Complex.prototype.toInexact = function() {\n\t\treturn Complex.makeInstance(toInexact(this.r),\n\t\t\t\t\t    toInexact(this.i));\n\t    };\n\t\n\t\n\t    Complex.prototype.isExact = function() {\n\t        return isExact(this.r) && isExact(this.i);\n\t    };\n\t\n\t\n\t    Complex.prototype.isInexact = function() {\n\t\treturn isInexact(this.r) || isInexact(this.i);\n\t    };\n\t\n\t\n\t    Complex.prototype.level = 3;\n\t\n\t\n\t    Complex.prototype.liftTo = function(target){\n\t\tthrowRuntimeError(\"Don't know how to lift Complex number\", this, target);\n\t    };\n\t\n\t    Complex.prototype.equals = function(other) {\n\t\tvar result = ((other instanceof Complex) &&\n\t\t\t      (equals(this.r, other.r)) &&\n\t\t\t      (equals(this.i, other.i)));\n\t\treturn result;\n\t    };\n\t\n\t\n\t\n\t    Complex.prototype.greaterThan = function(other) {\n\t\tif (! this.isReal() || ! other.isReal()) {\n\t\t    throwRuntimeError(\">: expects argument of type real number\", this, other);\n\t\t}\n\t\treturn greaterThan(this.r, other.r);\n\t    };\n\t\n\t    Complex.prototype.greaterThanOrEqual = function(other) {\n\t\tif (! this.isReal() || ! other.isReal()) {\n\t\t    throwRuntimeError(\">=: expects argument of type real number\", this, other);\n\t\t}\n\t\treturn greaterThanOrEqual(this.r, other.r);\n\t    };\n\t\n\t    Complex.prototype.lessThan = function(other) {\n\t\tif (! this.isReal() || ! other.isReal()) {\n\t\t    throwRuntimeError(\"<: expects argument of type real number\", this, other);\n\t\t}\n\t\treturn lessThan(this.r, other.r);\n\t    };\n\t\n\t    Complex.prototype.lessThanOrEqual = function(other) {\n\t\tif (! this.isReal() || ! other.isReal()) {\n\t\t    throwRuntimeError(\"<=: expects argument of type real number\", this, other);\n\t\t}\n\t\treturn lessThanOrEqual(this.r, other.r);\n\t    };\n\t\n\t\n\t    Complex.prototype.abs = function(){\n\t\tif (!equals(this.i, 0).valueOf())\n\t\t    throwRuntimeError(\"abs: expects argument of type real number\", this);\n\t\treturn abs(this.r);\n\t    };\n\t\n\t    Complex.prototype.toFixnum = function(){\n\t\tif (!equals(this.i, 0).valueOf())\n\t\t    throwRuntimeError(\"toFixnum: expects argument of type real number\", this);\n\t\treturn toFixnum(this.r);\n\t    };\n\t\n\t    Complex.prototype.numerator = function() {\n\t\tif (!this.isReal())\n\t\t    throwRuntimeError(\"numerator: can only be applied to real number\", this);\n\t\treturn numerator(this.n);\n\t    };\n\t\n\t\n\t    Complex.prototype.denominator = function() {\n\t\tif (!this.isReal())\n\t\t    throwRuntimeError(\"floor: can only be applied to real number\", this);\n\t\treturn denominator(this.n);\n\t    };\n\t\n\t    Complex.prototype.add = function(other){\n\t\treturn Complex.makeInstance(\n\t\t    add(this.r, other.r),\n\t\t    add(this.i, other.i));\n\t    };\n\t\n\t    Complex.prototype.subtract = function(other){\n\t\treturn Complex.makeInstance(\n\t\t    subtract(this.r, other.r),\n\t\t    subtract(this.i, other.i));\n\t    };\n\t\n\t    Complex.prototype.negate = function() {\n\t\treturn Complex.makeInstance(negate(this.r),\n\t\t\t\t\t    negate(this.i));\n\t    };\n\t\n\t\n\t    Complex.prototype.multiply = function(other){\n\t\t// If the other value is real, just do primitive division\n\t\tif (other.isReal()) {\n\t\t    return Complex.makeInstance(\n\t\t\tmultiply(this.r, other.r),\n\t\t\tmultiply(this.i, other.r));\n\t\t}\n\t\tvar r = subtract(\n\t\t    multiply(this.r, other.r),\n\t\t    multiply(this.i, other.i));\n\t\tvar i = add(\n\t\t    multiply(this.r, other.i),\n\t\t    multiply(this.i, other.r));\n\t\treturn Complex.makeInstance(r, i);\n\t    };\n\t\n\t\n\t\n\t\n\t\n\t    Complex.prototype.divide = function(other){\n\t\tvar a, b, c, d, r, x, y;\n\t\t// If the other value is real, just do primitive division\n\t\tif (other.isReal()) {\n\t\t    return Complex.makeInstance(\n\t\t\tdivide(this.r, other.r),\n\t\t\tdivide(this.i, other.r));\n\t\t}\n\t\n\t\tif (this.isInexact() || other.isInexact()) {\n\t\t    // http://portal.acm.org/citation.cfm?id=1039814\n\t\t    // We currently use Smith's method, though we should\n\t\t    // probably switch over to Priest's method.\n\t\t    a = this.r;\n\t\t    b = this.i;\n\t\t    c = other.r;\n\t\t    d = other.i;\n\t\t    if (lessThanOrEqual(abs(d), abs(c))) {\n\t\t\tr = divide(d, c);\n\t\t\tx = divide(add(a, multiply(b, r)),\n\t\t\t\t   add(c, multiply(d, r)));\n\t\t\ty = divide(subtract(b, multiply(a, r)),\n\t\t\t\t   add(c, multiply(d, r)));\n\t\t    } else {\n\t\t\tr = divide(c, d);\n\t\t\tx = divide(add(multiply(a, r), b),\n\t\t\t\t   add(multiply(c, r), d));\n\t\t\ty = divide(subtract(multiply(b, r), a),\n\t\t\t\t   add(multiply(c, r), d));\n\t\t    }\n\t\t    return Complex.makeInstance(x, y);\n\t\t} else {\n\t\t    var con = conjugate(other);\n\t\t    var up = multiply(this, con);\n\t\n\t\t    // Down is guaranteed to be real by this point.\n\t\t    var down = realPart(multiply(other, con));\n\t\n\t\t    var result = Complex.makeInstance(\n\t\t\tdivide(realPart(up), down),\n\t\t\tdivide(imaginaryPart(up), down));\n\t\t    return result;\n\t\t}\n\t    };\n\t\n\t    Complex.prototype.conjugate = function(){\n\t\tvar result = Complex.makeInstance(\n\t\t    this.r,\n\t\t    subtract(0, this.i));\n\t\n\t\treturn result;\n\t    };\n\t\n\t    Complex.prototype.magnitude = function(){\n\t\tvar sum = add(\n\t\t    multiply(this.r, this.r),\n\t\t    multiply(this.i, this.i));\n\t\treturn sqrt(sum);\n\t    };\n\t\n\t    Complex.prototype.isReal = function(){\n\t\treturn eqv(this.i, 0);\n\t    };\n\t\n\t    Complex.prototype.integerSqrt = function() {\n\t\tif (isInteger(this)) {\n\t\t    return integerSqrt(this.r);\n\t\t} else {\n\t\t    throwRuntimeError(\"integerSqrt: can only be applied to an integer\", this);\n\t\t}\n\t    };\n\t\n\t    Complex.prototype.sqrt = function(){\n\t\tif (this.isReal())\n\t\t    return sqrt(this.r);\n\t\t// http://en.wikipedia.org/wiki/Square_root#Square_roots_of_negative_and_complex_numbers\n\t\tvar r_plus_x = add(this.magnitude(), this.r);\n\t\n\t\tvar r = sqrt(halve(r_plus_x));\n\t\n\t\tvar i = divide(this.i, sqrt(multiply(r_plus_x, 2)));\n\t\n\t\n\t\treturn Complex.makeInstance(r, i);\n\t    };\n\t\n\t    Complex.prototype.log = function(){\n\t\tvar m = this.magnitude();\n\t\tvar theta = this.angle();\n\t\tvar result = add(\n\t\t    log(m),\n\t\t    timesI(theta));\n\t\treturn result;\n\t    };\n\t\n\t    Complex.prototype.angle = function(){\n\t\tif (this.isReal()) {\n\t\t    return angle(this.r);\n\t\t}\n\t\tif (equals(0, this.r)) {\n\t\t    var tmp = halve(FloatPoint.pi);\n\t\t    return greaterThan(this.i, 0) ?\n\t\t\ttmp : negate(tmp);\n\t\t} else {\n\t\t    var tmp = atan(divide(abs(this.i), abs(this.r)));\n\t\t    if (greaterThan(this.r, 0)) {\n\t\t\treturn greaterThan(this.i, 0) ?\n\t\t\t    tmp : negate(tmp);\n\t\t    } else {\n\t\t\treturn greaterThan(this.i, 0) ?\n\t\t\t    subtract(FloatPoint.pi, tmp) : subtract(tmp, FloatPoint.pi);\n\t\t    }\n\t\t}\n\t    };\n\t\n\t    var plusI = Complex.makeInstance(0, 1);\n\t    var minusI = Complex.makeInstance(0, -1);\n\t\n\t\n\t    Complex.prototype.tan = function() {\n\t\treturn divide(this.sin(), this.cos());\n\t    };\n\t\n\t    Complex.prototype.atan = function(){\n\t\tif (equals(this, plusI) ||\n\t\t    equals(this, minusI)) {\n\t\t    return neginf;\n\t\t}\n\t\treturn multiply(\n\t\t    plusI,\n\t\t    multiply(\n\t\t\tFloatPoint.makeInstance(0.5),\n\t\t\tlog(divide(\n\t\t\t    add(plusI, this),\n\t\t\t    add(\n\t\t\t\tplusI,\n\t\t\t\tsubtract(0, this))))));\n\t    };\n\t\n\t    Complex.prototype.cos = function(){\n\t\tif (this.isReal())\n\t\t    return cos(this.r);\n\t\tvar iz = timesI(this);\n\t\tvar iz_negate = negate(iz);\n\t\n\t\treturn halve(add(exp(iz), exp(iz_negate)));\n\t    };\n\t\n\t    Complex.prototype.sin = function(){\n\t\tif (this.isReal())\n\t\t    return sin(this.r);\n\t\tvar iz = timesI(this);\n\t\tvar iz_negate = negate(iz);\n\t\tvar z2 = Complex.makeInstance(0, 2);\n\t\tvar exp_negate = subtract(exp(iz), exp(iz_negate));\n\t\tvar result = divide(exp_negate, z2);\n\t\treturn result;\n\t    };\n\t\n\t\n\t    Complex.prototype.expt = function(y){\n\t\tif (isExactInteger(y) && greaterThanOrEqual(y, 0)) {\n\t\t    return fastExpt(this, y);\n\t\t}\n\t\tvar expo = multiply(y, this.log());\n\t\treturn exp(expo);\n\t    };\n\t\n\t    Complex.prototype.exp = function(){\n\t\tvar r = exp(this.r);\n\t\tvar cos_a = cos(this.i);\n\t\tvar sin_a = sin(this.i);\n\t\n\t\treturn multiply(\n\t\t    r,\n\t\t    add(cos_a, timesI(sin_a)));\n\t    };\n\t\n\t    Complex.prototype.acos = function(){\n\t\tif (this.isReal())\n\t\t    return acos(this.r);\n\t\tvar pi_half = halve(FloatPoint.pi);\n\t\tvar iz = timesI(this);\n\t\tvar root = sqrt(subtract(1, sqr(this)));\n\t\tvar l = timesI(log(add(iz, root)));\n\t\treturn add(pi_half, l);\n\t    };\n\t\n\t    Complex.prototype.asin = function(){\n\t\tif (this.isReal())\n\t\t    return asin(this.r);\n\t\n\t\tvar oneNegateThisSq =\n\t\t    subtract(1, sqr(this));\n\t\tvar sqrtOneNegateThisSq = sqrt(oneNegateThisSq);\n\t\treturn multiply(2, atan(divide(this,\n\t\t\t\t\t       add(1, sqrtOneNegateThisSq))));\n\t    };\n\t\n\t    Complex.prototype.ceiling = function(){\n\t\tif (!this.isReal())\n\t\t    throwRuntimeError(\"ceiling: can only be applied to real number\", this);\n\t\treturn ceiling(this.r);\n\t    };\n\t\n\t    Complex.prototype.floor = function(){\n\t\tif (!this.isReal())\n\t\t    throwRuntimeError(\"floor: can only be applied to real number\", this);\n\t\treturn floor(this.r);\n\t    };\n\t\n\t    Complex.prototype.imaginaryPart = function(){\n\t\treturn this.i;\n\t    };\n\t\n\t    Complex.prototype.realPart = function(){\n\t\treturn this.r;\n\t    };\n\t\n\t    Complex.prototype.round = function(){\n\t\tif (!this.isReal())\n\t\t    throwRuntimeError(\"round: can only be applied to real number\", this);\n\t\treturn round(this.r);\n\t    };\n\t\n\t\n\t\n\t    var hashModifiersRegexp = new RegExp(\"^(#[ei]#[bodx]|#[bodx]#[ei]|#[bodxei])(.*)$\")\n\t    function rationalRegexp(digits) { return new RegExp(\"^([+-]?[\"+digits+\"]+)/([\"+digits+\"]+)$\"); }\n\t    function matchComplexRegexp(radix, x) {\n\t\tvar sign = \"[+-]\";\n\t\tvar maybeSign = \"[+-]?\";\n\t\tvar digits = digitsForRadix(radix)\n\t\tvar expmark = \"[\"+expMarkForRadix(radix)+\"]\"\n\t\tvar digitSequence = \"[\"+digits+\"]+\"\n\t\n\t\tvar unsignedRational = digitSequence+\"/\"+digitSequence\n\t\tvar rational = maybeSign + unsignedRational\n\t\n\t\tvar noDecimal = digitSequence\n\t\tvar decimalNumOnRight = \"[\"+digits+\"]*\\\\.[\"+digits+\"]+\"\n\t\tvar decimalNumOnLeft = \"[\"+digits+\"]+\\\\.[\"+digits+\"]*\"\n\t\n\t\tvar unsignedDecimal = \"(?:\" + noDecimal + \"|\" + decimalNumOnRight + \"|\" + decimalNumOnLeft + \")\"\n\t\n\t\tvar special = \"(?:inf\\.0|nan\\.0|inf\\.f|nan\\.f)\"\n\t\n\t\tvar unsignedRealNoExp = \"(?:\" + unsignedDecimal + \"|\" + unsignedRational + \")\"\n\t\tvar unsignedReal = unsignedRealNoExp + \"(?:\" + expmark + maybeSign + digitSequence + \")?\"\n\t\tvar unsignedRealOrSpecial = \"(?:\" + unsignedReal + \"|\" + special + \")\"\n\t\tvar real = \"(?:\" + maybeSign + unsignedReal + \"|\" + sign + special + \")\"\n\t\n\t\tvar alt1 = new RegExp(\"^(\" + rational + \")\"\n\t                             + \"(\" + sign + unsignedRational + \"?)\"\n\t                             + \"i$\");\n\t\tvar alt2 = new RegExp(\"^(\" + real + \")?\"\n\t                             + \"(\" + sign + unsignedRealOrSpecial + \"?)\"\n\t                             + \"i$\");\n\t\tvar alt3 = new RegExp(\"^(\" + real + \")@(\" + real + \")$\");\n\t\n\t\tvar match1 = x.match(alt1)\n\t\tvar match2 = x.match(alt2)\n\t\tvar match3 = x.match(alt3)\n\t\n\t\treturn match1 ? match1 :\n\t\t       match2 ? match2 :\n\t\t       match3 ? match3 :\n\t\t     /* else */ false\n\t    }\n\t\n\t    function digitRegexp(digits) { return new RegExp(\"^[+-]?[\"+digits+\"]+$\"); }\n\t    /**\n\t    /* NB: !!!! flonum regexp only matches \"X.\", \".X\", or \"X.X\", NOT \"X\", this\n\t    /* must be separately checked with digitRegexp.\n\t    /* I know this seems dumb, but the alternative would be that this regexp\n\t    /* returns six matches, which also seems dumb.\n\t    /***/\n\t    function flonumRegexp(digits) {\n\t\tvar decimalNumOnRight = \"([\"+digits+\"]*)\\\\.([\"+digits+\"]+)\"\n\t\tvar decimalNumOnLeft = \"([\"+digits+\"]+)\\\\.([\"+digits+\"]*)\"\n\t\treturn new RegExp(\"^(?:([+-]?)(\" +\n\t                          decimalNumOnRight+\"|\"+decimalNumOnLeft +\n\t                          \"))$\");\n\t    }\n\t    function scientificPattern(digits, exp_mark) {\n\t\tvar noDecimal = \"[\"+digits+\"]+\"\n\t\tvar decimalNumOnRight = \"[\"+digits+\"]*\\\\.[\"+digits+\"]+\"\n\t\tvar decimalNumOnLeft = \"[\"+digits+\"]+\\\\.[\"+digits+\"]*\"\n\t\treturn new RegExp(\"^(?:([+-]?\" +\n\t\t\t\t  \"(?:\"+noDecimal+\"|\"+decimalNumOnRight+\"|\"+decimalNumOnLeft+\")\" +\n\t\t\t\t  \")[\"+exp_mark+\"]([+-]?[\"+digits+\"]+))$\");\n\t    }\n\t\n\t    function digitsForRadix(radix) {\n\t\treturn radix === 2  ? \"01\" :\n\t\t       radix === 8  ? \"0-7\" :\n\t\t       radix === 10 ? \"0-9\" :\n\t\t       radix === 16 ? \"0-9a-fA-F\" :\n\t\t       throwRuntimeError(\"digitsForRadix: invalid radix\", this, radix)\n\t    }\n\t\n\t    function expMarkForRadix(radix) {\n\t\treturn (radix === 2 || radix === 8 || radix === 10) ? \"defsl\" :\n\t\t       (radix === 16)                               ? \"sl\" :\n\t\t       throwRuntimeError(\"expMarkForRadix: invalid radix\", this, radix)\n\t    }\n\t\n\t    function Exactness(i) {\n\t      this.defaultp = function () { return i == 0; }\n\t      this.exactp = function () { return i == 1; }\n\t      this.inexactp = function () { return i == 2; }\n\t    }\n\t\n\t    Exactness.def = new Exactness(0);\n\t    Exactness.on = new Exactness(1);\n\t    Exactness.off = new Exactness(2);\n\t\n\t    Exactness.prototype.intAsExactp = function () { return this.defaultp() || this.exactp(); };\n\t    Exactness.prototype.floatAsInexactp = function () { return this.defaultp() || this.inexactp(); };\n\t\n\t\n\t    // fromString: string boolean -> (scheme-number | false)\n\t    var fromString = function(x, exactness) {\n\t\tvar radix = 10\n\t\tvar exactness = typeof exactness === 'undefined' ? Exactness.def :\n\t\t\t\texactness === true               ? Exactness.on :\n\t\t\t\texactness === false              ? Exactness.off :\n\t\t   /* else */  throwRuntimeError( \"exactness must be true or false\"\n\t                                        , this\n\t                                        , r) ;\n\t\n\t\tvar hMatch = x.toLowerCase().match(hashModifiersRegexp)\n\t\tif (hMatch) {\n\t\t    var modifierString = hMatch[1].toLowerCase();\n\t\n\t\t    var exactFlag = modifierString.match(new RegExp(\"(#[ei])\"))\n\t\t    var radixFlag = modifierString.match(new RegExp(\"(#[bodx])\"))\n\t\n\t\t    if (exactFlag) {\n\t\t\tvar f = exactFlag[1].charAt(1)\n\t\t\texactness = f === 'e' ? Exactness.on :\n\t\t\t\t    f === 'i' ? Exactness.off :\n\t\t\t\t // this case is unreachable\n\t\t\t\t throwRuntimeError(\"invalid exactness flag\", this, r)\n\t\t    }\n\t\t    if (radixFlag) {\n\t\t\tvar f = radixFlag[1].charAt(1)\n\t\t\tradix = f === 'b' ? 2 :\n\t            f === 'o' ? 8 :\n\t            f === 'd' ? 10 :\n\t            f === 'x' ? 16 :\n\t\t\t\t // this case is unreachable\n\t\t\t\tthrowRuntimeError(\"invalid radix flag\", this, r)\n\t\t    }\n\t\t}\n\t\n\t\tvar numberString = hMatch ? hMatch[2] : x\n\t\t// if the string begins with a hash modifier, then it must parse as a\n\t\t// number, an invalid parse is an error, not false. False is returned\n\t\t// when the item could potentially have been read as a symbol.\n\t\tvar mustBeANumberp = hMatch ? true : false\n\t\n\t\treturn fromStringRaw(numberString, radix, exactness, mustBeANumberp)\n\t    };\n\t\n\t    function fromStringRaw(x, radix, exactness, mustBeANumberp) {\n\t\tvar cMatch = matchComplexRegexp(radix, x);\n\t\tif (cMatch) {\n\t\t  return Complex.makeInstance( fromStringRawNoComplex( cMatch[1] || \"0\"\n\t\t\t\t\t\t\t\t     , radix\n\t\t\t\t\t\t\t\t     , exactness\n\t\t\t\t\t\t\t\t     )\n\t\t\t\t\t     , fromStringRawNoComplex( cMatch[2] === \"+\" ? \"1\"  :\n\t\t\t\t\t\t\t\t       cMatch[2] === \"-\" ? \"-1\" :\n\t\t\t\t\t\t\t\t       cMatch[2]\n\t\t\t\t\t\t\t\t     , radix\n\t\t\t\t\t\t\t\t     , exactness\n\t\t\t\t\t\t\t\t     ));\n\t\t}\n\t\n\t        return fromStringRawNoComplex(x, radix, exactness, mustBeANumberp)\n\t    }\n\t\n\t    function fromStringRawNoComplex(x, radix, exactness, mustBeANumberp) {\n\t\tvar aMatch = x.match(rationalRegexp(digitsForRadix(radix)));\n\t\tif (aMatch) {\n\t\t    return Rational.makeInstance( fromStringRawNoComplex( aMatch[1]\n\t                                                                , radix\n\t                                                                , exactness\n\t                                                                )\n\t                                        , fromStringRawNoComplex( aMatch[2]\n\t                                                                , radix\n\t                                                                , exactness\n\t                                                                ));\n\t\t}\n\t\n\t\t// Floating point tests\n\t\tif (x === '+nan.0' || x === '-nan.0')\n\t\t    return FloatPoint.nan;\n\t\tif (x === '+inf.0')\n\t\t    return FloatPoint.inf;\n\t\tif (x === '-inf.0')\n\t\t    return FloatPoint.neginf;\n\t\tif (x === \"-0.0\") {\n\t\t    return NEGATIVE_ZERO;\n\t\t}\n\t\n\t\tvar fMatch = x.match(flonumRegexp(digitsForRadix(radix)))\n\t\tif (fMatch) {\n\t\t    var integralPart = fMatch[3] !== undefined ? fMatch[3] : fMatch[5];\n\t\t    var fractionalPart = fMatch[4] !== undefined ? fMatch[4] : fMatch[6];\n\t\t    return parseFloat( fMatch[1]\n\t                             , integralPart\n\t                             , fractionalPart\n\t                             , radix\n\t                             , exactness\n\t                             )\n\t\t}\n\t\n\t\tvar sMatch = x.match(scientificPattern( digitsForRadix(radix)\n\t\t\t\t\t\t      , expMarkForRadix(radix)\n\t\t\t\t\t\t      ))\n\t\tif (sMatch) {\n\t\t    var coefficient = fromStringRawNoComplex(sMatch[1], radix, exactness)\n\t\t    var exponent = fromStringRawNoComplex(sMatch[2], radix, exactness)\n\t\t    return multiply(coefficient, expt(radix, exponent));\n\t\t}\n\t\n\t\t// Finally, integer tests.\n\t\tif (x.match(digitRegexp(digitsForRadix(radix)))) {\n\t\t    var n = parseInt(x, radix);\n\t\t    if (isOverflow(n)) {\n\t\t\treturn makeBignum(x);\n\t\t    } else if (exactness.intAsExactp()) {\n\t\t\treturn n;\n\t\t    } else {\n\t\t\treturn FloatPoint.makeInstance(n)\n\t\t    }\n\t\t} else if (mustBeANumberp) {\n\t\t    if(x.length===0) throwRuntimeError(\"no digits\");\n\t\t    throwRuntimeError(\"bad number: \" + x, this);\n\t\t} else {\n\t\t    return false;\n\t\t}\n\t    };\n\t\n\t    function parseFloat(sign, integralPart, fractionalPart, radix, exactness) {\n\t\tvar sign = (sign == \"-\" ? -1 : 1);\n\t\tvar integralPartValue = integralPart === \"\"  ? 0  :\n\t\t\t\t\texactness.intAsExactp() ? parseExactInt(integralPart, radix) :\n\t\t\t\t\t\t\t\t  parseInt(integralPart, radix)\n\t\n\t\tvar fractionalNumerator = fractionalPart === \"\" ? 0 :\n\t\t\t\t\t  exactness.intAsExactp() ? parseExactInt(fractionalPart, radix) :\n\t\t\t\t\t\t\t\t    parseInt(fractionalPart, radix)\n\t\t/* unfortunately, for these next two calculations, `expt` and `divide` */\n\t\t/* will promote to Bignum and Rational, respectively, but we only want */\n\t\t/* these if we're parsing in exact mode */\n\t\tvar fractionalDenominator = exactness.intAsExactp() ? expt(radix, fractionalPart.length) :\n\t\t\t\t\t\t\t\t      Math.pow(radix, fractionalPart.length)\n\t\tvar fractionalPartValue = fractionalPart === \"\" ? 0 :\n\t\t\t\t\t  exactness.intAsExactp() ? divide(fractionalNumerator, fractionalDenominator) :\n\t\t\t\t\t\t\t\t    fractionalNumerator / fractionalDenominator\n\t\n\t\tvar forceInexact = function(o) {\n\t\t    return typeof o === \"number\" ? FloatPoint.makeInstance(o) :\n\t\t\t\t\t\t   o.toInexact();\n\t\t}\n\t\n\t\treturn exactness.floatAsInexactp() ? forceInexact(multiply(sign, add( integralPartValue, fractionalPartValue))) :\n\t\t\t\t\t\t     multiply(sign, add(integralPartValue, fractionalPartValue));\n\t    }\n\t\n\t    function parseExactInt(str, radix) {\n\t\treturn fromStringRawNoComplex(str, radix, Exactness.on, true);\n\t    }\n\t\n\t    //////////////////////////////////////////////////////////////////////\n\t    //////////////////////////////////////////////////////////////////////\n\t    //////////////////////////////////////////////////////////////////////\n\t    //////////////////////////////////////////////////////////////////////\n\t    //////////////////////////////////////////////////////////////////////\n\t\n\t    // The code below comes from Tom Wu's BigInteger implementation:\n\t\n\t    // Copyright (c) 2005  Tom Wu\n\t    // All Rights Reserved.\n\t    // See \"LICENSE\" for details.\n\t\n\t    // Basic JavaScript BN library - subset useful for RSA encryption.\n\t\n\t    // Bits per digit\n\t    var dbits;\n\t\n\t    // JavaScript engine analysis\n\t    var canary = 0xdeadbeefcafe;\n\t    var j_lm = ((canary&0xffffff)==0xefcafe);\n\t\n\t    // (public) Constructor\n\t    function BigInteger(a,b,c) {\n\t\tif(a != null)\n\t\t    if(\"number\" == typeof a) this.fromNumber(a,b,c);\n\t\telse if(b == null && \"string\" != typeof a) this.fromString(a,256);\n\t\telse this.fromString(a,b);\n\t    }\n\t\n\t    // return new, unset BigInteger\n\t    function nbi() { return new BigInteger(null); }\n\t\n\t    // am: Compute w_j += (x*this_i), propagate carries,\n\t    // c is initial carry, returns final carry.\n\t    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n\t    // We need to select the fastest one that works in this environment.\n\t\n\t    // am1: use a single mult and divide to get the high bits,\n\t    // max digit bits should be 26 because\n\t    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n\t    function am1(i,x,w,j,c,n) {\n\t\twhile(--n >= 0) {\n\t\t    var v = x*this[i++]+w[j]+c;\n\t\t    c = Math.floor(v/0x4000000);\n\t\t    w[j++] = v&0x3ffffff;\n\t\t}\n\t\treturn c;\n\t    }\n\t    // am2 avoids a big mult-and-extract completely.\n\t    // Max digit bits should be <= 30 because we do bitwise ops\n\t    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n\t    function am2(i,x,w,j,c,n) {\n\t\tvar xl = x&0x7fff, xh = x>>15;\n\t\twhile(--n >= 0) {\n\t\t    var l = this[i]&0x7fff;\n\t\t    var h = this[i++]>>15;\n\t\t    var m = xh*l+h*xl;\n\t\t    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n\t\t    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n\t\t    w[j++] = l&0x3fffffff;\n\t\t}\n\t\treturn c;\n\t    }\n\t    // Alternately, set max digit bits to 28 since some\n\t    // browsers slow down when dealing with 32-bit numbers.\n\t    function am3(i,x,w,j,c,n) {\n\t\tvar xl = x&0x3fff, xh = x>>14;\n\t\twhile(--n >= 0) {\n\t\t    var l = this[i]&0x3fff;\n\t\t    var h = this[i++]>>14;\n\t\t    var m = xh*l+h*xl;\n\t\t    l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n\t\t    c = (l>>28)+(m>>14)+xh*h;\n\t\t    w[j++] = l&0xfffffff;\n\t\t}\n\t\treturn c;\n\t    }\n\t    if(j_lm && (typeof(navigator) !== 'undefined' && navigator.appName == \"Microsoft Internet Explorer\")) {\n\t\tBigInteger.prototype.am = am2;\n\t\tdbits = 30;\n\t    }\n\t    else if(j_lm && (typeof(navigator) !== 'undefined' && navigator.appName != \"Netscape\")) {\n\t\tBigInteger.prototype.am = am1;\n\t\tdbits = 26;\n\t    }\n\t    else { // Mozilla/Netscape seems to prefer am3\n\t\tBigInteger.prototype.am = am3;\n\t\tdbits = 28;\n\t    }\n\t\n\t    BigInteger.prototype.DB = dbits;\n\t    BigInteger.prototype.DM = ((1<<dbits)-1);\n\t    BigInteger.prototype.DV = (1<<dbits);\n\t\n\t    var BI_FP = 52;\n\t    BigInteger.prototype.FV = Math.pow(2,BI_FP);\n\t    BigInteger.prototype.F1 = BI_FP-dbits;\n\t    BigInteger.prototype.F2 = 2*dbits-BI_FP;\n\t\n\t    // Digit conversions\n\t    var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\t    var BI_RC = [];\n\t    var rr,vv;\n\t    rr = \"0\".charCodeAt(0);\n\t    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n\t    rr = \"a\".charCodeAt(0);\n\t    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t    rr = \"A\".charCodeAt(0);\n\t    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t\n\t    function int2char(n) { return BI_RM.charAt(n); }\n\t    function intAt(s,i) {\n\t\tvar c = BI_RC[s.charCodeAt(i)];\n\t\treturn (c==null)?-1:c;\n\t    }\n\t\n\t    // (protected) copy this to r\n\t    function bnpCopyTo(r) {\n\t\tfor(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n\t\tr.t = this.t;\n\t\tr.s = this.s;\n\t    }\n\t\n\t    // (protected) set from integer value x, -DV <= x < DV\n\t    function bnpFromInt(x) {\n\t\tthis.t = 1;\n\t\tthis.s = (x<0)?-1:0;\n\t\tif(x > 0) this[0] = x;\n\t\telse if(x < -1) this[0] = x+DV;\n\t\telse this.t = 0;\n\t    }\n\t\n\t    // return bigint initialized to value\n\t    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\t\n\t    // (protected) set from string and radix\n\t    function bnpFromString(s,b) {\n\t\tvar k;\n\t\tif(b == 16) k = 4;\n\t\telse if(b == 8) k = 3;\n\t\telse if(b == 256) k = 8; // byte array\n\t\telse if(b == 2) k = 1;\n\t\telse if(b == 32) k = 5;\n\t\telse if(b == 4) k = 2;\n\t\telse { this.fromRadix(s,b); return; }\n\t\tthis.t = 0;\n\t\tthis.s = 0;\n\t\tvar i = s.length, mi = false, sh = 0;\n\t\twhile(--i >= 0) {\n\t\t    var x = (k==8)?s[i]&0xff:intAt(s,i);\n\t\t    if(x < 0) {\n\t\t\tif(s.charAt(i) == \"-\") mi = true;\n\t\t\tcontinue;\n\t\t    }\n\t\t    mi = false;\n\t\t    if(sh == 0)\n\t\t\tthis[this.t++] = x;\n\t\t    else if(sh+k > this.DB) {\n\t\t\tthis[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n\t\t\tthis[this.t++] = (x>>(this.DB-sh));\n\t\t    }\n\t\t    else\n\t\t\tthis[this.t-1] |= x<<sh;\n\t\t    sh += k;\n\t\t    if(sh >= this.DB) sh -= this.DB;\n\t\t}\n\t\tif(k == 8 && (s[0]&0x80) != 0) {\n\t\t    this.s = -1;\n\t\t    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n\t\t}\n\t\tthis.clamp();\n\t\tif(mi) BigInteger.ZERO.subTo(this,this);\n\t    }\n\t\n\t    // (protected) clamp off excess high words\n\t    function bnpClamp() {\n\t\tvar c = this.s&this.DM;\n\t\twhile(this.t > 0 && this[this.t-1] == c) --this.t;\n\t    }\n\t\n\t    // (public) return string representation in given radix\n\t    function bnToString(b) {\n\t\tif(this.s < 0) return \"-\"+this.negate().toString(b);\n\t\tvar k;\n\t\tif(b == 16) k = 4;\n\t\telse if(b == 8) k = 3;\n\t\telse if(b == 2) k = 1;\n\t\telse if(b == 32) k = 5;\n\t\telse if(b == 4) k = 2;\n\t\telse return this.toRadix(b);\n\t\tvar km = (1<<k)-1, d, m = false, r = [], i = this.t;\n\t\tvar p = this.DB-(i*this.DB)%k;\n\t\tif(i-- > 0) {\n\t\t    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r.push(int2char(d)); }\n\t\t    while(i >= 0) {\n\t\t\tif(p < k) {\n\t\t\t    d = (this[i]&((1<<p)-1))<<(k-p);\n\t\t\t    d |= this[--i]>>(p+=this.DB-k);\n\t\t\t}\n\t\t\telse {\n\t\t\t    d = (this[i]>>(p-=k))&km;\n\t\t\t    if(p <= 0) { p += this.DB; --i; }\n\t\t\t}\n\t\t\tif(d > 0) m = true;\n\t\t\tif(m) r.push(int2char(d));\n\t\t    }\n\t\t}\n\t\treturn m?r.join(\"\"):\"0\";\n\t    }\n\t\n\t    // (public) -this\n\t    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\t\n\t    // (public) |this|\n\t    function bnAbs() { return (this.s<0)?this.negate():this; }\n\t\n\t    // (public) return + if this > a, - if this < a, 0 if equal\n\t    function bnCompareTo(a) {\n\t\tvar r = this.s-a.s;\n\t\tif(r != 0) return r;\n\t\tvar i = this.t;\n\t\tif ( this.s < 0 ) {\n\t\t\tr = a.t - i;\n\t\t}\n\t\telse {\n\t\t\tr = i - a.t;\n\t\t}\n\t\tif(r != 0) return r;\n\t\twhile(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n\t\treturn 0;\n\t    }\n\t\n\t    // returns bit length of the integer x\n\t    function nbits(x) {\n\t\tvar r = 1, t;\n\t\tif((t=x>>>16) != 0) { x = t; r += 16; }\n\t\tif((t=x>>8) != 0) { x = t; r += 8; }\n\t\tif((t=x>>4) != 0) { x = t; r += 4; }\n\t\tif((t=x>>2) != 0) { x = t; r += 2; }\n\t\tif((t=x>>1) != 0) { x = t; r += 1; }\n\t\treturn r;\n\t    }\n\t\n\t    // (public) return the number of bits in \"this\"\n\t    function bnBitLength() {\n\t\tif(this.t <= 0) return 0;\n\t\treturn this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n\t    }\n\t\n\t    // (protected) r = this << n*DB\n\t    function bnpDLShiftTo(n,r) {\n\t\tvar i;\n\t\tfor(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n\t\tfor(i = n-1; i >= 0; --i) r[i] = 0;\n\t\tr.t = this.t+n;\n\t\tr.s = this.s;\n\t    }\n\t\n\t    // (protected) r = this >> n*DB\n\t    function bnpDRShiftTo(n,r) {\n\t\tfor(var i = n; i < this.t; ++i) r[i-n] = this[i];\n\t\tr.t = Math.max(this.t-n,0);\n\t\tr.s = this.s;\n\t    }\n\t\n\t    // (protected) r = this << n\n\t    function bnpLShiftTo(n,r) {\n\t\tvar bs = n%this.DB;\n\t\tvar cbs = this.DB-bs;\n\t\tvar bm = (1<<cbs)-1;\n\t\tvar ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n\t\tfor(i = this.t-1; i >= 0; --i) {\n\t\t    r[i+ds+1] = (this[i]>>cbs)|c;\n\t\t    c = (this[i]&bm)<<bs;\n\t\t}\n\t\tfor(i = ds-1; i >= 0; --i) r[i] = 0;\n\t\tr[ds] = c;\n\t\tr.t = this.t+ds+1;\n\t\tr.s = this.s;\n\t\tr.clamp();\n\t    }\n\t\n\t    // (protected) r = this >> n\n\t    function bnpRShiftTo(n,r) {\n\t\tr.s = this.s;\n\t\tvar ds = Math.floor(n/this.DB);\n\t\tif(ds >= this.t) { r.t = 0; return; }\n\t\tvar bs = n%this.DB;\n\t\tvar cbs = this.DB-bs;\n\t\tvar bm = (1<<bs)-1;\n\t\tr[0] = this[ds]>>bs;\n\t\tfor(var i = ds+1; i < this.t; ++i) {\n\t\t    r[i-ds-1] |= (this[i]&bm)<<cbs;\n\t\t    r[i-ds] = this[i]>>bs;\n\t\t}\n\t\tif(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n\t\tr.t = this.t-ds;\n\t\tr.clamp();\n\t    }\n\t\n\t    // (protected) r = this - a\n\t    function bnpSubTo(a,r) {\n\t\tvar i = 0, c = 0, m = Math.min(a.t,this.t);\n\t\twhile(i < m) {\n\t\t    c += this[i]-a[i];\n\t\t    r[i++] = c&this.DM;\n\t\t    c >>= this.DB;\n\t\t}\n\t\tif(a.t < this.t) {\n\t\t    c -= a.s;\n\t\t    while(i < this.t) {\n\t\t\tc += this[i];\n\t\t\tr[i++] = c&this.DM;\n\t\t\tc >>= this.DB;\n\t\t    }\n\t\t    c += this.s;\n\t\t}\n\t\telse {\n\t\t    c += this.s;\n\t\t    while(i < a.t) {\n\t\t\tc -= a[i];\n\t\t\tr[i++] = c&this.DM;\n\t\t\tc >>= this.DB;\n\t\t    }\n\t\t    c -= a.s;\n\t\t}\n\t\tr.s = (c<0)?-1:0;\n\t\tif(c < -1) r[i++] = this.DV+c;\n\t\telse if(c > 0) r[i++] = c;\n\t\tr.t = i;\n\t\tr.clamp();\n\t    }\n\t\n\t    // (protected) r = this * a, r != this,a (HAC 14.12)\n\t    // \"this\" should be the larger one if appropriate.\n\t    function bnpMultiplyTo(a,r) {\n\t\tvar x = this.abs(), y = a.abs();\n\t\tvar i = x.t;\n\t\tr.t = i+y.t;\n\t\twhile(--i >= 0) r[i] = 0;\n\t\tfor(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n\t\tr.s = 0;\n\t\tr.clamp();\n\t\tif(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n\t    }\n\t\n\t    // (protected) r = this^2, r != this (HAC 14.16)\n\t    function bnpSquareTo(r) {\n\t\tvar x = this.abs();\n\t\tvar i = r.t = 2*x.t;\n\t\twhile(--i >= 0) r[i] = 0;\n\t\tfor(i = 0; i < x.t-1; ++i) {\n\t\t    var c = x.am(i,x[i],r,2*i,0,1);\n\t\t    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n\t\t\tr[i+x.t] -= x.DV;\n\t\t\tr[i+x.t+1] = 1;\n\t\t    }\n\t\t}\n\t\tif(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n\t\tr.s = 0;\n\t\tr.clamp();\n\t    }\n\t\n\t\n\t    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n\t    // r != q, this != m.  q or r may be null.\n\t    function bnpDivRemTo(m,q,r) {\n\t\tvar pm = m.abs();\n\t\tif(pm.t <= 0) return;\n\t\tvar pt = this.abs();\n\t\tif(pt.t < pm.t) {\n\t\t    if(q != null) q.fromInt(0);\n\t\t    if(r != null) this.copyTo(r);\n\t\t    return;\n\t\t}\n\t\tif(r == null) r = nbi();\n\t\tvar y = nbi(), ts = this.s, ms = m.s;\n\t\tvar nsh = this.DB-nbits(pm[pm.t-1]);\t// normalize modulus\n\t\tif(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n\t\telse { pm.copyTo(y); pt.copyTo(r); }\n\t\tvar ys = y.t;\n\t\tvar y0 = y[ys-1];\n\t\tif(y0 == 0) return;\n\t\tvar yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n\t\tvar d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n\t\tvar i = r.t, j = i-ys, t = (q==null)?nbi():q;\n\t\ty.dlShiftTo(j,t);\n\t\tif(r.compareTo(t) >= 0) {\n\t\t    r[r.t++] = 1;\n\t\t    r.subTo(t,r);\n\t\t}\n\t\tBigInteger.ONE.dlShiftTo(ys,t);\n\t\tt.subTo(y,y);\t// \"negative\" y so we can replace sub with am later\n\t\twhile(y.t < ys) y[y.t++] = 0;\n\t\twhile(--j >= 0) {\n\t\t    // Estimate quotient digit\n\t\t    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n\t\t    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {\t// Try it out\n\t\t\ty.dlShiftTo(j,t);\n\t\t\tr.subTo(t,r);\n\t\t\twhile(r[i] < --qd) r.subTo(t,r);\n\t\t    }\n\t\t}\n\t\tif(q != null) {\n\t\t    r.drShiftTo(ys,q);\n\t\t    if(ts != ms) BigInteger.ZERO.subTo(q,q);\n\t\t}\n\t\tr.t = ys;\n\t\tr.clamp();\n\t\tif(nsh > 0) r.rShiftTo(nsh,r);\t// Denormalize remainder\n\t\tif(ts < 0) BigInteger.ZERO.subTo(r,r);\n\t    }\n\t\n\t    // (public) this mod a\n\t    function bnMod(a) {\n\t\tvar r = nbi();\n\t\tthis.abs().divRemTo(a,null,r);\n\t\tif(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n\t\treturn r;\n\t    }\n\t\n\t    // Modular reduction using \"classic\" algorithm\n\t    function Classic(m) { this.m = m; }\n\t    function cConvert(x) {\n\t\tif(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n\t\telse return x;\n\t    }\n\t    function cRevert(x) { return x; }\n\t    function cReduce(x) { x.divRemTo(this.m,null,x); }\n\t    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\t    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\t\n\t    Classic.prototype.convert = cConvert;\n\t    Classic.prototype.revert = cRevert;\n\t    Classic.prototype.reduce = cReduce;\n\t    Classic.prototype.mulTo = cMulTo;\n\t    Classic.prototype.sqrTo = cSqrTo;\n\t\n\t    // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n\t    // justification:\n\t    //         xy == 1 (mod m)\n\t    //         xy =  1+km\n\t    //   xy(2-xy) = (1+km)(1-km)\n\t    // x[y(2-xy)] = 1-k^2m^2\n\t    // x[y(2-xy)] == 1 (mod m^2)\n\t    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n\t    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n\t    // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n\t    function bnpInvDigit() {\n\t\tif(this.t < 1) return 0;\n\t\tvar x = this[0];\n\t\tif((x&1) == 0) return 0;\n\t\tvar y = x&3;\t\t// y == 1/x mod 2^2\n\t\ty = (y*(2-(x&0xf)*y))&0xf;\t// y == 1/x mod 2^4\n\t\ty = (y*(2-(x&0xff)*y))&0xff;\t// y == 1/x mod 2^8\n\t\ty = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;\t// y == 1/x mod 2^16\n\t\t// last step - calculate inverse mod DV directly;\n\t\t// assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\t\ty = (y*(2-x*y%this.DV))%this.DV;\t\t// y == 1/x mod 2^dbits\n\t\t// we really want the negative inverse, and -DV < y < DV\n\t\treturn (y>0)?this.DV-y:-y;\n\t    }\n\t\n\t    // Montgomery reduction\n\t    function Montgomery(m) {\n\t\tthis.m = m;\n\t\tthis.mp = m.invDigit();\n\t\tthis.mpl = this.mp&0x7fff;\n\t\tthis.mph = this.mp>>15;\n\t\tthis.um = (1<<(m.DB-15))-1;\n\t\tthis.mt2 = 2*m.t;\n\t    }\n\t\n\t    // xR mod m\n\t    function montConvert(x) {\n\t\tvar r = nbi();\n\t\tx.abs().dlShiftTo(this.m.t,r);\n\t\tr.divRemTo(this.m,null,r);\n\t\tif(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n\t\treturn r;\n\t    }\n\t\n\t    // x/R mod m\n\t    function montRevert(x) {\n\t\tvar r = nbi();\n\t\tx.copyTo(r);\n\t\tthis.reduce(r);\n\t\treturn r;\n\t    }\n\t\n\t    // x = x/R mod m (HAC 14.32)\n\t    function montReduce(x) {\n\t\twhile(x.t <= this.mt2)\t// pad x so am has enough room later\n\t\t    x[x.t++] = 0;\n\t\tfor(var i = 0; i < this.m.t; ++i) {\n\t\t    // faster way of calculating u0 = x[i]*mp mod DV\n\t\t    var j = x[i]&0x7fff;\n\t\t    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n\t\t    // use am to combine the multiply-shift-add into one call\n\t\t    j = i+this.m.t;\n\t\t    x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n\t\t    // propagate carry\n\t\t    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n\t\t}\n\t\tx.clamp();\n\t\tx.drShiftTo(this.m.t,x);\n\t\tif(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n\t    }\n\t\n\t    // r = \"x^2/R mod m\"; x != r\n\t    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\t\n\t    // r = \"xy/R mod m\"; x,y != r\n\t    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\t\n\t    Montgomery.prototype.convert = montConvert;\n\t    Montgomery.prototype.revert = montRevert;\n\t    Montgomery.prototype.reduce = montReduce;\n\t    Montgomery.prototype.mulTo = montMulTo;\n\t    Montgomery.prototype.sqrTo = montSqrTo;\n\t\n\t    // (protected) true iff this is even\n\t    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\t\n\t    // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n\t    function bnpExp(e,z) {\n\t\t    if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n\t\t    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n\t\t    g.copyTo(r);\n\t\t    while(--i >= 0) {\n\t\t        z.sqrTo(r,r2);\n\t\t        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n\t\t        else { var t = r; r = r2; r2 = t; }\n\t\t    }\n\t\t    return z.revert(r);\n\t    }\n\t\n\t    // (public) this^e % m, 0 <= e < 2^32\n\t    function bnModPowInt(e,m) {\n\t\tvar z;\n\t\tif(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n\t\treturn this.exp(e,z);\n\t    }\n\t\n\t    // protected\n\t    BigInteger.prototype.copyTo = bnpCopyTo;\n\t    BigInteger.prototype.fromInt = bnpFromInt;\n\t    BigInteger.prototype.fromString = bnpFromString;\n\t    BigInteger.prototype.clamp = bnpClamp;\n\t    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n\t    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n\t    BigInteger.prototype.lShiftTo = bnpLShiftTo;\n\t    BigInteger.prototype.rShiftTo = bnpRShiftTo;\n\t    BigInteger.prototype.subTo = bnpSubTo;\n\t    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n\t    BigInteger.prototype.squareTo = bnpSquareTo;\n\t    BigInteger.prototype.divRemTo = bnpDivRemTo;\n\t    BigInteger.prototype.invDigit = bnpInvDigit;\n\t    BigInteger.prototype.isEven = bnpIsEven;\n\t    BigInteger.prototype.bnpExp = bnpExp;\n\t\n\t    // public\n\t    BigInteger.prototype.toString = bnToString;\n\t    BigInteger.prototype.negate = bnNegate;\n\t    BigInteger.prototype.abs = bnAbs;\n\t    BigInteger.prototype.compareTo = bnCompareTo;\n\t    BigInteger.prototype.bitLength = bnBitLength;\n\t    BigInteger.prototype.mod = bnMod;\n\t    BigInteger.prototype.modPowInt = bnModPowInt;\n\t\n\t    // \"constants\"\n\t    BigInteger.ZERO = nbv(0);\n\t    BigInteger.ONE = nbv(1);\n\t\n\t    // Copyright (c) 2005-2009  Tom Wu\n\t    // All Rights Reserved.\n\t    // See \"LICENSE\" for details.\n\t\n\t    // Extended JavaScript BN functions, required for RSA private ops.\n\t\n\t    // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n\t\n\t    // (public)\n\t    function bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\t\n\t    // (public) return value as integer\n\t    function bnIntValue() {\n\t\tif(this.s < 0) {\n\t\t    if(this.t == 1) return this[0]-this.DV;\n\t\t    else if(this.t == 0) return -1;\n\t\t}\n\t\telse if(this.t == 1) return this[0];\n\t\telse if(this.t == 0) return 0;\n\t\t// assumes 16 < DB < 32\n\t\treturn ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n\t    }\n\t\n\t    // (public) return value as byte\n\t    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\t\n\t    // (public) return value as short (assumes DB>=16)\n\t    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\t\n\t    // (protected) return x s.t. r^x < DV\n\t    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\t\n\t    // (public) 0 if this == 0, 1 if this > 0\n\t    function bnSigNum() {\n\t\tif(this.s < 0) return -1;\n\t\telse if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n\t\telse return 1;\n\t    }\n\t\n\t    // (protected) convert to radix string\n\t    function bnpToRadix(b) {\n\t\tif(b == null) b = 10;\n\t\tif(this.signum() == 0 || b < 2 || b > 36) return \"0\";\n\t\tvar cs = this.chunkSize(b);\n\t\tvar a = Math.pow(b,cs);\n\t\tvar d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n\t\tthis.divRemTo(d,y,z);\n\t\twhile(y.signum() > 0) {\n\t\t    r = (a+z.intValue()).toString(b).substr(1) + r;\n\t\t    y.divRemTo(d,y,z);\n\t\t}\n\t\treturn z.intValue().toString(b) + r;\n\t    }\n\t\n\t    // (protected) convert from radix string\n\t    function bnpFromRadix(s,b) {\n\t\tthis.fromInt(0);\n\t\tif(b == null) b = 10;\n\t\tvar cs = this.chunkSize(b);\n\t\tvar d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n\t\tfor(var i = 0; i < s.length; ++i) {\n\t\t    var x = intAt(s,i);\n\t\t    if(x < 0) {\n\t\t\tif(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n\t\t\tcontinue;\n\t\t    }\n\t\t    w = b*w+x;\n\t\t    if(++j >= cs) {\n\t\t\tthis.dMultiply(d);\n\t\t\tthis.dAddOffset(w,0);\n\t\t\tj = 0;\n\t\t\tw = 0;\n\t\t    }\n\t\t}\n\t\tif(j > 0) {\n\t\t    this.dMultiply(Math.pow(b,j));\n\t\t    this.dAddOffset(w,0);\n\t\t}\n\t\tif(mi) BigInteger.ZERO.subTo(this,this);\n\t    }\n\t\n\t    // (protected) alternate constructor\n\t    function bnpFromNumber(a,b,c) {\n\t\tif(\"number\" == typeof b) {\n\t\t    // new BigInteger(int,int,RNG)\n\t\t    if(a < 2) this.fromInt(1);\n\t\t    else {\n\t\t\tthis.fromNumber(a,c);\n\t\t\tif(!this.testBit(a-1))\t// force MSB set\n\t\t\t    this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n\t\t\tif(this.isEven()) this.dAddOffset(1,0); // force odd\n\t\t\twhile(!this.isProbablePrime(b)) {\n\t\t\t    this.dAddOffset(2,0);\n\t\t\t    if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    // new BigInteger(int,RNG)\n\t\t    var x = [], t = a&7;\n\t\t    x.length = (a>>3)+1;\n\t\t    b.nextBytes(x);\n\t\t    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n\t\t    this.fromString(x,256);\n\t\t}\n\t    }\n\t\n\t    // (public) convert to bigendian byte array\n\t    function bnToByteArray() {\n\t\tvar i = this.t, r = [];\n\t\tr[0] = this.s;\n\t\tvar p = this.DB-(i*this.DB)%8, d, k = 0;\n\t\tif(i-- > 0) {\n\t\t    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n\t\t\tr[k++] = d|(this.s<<(this.DB-p));\n\t\t    while(i >= 0) {\n\t\t\tif(p < 8) {\n\t\t\t    d = (this[i]&((1<<p)-1))<<(8-p);\n\t\t\t    d |= this[--i]>>(p+=this.DB-8);\n\t\t\t}\n\t\t\telse {\n\t\t\t    d = (this[i]>>(p-=8))&0xff;\n\t\t\t    if(p <= 0) { p += this.DB; --i; }\n\t\t\t}\n\t\t\tif((d&0x80) != 0) d |= -256;\n\t\t\tif(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n\t\t\tif(k > 0 || d != this.s) r[k++] = d;\n\t\t    }\n\t\t}\n\t\treturn r;\n\t    }\n\t\n\t    function bnEquals(a) { return(this.compareTo(a)==0); }\n\t    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\n\t    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\t\n\t    // (protected) r = this op a (bitwise)\n\t    function bnpBitwiseTo(a,op,r) {\n\t\tvar i, f, m = Math.min(a.t,this.t);\n\t\tfor(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n\t\tif(a.t < this.t) {\n\t\t    f = a.s&this.DM;\n\t\t    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n\t\t    r.t = this.t;\n\t\t}\n\t\telse {\n\t\t    f = this.s&this.DM;\n\t\t    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n\t\t    r.t = a.t;\n\t\t}\n\t\tr.s = op(this.s,a.s);\n\t\tr.clamp();\n\t    }\n\t\n\t    // (public) this & a\n\t    function op_and(x,y) { return x&y; }\n\t    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\t\n\t    // (public) this | a\n\t    function op_or(x,y) { return x|y; }\n\t    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\t\n\t    // (public) this ^ a\n\t    function op_xor(x,y) { return x^y; }\n\t    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\t\n\t    // (public) this & ~a\n\t    function op_andnot(x,y) { return x&~y; }\n\t    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\t\n\t    // (public) ~this\n\t    function bnNot() {\n\t\tvar r = nbi();\n\t\tfor(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n\t\tr.t = this.t;\n\t\tr.s = ~this.s;\n\t\treturn r;\n\t    }\n\t\n\t    // (public) this << n\n\t    function bnShiftLeft(n) {\n\t\tvar r = nbi();\n\t\tif(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n\t\treturn r;\n\t    }\n\t\n\t    // (public) this >> n\n\t    function bnShiftRight(n) {\n\t\tvar r = nbi();\n\t\tif(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n\t\treturn r;\n\t    }\n\t\n\t    // return index of lowest 1-bit in x, x < 2^31\n\t    function lbit(x) {\n\t\tif(x == 0) return -1;\n\t\tvar r = 0;\n\t\tif((x&0xffff) == 0) { x >>= 16; r += 16; }\n\t\tif((x&0xff) == 0) { x >>= 8; r += 8; }\n\t\tif((x&0xf) == 0) { x >>= 4; r += 4; }\n\t\tif((x&3) == 0) { x >>= 2; r += 2; }\n\t\tif((x&1) == 0) ++r;\n\t\treturn r;\n\t    }\n\t\n\t    // (public) returns index of lowest 1-bit (or -1 if none)\n\t    function bnGetLowestSetBit() {\n\t\tfor(var i = 0; i < this.t; ++i)\n\t\t    if(this[i] != 0) return i*this.DB+lbit(this[i]);\n\t\tif(this.s < 0) return this.t*this.DB;\n\t\treturn -1;\n\t    }\n\t\n\t    // return number of 1 bits in x\n\t    function cbit(x) {\n\t\tvar r = 0;\n\t\twhile(x != 0) { x &= x-1; ++r; }\n\t\treturn r;\n\t    }\n\t\n\t    // (public) return number of set bits\n\t    function bnBitCount() {\n\t\tvar r = 0, x = this.s&this.DM;\n\t\tfor(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n\t\treturn r;\n\t    }\n\t\n\t    // (public) true iff nth bit is set\n\t    function bnTestBit(n) {\n\t\tvar j = Math.floor(n/this.DB);\n\t\tif(j >= this.t) return(this.s!=0);\n\t\treturn((this[j]&(1<<(n%this.DB)))!=0);\n\t    }\n\t\n\t    // (protected) this op (1<<n)\n\t    function bnpChangeBit(n,op) {\n\t\tvar r = BigInteger.ONE.shiftLeft(n);\n\t\tthis.bitwiseTo(r,op,r);\n\t\treturn r;\n\t    }\n\t\n\t    // (public) this | (1<<n)\n\t    function bnSetBit(n) { return this.changeBit(n,op_or); }\n\t\n\t    // (public) this & ~(1<<n)\n\t    function bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\t\n\t    // (public) this ^ (1<<n)\n\t    function bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\t\n\t    // (protected) r = this + a\n\t    function bnpAddTo(a,r) {\n\t\tvar i = 0, c = 0, m = Math.min(a.t,this.t);\n\t\twhile(i < m) {\n\t\t    c += this[i]+a[i];\n\t\t    r[i++] = c&this.DM;\n\t\t    c >>= this.DB;\n\t\t}\n\t\tif(a.t < this.t) {\n\t\t    c += a.s;\n\t\t    while(i < this.t) {\n\t\t\tc += this[i];\n\t\t\tr[i++] = c&this.DM;\n\t\t\tc >>= this.DB;\n\t\t    }\n\t\t    c += this.s;\n\t\t}\n\t\telse {\n\t\t    c += this.s;\n\t\t    while(i < a.t) {\n\t\t\tc += a[i];\n\t\t\tr[i++] = c&this.DM;\n\t\t\tc >>= this.DB;\n\t\t    }\n\t\t    c += a.s;\n\t\t}\n\t\tr.s = (c<0)?-1:0;\n\t\tif(c > 0) r[i++] = c;\n\t\telse if(c < -1) r[i++] = this.DV+c;\n\t\tr.t = i;\n\t\tr.clamp();\n\t    }\n\t\n\t    // (public) this + a\n\t    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\t\n\t    // (public) this - a\n\t    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\t\n\t    // (public) this * a\n\t    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\t\n\t    // (public) this / a\n\t    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\t\n\t    // (public) this % a\n\t    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\t\n\t    // (public) [this/a,this%a]\n\t    function bnDivideAndRemainder(a) {\n\t\tvar q = nbi(), r = nbi();\n\t\tthis.divRemTo(a,q,r);\n\t\treturn [q,r];\n\t    }\n\t\n\t    // (protected) this *= n, this >= 0, 1 < n < DV\n\t    function bnpDMultiply(n) {\n\t\tthis[this.t] = this.am(0,n-1,this,0,0,this.t);\n\t\t++this.t;\n\t\tthis.clamp();\n\t    }\n\t\n\t    // (protected) this += n << w words, this >= 0\n\t    function bnpDAddOffset(n,w) {\n\t\tif(n == 0) return;\n\t\twhile(this.t <= w) this[this.t++] = 0;\n\t\tthis[w] += n;\n\t\twhile(this[w] >= this.DV) {\n\t\t    this[w] -= this.DV;\n\t\t    if(++w >= this.t) this[this.t++] = 0;\n\t\t    ++this[w];\n\t\t}\n\t    }\n\t\n\t    // A \"null\" reducer\n\t    function NullExp() {}\n\t    function nNop(x) { return x; }\n\t    function nMulTo(x,y,r) { x.multiplyTo(y,r); }\n\t    function nSqrTo(x,r) { x.squareTo(r); }\n\t\n\t    NullExp.prototype.convert = nNop;\n\t    NullExp.prototype.revert = nNop;\n\t    NullExp.prototype.mulTo = nMulTo;\n\t    NullExp.prototype.sqrTo = nSqrTo;\n\t\n\t    // (public) this^e\n\t    function bnPow(e) { return this.bnpExp(e,new NullExp()); }\n\t\n\t    // (protected) r = lower n words of \"this * a\", a.t <= n\n\t    // \"this\" should be the larger one if appropriate.\n\t    function bnpMultiplyLowerTo(a,n,r) {\n\t\tvar i = Math.min(this.t+a.t,n);\n\t\tr.s = 0; // assumes a,this >= 0\n\t\tr.t = i;\n\t\twhile(i > 0) r[--i] = 0;\n\t\tvar j;\n\t\tfor(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n\t\tfor(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n\t\tr.clamp();\n\t    }\n\t\n\t    // (protected) r = \"this * a\" without lower n words, n > 0\n\t    // \"this\" should be the larger one if appropriate.\n\t    function bnpMultiplyUpperTo(a,n,r) {\n\t\t--n;\n\t\tvar i = r.t = this.t+a.t-n;\n\t\tr.s = 0; // assumes a,this >= 0\n\t\twhile(--i >= 0) r[i] = 0;\n\t\tfor(i = Math.max(n-this.t,0); i < a.t; ++i)\n\t\t    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n\t\tr.clamp();\n\t\tr.drShiftTo(1,r);\n\t    }\n\t\n\t    // Barrett modular reduction\n\t    function Barrett(m) {\n\t\t// setup Barrett\n\t\tthis.r2 = nbi();\n\t\tthis.q3 = nbi();\n\t\tBigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n\t\tthis.mu = this.r2.divide(m);\n\t\tthis.m = m;\n\t    }\n\t\n\t    function barrettConvert(x) {\n\t\tif(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n\t\telse if(x.compareTo(this.m) < 0) return x;\n\t\telse { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n\t    }\n\t\n\t    function barrettRevert(x) { return x; }\n\t\n\t    // x = x mod m (HAC 14.42)\n\t    function barrettReduce(x) {\n\t\tx.drShiftTo(this.m.t-1,this.r2);\n\t\tif(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n\t\tthis.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n\t\tthis.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n\t\twhile(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n\t\tx.subTo(this.r2,x);\n\t\twhile(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n\t    }\n\t\n\t    // r = x^2 mod m; x != r\n\t    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\t\n\t    // r = x*y mod m; x,y != r\n\t    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\t\n\t    Barrett.prototype.convert = barrettConvert;\n\t    Barrett.prototype.revert = barrettRevert;\n\t    Barrett.prototype.reduce = barrettReduce;\n\t    Barrett.prototype.mulTo = barrettMulTo;\n\t    Barrett.prototype.sqrTo = barrettSqrTo;\n\t\n\t    // (public) this^e % m (HAC 14.85)\n\t    function bnModPow(e,m) {\n\t\tvar i = e.bitLength(), k, r = nbv(1), z;\n\t\tif(i <= 0) return r;\n\t\telse if(i < 18) k = 1;\n\t\telse if(i < 48) k = 3;\n\t\telse if(i < 144) k = 4;\n\t\telse if(i < 768) k = 5;\n\t\telse k = 6;\n\t\tif(i < 8)\n\t\t    z = new Classic(m);\n\t\telse if(m.isEven())\n\t\t    z = new Barrett(m);\n\t\telse\n\t\t    z = new Montgomery(m);\n\t\n\t\t// precomputation\n\t\tvar g = [], n = 3, k1 = k-1, km = (1<<k)-1;\n\t\tg[1] = z.convert(this);\n\t\tif(k > 1) {\n\t\t    var g2 = nbi();\n\t\t    z.sqrTo(g[1],g2);\n\t\t    while(n <= km) {\n\t\t\tg[n] = nbi();\n\t\t\tz.mulTo(g2,g[n-2],g[n]);\n\t\t\tn += 2;\n\t\t    }\n\t\t}\n\t\n\t\tvar j = e.t-1, w, is1 = true, r2 = nbi(), t;\n\t\ti = nbits(e[j])-1;\n\t\twhile(j >= 0) {\n\t\t    if(i >= k1) w = (e[j]>>(i-k1))&km;\n\t\t    else {\n\t\t\tw = (e[j]&((1<<(i+1))-1))<<(k1-i);\n\t\t\tif(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n\t\t    }\n\t\n\t\t    n = k;\n\t\t    while((w&1) == 0) { w >>= 1; --n; }\n\t\t    if((i -= n) < 0) { i += this.DB; --j; }\n\t\t    if(is1) {\t// ret == 1, don't bother squaring or multiplying it\n\t\t\tg[w].copyTo(r);\n\t\t\tis1 = false;\n\t\t    }\n\t\t    else {\n\t\t\twhile(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n\t\t\tif(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n\t\t\tz.mulTo(r2,g[w],r);\n\t\t    }\n\t\n\t\t    while(j >= 0 && (e[j]&(1<<i)) == 0) {\n\t\t\tz.sqrTo(r,r2); t = r; r = r2; r2 = t;\n\t\t\tif(--i < 0) { i = this.DB-1; --j; }\n\t\t    }\n\t\t}\n\t\treturn z.revert(r);\n\t    }\n\t\n\t    // (public) gcd(this,a) (HAC 14.54)\n\t    function bnGCD(a) {\n\t\tvar x = (this.s<0)?this.negate():this.clone();\n\t\tvar y = (a.s<0)?a.negate():a.clone();\n\t\tif(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n\t\tvar i = x.getLowestSetBit(), g = y.getLowestSetBit();\n\t\tif(g < 0) return x;\n\t\tif(i < g) g = i;\n\t\tif(g > 0) {\n\t\t    x.rShiftTo(g,x);\n\t\t    y.rShiftTo(g,y);\n\t\t}\n\t\twhile(x.signum() > 0) {\n\t\t    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n\t\t    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n\t\t    if(x.compareTo(y) >= 0) {\n\t\t\tx.subTo(y,x);\n\t\t\tx.rShiftTo(1,x);\n\t\t    }\n\t\t    else {\n\t\t\ty.subTo(x,y);\n\t\t\ty.rShiftTo(1,y);\n\t\t    }\n\t\t}\n\t\tif(g > 0) y.lShiftTo(g,y);\n\t\treturn y;\n\t    }\n\t\n\t    // (protected) this % n, n < 2^26\n\t    function bnpModInt(n) {\n\t\tif(n <= 0) return 0;\n\t\tvar d = this.DV%n, r = (this.s<0)?n-1:0;\n\t\tif(this.t > 0)\n\t\t    if(d == 0) r = this[0]%n;\n\t\telse for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n\t\treturn r;\n\t    }\n\t\n\t    // (public) 1/this % m (HAC 14.61)\n\t    function bnModInverse(m) {\n\t\tvar ac = m.isEven();\n\t\tif((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n\t\tvar u = m.clone(), v = this.clone();\n\t\tvar a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n\t\twhile(u.signum() != 0) {\n\t\t    while(u.isEven()) {\n\t\t\tu.rShiftTo(1,u);\n\t\t\tif(ac) {\n\t\t\t    if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n\t\t\t    a.rShiftTo(1,a);\n\t\t\t}\n\t\t\telse if(!b.isEven()) b.subTo(m,b);\n\t\t\tb.rShiftTo(1,b);\n\t\t    }\n\t\t    while(v.isEven()) {\n\t\t\tv.rShiftTo(1,v);\n\t\t\tif(ac) {\n\t\t\t    if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n\t\t\t    c.rShiftTo(1,c);\n\t\t\t}\n\t\t\telse if(!d.isEven()) d.subTo(m,d);\n\t\t\td.rShiftTo(1,d);\n\t\t    }\n\t\t    if(u.compareTo(v) >= 0) {\n\t\t\tu.subTo(v,u);\n\t\t\tif(ac) a.subTo(c,a);\n\t\t\tb.subTo(d,b);\n\t\t    }\n\t\t    else {\n\t\t\tv.subTo(u,v);\n\t\t\tif(ac) c.subTo(a,c);\n\t\t\td.subTo(b,d);\n\t\t    }\n\t\t}\n\t\tif(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n\t\tif(d.compareTo(m) >= 0) return d.subtract(m);\n\t\tif(d.signum() < 0) d.addTo(m,d); else return d;\n\t\tif(d.signum() < 0) return d.add(m); else return d;\n\t    }\n\t\n\t    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];\n\t    var lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\t\n\t    // (public) test primality with certainty >= 1-.5^t\n\t    function bnIsProbablePrime(t) {\n\t\tvar i, x = this.abs();\n\t\tif(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n\t\t    for(i = 0; i < lowprimes.length; ++i)\n\t\t\tif(x[0] == lowprimes[i]) return true;\n\t\t    return false;\n\t\t}\n\t\tif(x.isEven()) return false;\n\t\ti = 1;\n\t\twhile(i < lowprimes.length) {\n\t\t    var m = lowprimes[i], j = i+1;\n\t\t    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n\t\t    m = x.modInt(m);\n\t\t    while(i < j) if(m%lowprimes[i++] == 0) return false;\n\t\t}\n\t\treturn x.millerRabin(t);\n\t    }\n\t\n\t    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n\t    function bnpMillerRabin(t) {\n\t\tvar n1 = this.subtract(BigInteger.ONE);\n\t\tvar k = n1.getLowestSetBit();\n\t\tif(k <= 0) return false;\n\t\tvar r = n1.shiftRight(k);\n\t\tt = (t+1)>>1;\n\t\tif(t > lowprimes.length) t = lowprimes.length;\n\t\tvar a = nbi();\n\t\tfor(var i = 0; i < t; ++i) {\n\t\t    a.fromInt(lowprimes[i]);\n\t\t    var y = a.modPow(r,this);\n\t\t    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n\t\t\tvar j = 1;\n\t\t\twhile(j++ < k && y.compareTo(n1) != 0) {\n\t\t\t    y = y.modPowInt(2,this);\n\t\t\t    if(y.compareTo(BigInteger.ONE) == 0) return false;\n\t\t\t}\n\t\t\tif(y.compareTo(n1) != 0) return false;\n\t\t    }\n\t\t}\n\t\treturn true;\n\t    }\n\t    \n\t    \n\t\n\t    // protected\n\t    BigInteger.prototype.chunkSize = bnpChunkSize;\n\t    BigInteger.prototype.toRadix = bnpToRadix;\n\t    BigInteger.prototype.fromRadix = bnpFromRadix;\n\t    BigInteger.prototype.fromNumber = bnpFromNumber;\n\t    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n\t    BigInteger.prototype.changeBit = bnpChangeBit;\n\t    BigInteger.prototype.addTo = bnpAddTo;\n\t    BigInteger.prototype.dMultiply = bnpDMultiply;\n\t    BigInteger.prototype.dAddOffset = bnpDAddOffset;\n\t    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n\t    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n\t    BigInteger.prototype.modInt = bnpModInt;\n\t    BigInteger.prototype.millerRabin = bnpMillerRabin;\n\t\n\t    // public\n\t    BigInteger.prototype.clone = bnClone;\n\t    BigInteger.prototype.intValue = bnIntValue;\n\t    BigInteger.prototype.byteValue = bnByteValue;\n\t    BigInteger.prototype.shortValue = bnShortValue;\n\t    BigInteger.prototype.signum = bnSigNum;\n\t    BigInteger.prototype.toByteArray = bnToByteArray;\n\t    BigInteger.prototype.equals = bnEquals;\n\t    BigInteger.prototype.min = bnMin;\n\t    BigInteger.prototype.max = bnMax;\n\t    BigInteger.prototype.and = bnAnd;\n\t    BigInteger.prototype.or = bnOr;\n\t    BigInteger.prototype.xor = bnXor;\n\t    BigInteger.prototype.andNot = bnAndNot;\n\t    BigInteger.prototype.not = bnNot;\n\t    BigInteger.prototype.shiftLeft = bnShiftLeft;\n\t    BigInteger.prototype.shiftRight = bnShiftRight;\n\t    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n\t    BigInteger.prototype.bitCount = bnBitCount;\n\t    BigInteger.prototype.testBit = bnTestBit;\n\t    BigInteger.prototype.setBit = bnSetBit;\n\t    BigInteger.prototype.clearBit = bnClearBit;\n\t    BigInteger.prototype.flipBit = bnFlipBit;\n\t    BigInteger.prototype.add = bnAdd;\n\t    BigInteger.prototype.subtract = bnSubtract;\n\t    BigInteger.prototype.multiply = bnMultiply;\n\t    BigInteger.prototype.divide = bnDivide;\n\t    BigInteger.prototype.remainder = bnRemainder;\n\t    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n\t    BigInteger.prototype.modPow = bnModPow;\n\t    BigInteger.prototype.modInverse = bnModInverse;\n\t    BigInteger.prototype.pow = bnPow;\n\t    BigInteger.prototype.expt = bnPow;\n\t    BigInteger.prototype.gcd = bnGCD;\n\t    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\t\n\t    // BigInteger interfaces not implemented in jsbn:\n\t\n\t    // BigInteger(int signum, byte[] magnitude)\n\t    // double doubleValue()\n\t    // float floatValue()\n\t    // int hashCode()\n\t    // long longValue()\n\t    // static BigInteger valueOf(long val)\n\t\n\t\n\t\n\t    //////////////////////////////////////////////////////////////////////\n\t    //////////////////////////////////////////////////////////////////////\n\t    //////////////////////////////////////////////////////////////////////\n\t    //////////////////////////////////////////////////////////////////////\n\t    //////////////////////////////////////////////////////////////////////\n\t    // END OF copy-and-paste of jsbn.\n\t\n\t\n\t\n\t    BigInteger.NEGATIVE_ONE = BigInteger.ONE.negate();\n\t\n\t\n\t    // Other methods we need to add for compatibilty with js-numbers numeric tower.\n\t\n\t    // add is implemented above.\n\t    // subtract is implemented above.\n\t    // multiply is implemented above.\n\t    // equals is implemented above.\n\t    // abs is implemented above.\n\t    // negate is defined above.\n\t\n\t    // makeBignum: string -> BigInteger\n\t    var makeBignum = function(s) {\n\t\tif (typeof(s) === 'number') { s = s + ''; }\n\t\ts = expandExponent(s);\n\t\treturn new BigInteger(s, 10);\n\t    };\n\t\n\t    var zerostring = function(n) {\n\t\tvar buf = [];\n\t\tfor (var i = 0; i < n; i++) {\n\t\t    buf.push('0');\n\t\t}\n\t\treturn buf.join('');\n\t    };\n\t\n\t\n\t    BigInteger.prototype.level = 0;\n\t    BigInteger.prototype.liftTo = function(target) {\n\t\tif (target.level === 1) {\n\t\t    return new Rational(this, 1);\n\t\t}\n\t\tif (target.level === 2) {\n\t\t    var fixrep = this.toFixnum();\n\t\t    if (fixrep === Number.POSITIVE_INFINITY)\n\t\t\treturn TOO_POSITIVE_TO_REPRESENT;\n\t\t    if (fixrep === Number.NEGATIVE_INFINITY)\n\t\t\treturn TOO_NEGATIVE_TO_REPRESENT;\n\t\t    return new FloatPoint(fixrep);\n\t\t}\n\t\tif (target.level === 3) {\n\t\t    return new Complex(this, 0);\n\t\t}\n\t\treturn throwRuntimeError(\"invalid level for BigInteger lift\", this, target);\n\t    };\n\t\n\t    BigInteger.prototype.isFinite = function() {\n\t\treturn true;\n\t    };\n\t\n\t    BigInteger.prototype.isInteger = function() {\n\t\treturn true;\n\t    };\n\t\n\t    BigInteger.prototype.isRational = function() {\n\t\treturn true;\n\t    };\n\t\n\t    BigInteger.prototype.isReal = function() {\n\t\treturn true;\n\t    };\n\t\n\t    BigInteger.prototype.isExact = function() {\n\t\treturn true;\n\t    };\n\t\n\t    BigInteger.prototype.isInexact = function() {\n\t\treturn false;\n\t    };\n\t\n\t    BigInteger.prototype.toExact = function() {\n\t\treturn this;\n\t    };\n\t\n\t    BigInteger.prototype.toInexact = function() {\n\t\treturn FloatPoint.makeInstance(this.toFixnum());\n\t    };\n\t\n\t    BigInteger.prototype.toFixnum = function() {\n\t\tvar result = 0, str = this.toString(), i;\n\t\tif (str[0] === '-') {\n\t\t    for (i=1; i < str.length; i++) {\n\t\t\tresult = result * 10 + Number(str[i]);\n\t\t    }\n\t\t    return -result;\n\t\t} else {\n\t\t    for (i=0; i < str.length; i++) {\n\t\t\tresult = result * 10 + Number(str[i]);\n\t\t    }\n\t\t    return result;\n\t\t}\n\t    };\n\t\n\t\n\t    BigInteger.prototype.greaterThan = function(other) {\n\t\treturn this.compareTo(other) > 0;\n\t    };\n\t\n\t    BigInteger.prototype.greaterThanOrEqual = function(other) {\n\t\treturn this.compareTo(other) >= 0;\n\t    };\n\t\n\t    BigInteger.prototype.lessThan = function(other) {\n\t\treturn this.compareTo(other) < 0;\n\t    };\n\t\n\t    BigInteger.prototype.lessThanOrEqual = function(other) {\n\t\treturn this.compareTo(other) <= 0;\n\t    };\n\t\n\t    // divide: scheme-number -> scheme-number\n\t    // WARNING NOTE: we override the old version of divide.\n\t    BigInteger.prototype.divide = function(other) {\n\t\tvar quotientAndRemainder = bnDivideAndRemainder.call(this, other);\n\t\tif (quotientAndRemainder[1].compareTo(BigInteger.ZERO) === 0) {\n\t\t    return quotientAndRemainder[0];\n\t\t} else {\n\t\t    var result = add(quotientAndRemainder[0],\n\t\t\t\t     Rational.makeInstance(quotientAndRemainder[1], other));\n\t\t    return result;\n\t\t}\n\t    };\n\t\n\t    BigInteger.prototype.numerator = function() {\n\t\treturn this;\n\t    };\n\t\n\t    BigInteger.prototype.denominator = function() {\n\t\treturn 1;\n\t    };\n\t\n\t\n\t    (function() {\n\t\t// Classic implementation of Newton-Ralphson square-root search,\n\t\t// adapted for integer-sqrt.\n\t\t// http://en.wikipedia.org/wiki/Newton's_method#Square_root_of_a_number\n\t\t    var searchIter = function(n, guess) {\n\t\t\twhile(!(lessThanOrEqual(sqr(guess),n) &&\n\t\t\t\tlessThan(n,sqr(add(guess, 1))))) {\n\t\t\t    guess = floor(divide(add(guess,\n\t\t\t\t\t\t     floor(divide(n, guess))),\n\t\t\t\t\t\t 2));\n\t\t\t}\n\t\t\treturn guess;\n\t\t    };\n\t\n\t\t    // integerSqrt: -> scheme-number\n\t\t    BigInteger.prototype.integerSqrt = function() {\n\t\t\tvar n;\n\t\t\tif(sign(this) >= 0) {\n\t\t\t    return searchIter(this, this);\n\t\t\t} else {\n\t\t\t    n = this.negate();\n\t\t\t    return Complex.makeInstance(0, searchIter(n, n));\n\t\t\t}\n\t\t    };\n\t    })();\n\t\n\t\n\t    // sqrt: -> scheme-number\n\t    // http://en.wikipedia.org/wiki/Newton's_method#Square_root_of_a_number\n\t    // Produce the square root.\n\t    (function() {\t\n\t\t// Get an approximation using integerSqrt, and then start another\n\t\t// Newton-Ralphson search if necessary.\n\t\tBigInteger.prototype.sqrt = function() {\n\t\t    var approx = this.integerSqrt(), fix;\n\t\t    if (eqv(sqr(approx), this)) {\n\t\t\treturn approx;\n\t\t    }\n\t\t    fix = toFixnum(this);\n\t\t    if (isFinite(fix)) {\n\t\t\tif (fix >= 0) {\n\t\t\t    return FloatPoint.makeInstance(Math.sqrt(fix));\n\t\t\t} else {\n\t\t\t    return Complex.makeInstance(\n\t\t\t\t0,\n\t\t\t\tFloatPoint.makeInstance(Math.sqrt(-fix)));\n\t\t\t}\n\t\t    } else {\n\t\t\treturn approx;\n\t\t    }\n\t\t};\n\t    })();\n\t\n\t    // floor: -> scheme-number\n\t    // Produce the floor.\n\t    BigInteger.prototype.floor = function() {\n\t        return this;\n\t    }\n\t\n\t    // ceiling: -> scheme-number\n\t    // Produce the ceiling.\n\t    BigInteger.prototype.ceiling = function() {\n\t        return this;\n\t    }\n\t\n\t\n\t    // Until we have a feature-complete Big Number implementation, we'll\n\t    // convert BigInteger objects into FloatPoint objects and perform\n\t    // unsupported operations there.\n\t    function temporaryAccuracyLosingWorkAroundForBigNums(function_name) {\n\t      return function () {\n\t\tvar inexact = this.toInexact();\n\t\treturn inexact[function_name].apply(inexact, arguments);\n\t      }\n\t    }\n\t\n\t    // conjugate: -> scheme-number\n\t    // Produce the conjugate.\n\t    BigInteger.prototype.conjugate = temporaryAccuracyLosingWorkAroundForBigNums(\"conjugate\");\n\t\n\t    // magnitude: -> scheme-number\n\t    // Produce the magnitude.\n\t    BigInteger.prototype.magnitude = temporaryAccuracyLosingWorkAroundForBigNums(\"magnitude\");\n\t\n\t    // log: -> scheme-number\n\t    // Produce the log.\n\t    BigInteger.prototype.log = temporaryAccuracyLosingWorkAroundForBigNums(\"log\");\n\t\n\t    // angle: -> scheme-number\n\t    // Produce the angle.\n\t    BigInteger.prototype.angle = temporaryAccuracyLosingWorkAroundForBigNums(\"angle\");\n\t\n\t    // atan: -> scheme-number\n\t    // Produce the arc tangent.\n\t    BigInteger.prototype.atan = temporaryAccuracyLosingWorkAroundForBigNums(\"atan\");\n\t\n\t    // acos: -> scheme-number\n\t    // Produce the arc cosine.\n\t    BigInteger.prototype.acos = temporaryAccuracyLosingWorkAroundForBigNums(\"acos\");\n\t\n\t    // asin: -> scheme-number\n\t    // Produce the arc sine.\n\t    BigInteger.prototype.asin = temporaryAccuracyLosingWorkAroundForBigNums(\"asin\");\n\t\n\t    // tan: -> scheme-number\n\t    // Produce the tangent.\n\t    BigInteger.prototype.tan = temporaryAccuracyLosingWorkAroundForBigNums(\"tan\");\n\t\n\t    // cos: -> scheme-number\n\t    // Produce the cosine.\n\t    BigInteger.prototype.cos = temporaryAccuracyLosingWorkAroundForBigNums(\"cos\");\n\t\n\t    // sin: -> scheme-number\n\t    // Produce the sine.\n\t    BigInteger.prototype.sin = temporaryAccuracyLosingWorkAroundForBigNums(\"sin\");\n\t\n\t    // exp: -> scheme-number\n\t    // Produce e raised to the given power.\n\t    BigInteger.prototype.exp = temporaryAccuracyLosingWorkAroundForBigNums(\"exp\");\n\t\n\t    BigInteger.prototype.imaginaryPart = function() {\n\t\t    return 0;\n\t    }\n\t    BigInteger.prototype.realPart = function() {\n\t\t    return this;\n\t    }\n\t\n\t    // round: -> scheme-number\n\t    // Round to the nearest integer.\n\t    BigInteger.prototype.round = function() {\n\t\t    return this;\n\t    }\n\t\n\t\n\t\n\t\n\t\n\t    //////////////////////////////////////////////////////////////////////\n\t    // toRepeatingDecimal: jsnum jsnum {limit: number}? -> [string, string, string]\n\t    //\n\t    // Given the numerator and denominator parts of a rational,\n\t    // produces the repeating-decimal representation, where the first\n\t    // part are the digits before the decimal, the second are the\n\t    // non-repeating digits after the decimal, and the third are the\n\t    // remaining repeating decimals.\n\t    // \n\t    // An optional limit on the decimal expansion can be provided, in which\n\t    // case the search cuts off if we go past the limit.\n\t    // If this happens, the third argument returned becomes '...' to indicate\n\t    // that the search was prematurely cut off.\n\t    var toRepeatingDecimal = (function() {\n\t\tvar getResidue = function(r, d, limit) {\n\t\t    var digits = [];\n\t\t    var seenRemainders = {};\n\t\t    seenRemainders[r] = true;\n\t\t    while(true) {\t\n\t\t\tif (limit-- <= 0) {\n\t\t\t    return [digits.join(''), '...']\n\t\t\t}\n\t\n\t\t\tvar nextDigit = quotient(\n\t\t\t    multiply(r, 10), d);\n\t\t\tvar nextRemainder = remainder(\n\t\t\t    multiply(r, 10),\n\t\t\t    d);\n\t\t\tdigits.push(nextDigit.toString());\n\t\t\tif (seenRemainders[nextRemainder]) {\n\t\t\t    r = nextRemainder;\n\t\t\t    break;\n\t\t\t} else {\n\t\t\t    seenRemainders[nextRemainder] = true;\n\t\t\t    r = nextRemainder;\n\t\t\t}\n\t\t    }\n\t\t    \n\t\t    var firstRepeatingRemainder = r;\n\t\t    var repeatingDigits = [];\n\t\t    while (true) {\n\t\t\tvar nextDigit = quotient(multiply(r, 10), d);\n\t\t\tvar nextRemainder = remainder(\n\t\t\t    multiply(r, 10),\n\t\t\t    d);\n\t\t\trepeatingDigits.push(nextDigit.toString());\n\t\t\tif (equals(nextRemainder, firstRepeatingRemainder)) {\n\t\t\t    break;\n\t\t\t} else {\n\t\t\t    r = nextRemainder;\n\t\t\t}\n\t\t    };\n\t\n\t\t    var digitString = digits.join('');\n\t\t    var repeatingDigitString = repeatingDigits.join('');\n\t\n\t\t    while (digitString.length >= repeatingDigitString.length &&\n\t\t\t   (digitString.substring(\n\t\t\t       digitString.length - repeatingDigitString.length)\n\t\t\t    === repeatingDigitString)) {\n\t\t\tdigitString = digitString.substring(\n\t\t\t    0, digitString.length - repeatingDigitString.length);\n\t\t    }\n\t\n\t\t    return [digitString, repeatingDigitString];\n\t\n\t\t};\n\t\n\t\treturn function(n, d, options) {\n\t\t    // default limit on decimal expansion; can be overridden\n\t\t    var limit = 512;\n\t\t    if (options && typeof(options.limit) !== 'undefined') {\n\t\t\tlimit = options.limit;\n\t\t    }\n\t\t    if (! isInteger(n)) {\n\t\t\tthrowRuntimeError('toRepeatingDecimal: n ' + n.toString() +\n\t\t\t\t\t  \" is not an integer.\");\n\t\t    }\n\t\t    if (! isInteger(d)) {\n\t\t\tthrowRuntimeError('toRepeatingDecimal: d ' + d.toString() +\n\t\t\t\t\t  \" is not an integer.\");\n\t\t    }\n\t\t    if (equals(d, 0)) {\n\t\t\tthrowRuntimeError('toRepeatingDecimal: d equals 0');\n\t\t    }\n\t\t    if (lessThan(d, 0)) {\n\t\t\tthrowRuntimeError('toRepeatingDecimal: d < 0');\n\t\t    }\n\t \t    var sign = (lessThan(n, 0) ? \"-\" : \"\");\n\t \t    n = abs(n);\n\t \t    var beforeDecimalPoint = sign + quotient(n, d);\n\t \t    var afterDecimals = getResidue(remainder(n, d), d, limit);\n\t \t    return [beforeDecimalPoint].concat(afterDecimals);\n\t\t};\n\t    })();\n\t    //////////////////////////////////////////////////////////////////////\n\t\n\t\n\t\n\t\n\t    // External interface of js-numbers:\n\t\n\t    Numbers['fromFixnum'] = fromFixnum;\n\t    Numbers['fromString'] = fromString;\n\t    Numbers['makeBignum'] = makeBignum;\n\t    Numbers['makeRational'] = Rational.makeInstance;\n\t    Numbers['makeFloat'] = FloatPoint.makeInstance;\n\t    Numbers['makeComplex'] = Complex.makeInstance;\n\t    Numbers['makeComplexPolar'] = makeComplexPolar;\n\t\n\t    Numbers['pi'] = FloatPoint.pi;\n\t    Numbers['e'] = FloatPoint.e;\n\t    Numbers['nan'] = FloatPoint.nan;\n\t    Numbers['negative_inf'] = FloatPoint.neginf;\n\t    Numbers['inf'] = FloatPoint.inf;\n\t    Numbers['negative_one'] = -1;   // Rational.NEGATIVE_ONE;\n\t    Numbers['zero'] = 0;            // Rational.ZERO;\n\t    Numbers['one'] = 1;             // Rational.ONE;\n\t    Numbers['i'] = plusI;\n\t    Numbers['negative_i'] = minusI;\n\t    Numbers['negative_zero'] = NEGATIVE_ZERO;\n\t\n\t    Numbers['onThrowRuntimeError'] = onThrowRuntimeError;\n\t    Numbers['isSchemeNumber'] = isSchemeNumber;\n\t    Numbers['isRational'] = isRational;\n\t    Numbers['isReal'] = isReal;\n\t    Numbers['isExact'] = isExact;\n\t    Numbers['isInexact'] = isInexact;\n\t    Numbers['isInteger'] = isInteger;\n\t\n\t    Numbers['toFixnum'] = toFixnum;\n\t    Numbers['toExact'] = toExact;\n\t    Numbers['toInexact'] = toInexact;\n\t    Numbers['add'] = add;\n\t    Numbers['subtract'] = subtract;\n\t    Numbers['multiply'] = multiply;\n\t    Numbers['divide'] = divide;\n\t    Numbers['equals'] = equals;\n\t    Numbers['eqv'] = eqv;\n\t    Numbers['approxEquals'] = approxEquals;\n\t    Numbers['greaterThanOrEqual'] = greaterThanOrEqual;\n\t    Numbers['lessThanOrEqual'] = lessThanOrEqual;\n\t    Numbers['greaterThan'] = greaterThan;\n\t    Numbers['lessThan'] = lessThan;\n\t    Numbers['expt'] = expt;\n\t    Numbers['exp'] = exp;\n\t    Numbers['modulo'] = modulo;\n\t    Numbers['numerator'] = numerator;\n\t    Numbers['denominator'] = denominator;\n\t    Numbers['integerSqrt'] = integerSqrt;\n\t    Numbers['sqrt'] = sqrt;\n\t    Numbers['abs'] = abs;\n\t    Numbers['quotient'] = quotient;\n\t    Numbers['remainder'] = remainder;\n\t    Numbers['floor'] = floor;\n\t    Numbers['ceiling'] = ceiling;\n\t    Numbers['conjugate'] = conjugate;\n\t    Numbers['magnitude'] = magnitude;\n\t    Numbers['log'] = log;\n\t    Numbers['angle'] = angle;\n\t    Numbers['tan'] = tan;\n\t    Numbers['atan'] = atan;\n\t    Numbers['cos'] = cos;\n\t    Numbers['sin'] = sin;\n\t    Numbers['tan'] = tan;\n\t    Numbers['acos'] = acos;\n\t    Numbers['asin'] = asin;\n\t    Numbers['cosh'] = cosh;\n\t    Numbers['sinh'] = sinh;\n\t    Numbers['imaginaryPart'] = imaginaryPart;\n\t    Numbers['realPart'] = realPart;\n\t    Numbers['round'] = round;\n\t    Numbers['sqr'] = sqr;\n\t    Numbers['gcd'] = gcd;\n\t    Numbers['lcm'] = lcm;\n\t\n\t    Numbers['toRepeatingDecimal'] = toRepeatingDecimal;\n\t\n\t\n\t\n\t    // The following exposes the class representations for easier\n\t    // integration with other projects.\n\t    Numbers['BigInteger'] = BigInteger;\n\t    Numbers['Rational'] = Rational;\n\t    Numbers['FloatPoint'] = FloatPoint;\n\t    Numbers['Complex'] = Complex;   \n\t\n\t    Numbers['MIN_FIXNUM'] = MIN_FIXNUM;\n\t    Numbers['MAX_FIXNUM'] = MAX_FIXNUM;\n\t\n\t})();\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t\r\n\t/**\r\n\t * Copyright 2009 Tim Down.\r\n\t *\r\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n\t * you may not use this file except in compliance with the License.\r\n\t * You may obtain a copy of the License at\r\n\t *\r\n\t *      http://www.apache.org/licenses/LICENSE-2.0\r\n\t *\r\n\t * Unless required by applicable law or agreed to in writing, software\r\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\t * See the License for the specific language governing permissions and\r\n\t * limitations under the License.\r\n\t */\r\n\t\r\n\t\r\n\t//     *\r\n\t//       void put(Object key, Object value)\r\n\t\r\n\t//       Sets the value associated with the key supplied. If the hash table already contains the key then the old value is overwritten.\r\n\t//     *\r\n\t//       void get(Object key)\r\n\t\r\n\t//       Returns the value associated with the key supplied, or null if no value is found for that key.\r\n\t//     *\r\n\t//       Boolean containsKey(Object key)\r\n\t\r\n\t//       Returns whether the hash table contains the specified key.\r\n\t//     *\r\n\t//       Boolean containsValue(Object value)\r\n\t\r\n\t//       Returns whether the hash table contains the specified value.\r\n\t//     *\r\n\t//       void clear()\r\n\t\r\n\t//       Removes all entries from the hash table.\r\n\t//     *\r\n\t//       Boolean isEmpty()\r\n\t\r\n\t//       Returns true if the hash table contains no key/value pairs.\r\n\t//     *\r\n\t//       Array keys()\r\n\t\r\n\t//       Returns an array containing all the keys contained in the hash table.\r\n\t//     *\r\n\t//       Array values()\r\n\t\r\n\t//       Returns an array containing all the values contained in the hash table.\r\n\t//     *\r\n\t//       void remove(Object key)\r\n\t\r\n\t//       Removes the key and its corresponding value from the hash table.\r\n\t//     *\r\n\t//       Number size()\r\n\t\r\n\t//       Returns the number of key/value pairs contained in the hash table.\r\n\t\r\n\t\r\n\tvar _Hashtable=(function(){function _1(_2){return(typeof _2===\"undefined\");};function _3(_4){return(typeof _4===\"function\");};function _5(_6){return(typeof _6===\"string\");};function _7(_8,_9){return _3(_8[_9]);};function _a(_b){return _7(_b,\"equals\");};function _c(_d){return _7(_d,\"hashCode\");};function _e(_f){if(_5(_f)){return _f;}else{if(_c(_f)){var _10=_f.hashCode();if(!_5(_10)){return _e(_10);}\r\n\treturn _10;}else{if(_7(_f,\"toString\")){return _f.toString();}else{return String(_f);}}}};function _11(_12,_13){return _12.equals(_13);};function _14(_15,_16){if(_a(_16)){return _16.equals(_15);}else{return _15===_16;}};function _17(o1,o2){return o1===o2;};function _1a(arr,_1c,_1d,_1e,_1f){var _20;for(var i=0,len=arr.length;i<len;i++){_20=arr[i];if(_1f(_1c,_1d(_20))){return _1e?[i,_20]:true;}}\r\n\treturn false;};function _23(arr,idx){if(_7(arr,\"splice\")){arr.splice(idx,1);}else{if(idx===arr.length-1){arr.length=idx;}else{var _26=arr.slice(idx+1);arr.length=idx;for(var i=0,len=_26.length;i<len;i++){arr[idx+i]=_26[i];}}}};function _29(kv,_2b){if(kv===null){throw new Error(\"null is not a valid \"+_2b);}else{if(_1(kv)){throw new Error(_2b+\" must not be undefined\");}}};var _2c=\"key\",_2d=\"value\";function _2e(key){_29(key,_2c);};function _30(_31){_29(_31,_2d);};function _32(_33,_34,_35){this.entries=[];this.addEntry(_33,_34);if(_35!==null){this.getEqualityFunction=function(){return _35;};}};function _36(_37){return _37[0];};function _38(_39){return _39[1];};_32.prototype={getEqualityFunction:function(_3a){if(_a(_3a)){return _11;}else{return _14;}},searchForEntry:function(key){return _1a(this.entries,key,_36,true,this.getEqualityFunction(key));},getEntryForKey:function(key){return this.searchForEntry(key)[1];},getEntryIndexForKey:function(key){return this.searchForEntry(key)[0];},removeEntryForKey:function(key){var _3f=this.searchForEntry(key);if(_3f){_23(this.entries,_3f[0]);return true;}\r\n\treturn false;},addEntry:function(key,_41){this.entries[this.entries.length]=[key,_41];},size:function(){return this.entries.length;},keys:function(_42){var _43=_42.length;for(var i=0,len=this.entries.length;i<len;i++){_42[_43+i]=this.entries[i][0];}},values:function(_46){var _47=_46.length;for(var i=0,len=this.entries.length;i<len;i++){_46[_47+i]=this.entries[i][1];}},containsKey:function(key){return _1a(this.entries,key,_36,false,this.getEqualityFunction(key));},containsValue:function(_4b){return _1a(this.entries,_4b,_38,false,_17);}};function _4c(){};_4c.prototype=[];function _4d(_4e){return _4e[0];};function _4f(_50,_51,_52){return _1a(_50,_51,_4d,true,_52);};function _53(_54,_55){var _56=_54[_55];if(_56&&(_56 instanceof _4c)){return _56[1];}\r\n\treturn null;};function _57(_58,_59){var _5a=[];var _5b={};_58=_3(_58)?_58:_e;_59=_3(_59)?_59:null;this.put=function(key,_5d){_2e(key);_30(_5d);var _5e=_58(key);var _5f=_53(_5b,_5e);if(_5f){var _60=_5f.getEntryForKey(key);if(_60){_60[1]=_5d;}else{_5f.addEntry(key,_5d);}}else{var _61=new _4c();_61[0]=_5e;_61[1]=new _32(key,_5d,_59);_5a[_5a.length]=_61;_5b[_5e]=_61;}};this.get=function(key){_2e(key);var _63=_58(key);var _64=_53(_5b,_63);if(_64){var _65=_64.getEntryForKey(key);if(_65){return _65[1];}}\r\n\treturn null;};this.containsKey=function(key){_2e(key);var _67=_58(key);var _68=_53(_5b,_67);if(_68){return _68.containsKey(key);}\r\n\treturn false;};this.containsValue=function(_69){_30(_69);for(var i=0,len=_5a.length;i<len;i++){if(_5a[i][1].containsValue(_69)){return true;}}\r\n\treturn false;};this.clear=function(){_5a.length=0;_5b={};};this.isEmpty=function(){return _5a.length===0;};this.keys=function(){var _6c=[];for(var i=0,len=_5a.length;i<len;i++){_5a[i][1].keys(_6c);}\r\n\treturn _6c;};this.values=function(){var _6f=[];for(var i=0,len=_5a.length;i<len;i++){_5a[i][1].values(_6f);}\r\n\treturn _6f;};this.remove=function(key){_2e(key);var _73=_58(key);var _74=_53(_5b,_73);if(_74){if(_74.removeEntryForKey(key)){if(_74.size()===0){var _75=_4f(_5a,_73,_74.getEqualityFunction(key));_23(_5a,_75[0]);delete _5b[_73];}}}};this.size=function(){var _76=0;for(var i=0,len=_5a.length;i<len;i++){_76+=_5a[i][1].size();}\r\n\treturn _76;};};return _57;})();\r\n\t\r\n\tmodule.exports = _Hashtable;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t// if not defined, declare the compiler object as part of plt\n\twindow.plt   = window.plt   || {};\n\tplt.compiler = __webpack_require__(2);\n\tvar types = __webpack_require__(3);\n\t\n\t/*\n\t \n\t //////////////////////////////////////////////////////////////////////////////\n\t ///////////////////////////////// PARSER OBJECT //////////////////////////////\n\t //////////////////////////////////////////////////////////////////////////////\n\t \n\t Parser for http://docs.racket-lang.org/htdp-langs/intermediate-lam.html\n\t \n\t * Given an Array of SExps, produce an array of Programs or a structured error\n\t * see structures.js for Program Objects and Error throwing\n\t \n\t TODO\n\t - Perf: give location information to all AST nodes as constructor argument\n\t - JSLint\n\t */\n\t\n\t(function () {\n\t 'use strict';\n\t \n\t // import frequently-used bindings\n\t var literal          = plt.compiler.literal;\n\t var symbolExpr       = plt.compiler.symbolExpr;\n\t var Program          = plt.compiler.Program;\n\t var couple           = plt.compiler.couple;\n\t var ifExpr           = plt.compiler.ifExpr;\n\t var beginExpr        = plt.compiler.beginExpr;\n\t var letExpr          = plt.compiler.letExpr;\n\t var letStarExpr      = plt.compiler.letStarExpr;\n\t var letrecExpr       = plt.compiler.letrecExpr;\n\t var localExpr        = plt.compiler.localExpr;\n\t var andExpr          = plt.compiler.andExpr;\n\t var orExpr           = plt.compiler.orExpr;\n\t var condExpr         = plt.compiler.condExpr;\n\t var caseExpr         = plt.compiler.caseExpr;\n\t var lambdaExpr       = plt.compiler.lambdaExpr;\n\t var quotedExpr       = plt.compiler.quotedExpr;\n\t var unquotedExpr     = plt.compiler.unquotedExpr;\n\t var quasiquotedExpr  = plt.compiler.quasiquotedExpr;\n\t var unquoteSplice    = plt.compiler.unquoteSplice;\n\t var callExpr         = plt.compiler.callExpr;\n\t var whenUnlessExpr   = plt.compiler.whenUnlessExpr;\n\t var defFunc          = plt.compiler.defFunc;\n\t var defVar           = plt.compiler.defVar;\n\t var defVars          = plt.compiler.defVars;\n\t var defStruct        = plt.compiler.defStruct;\n\t var requireExpr      = plt.compiler.requireExpr;\n\t var provideStatement = plt.compiler.provideStatement;\n\t var unsupportedExpr  = plt.compiler.unsupportedExpr;\n\t var throwError       = plt.compiler.throwError;\n\t \n\t //////////////////////////////////// UTILITY FUNCTIONS //////////////////////////////\n\t function isVector(x) { return types.isVector(x.val); }\n\t function isString(x) { return types.isString(x.val); }\n\t function isSymbol(x) { return x instanceof symbolExpr; }\n\t function isLiteral(x){ return x instanceof literal; }\n\t function isUnsupported(x){ return x instanceof unsupportedExpr;}\n\t \n\t // isSymbolEqualTo : symbolExpr symbolExpr -> Boolean\n\t // are these all symbols of the same value?\n\t function isSymbolEqualTo(x, y) {\n\t    x = (x instanceof symbolExpr)? x.val : x;\n\t    y = (y instanceof symbolExpr)? y.val : y;\n\t    return x === y;\n\t }\n\t \n\t function isCons(x)  { return x instanceof Array && x.length>=1;}\n\t function rest(ls)   { return ls.slice(1); }\n\t \n\t  // PARSING ///////////////////////////////////////////\n\t \n\t   // parse* : sexp list -> Program list\n\t  function parseStar(sexps) {\n\t   function parseSExp(sexp) {\n\t     return isDefinition(sexp) ? parseDefinition(sexp) :\n\t     isExpr(sexp) ? parseExpr(sexp) :\n\t     isRequire(sexp) ? parseRequire(sexp) :\n\t     isProvide(sexp) ? parseProvide(sexp) :\n\t     throwError(new types.Message([\"Not a Definition, Expression, Library Require, or Provide\"]),\n\t                                  sexp.location);\n\t    }\n\t    return sexps.map(parseSExp);\n\t  }\n\t \n\t  // parse : sexp list -> Program list\n\t  function parse(sexp) {\n\t    return (sexp.length === 0) ? [] :\n\t    (!isCons(sexp)) ? throwError(new types.Message([\"The sexp is not a list of definitions or expressions: \"+sexp]),\n\t                                sexp.location):\n\t    parseStar(sexp);\n\t  }\n\t\n\t\n\t  //////////////////////////////////////// DEFINITION PARSING ////////////////////////////////\n\t  // (define-struct ...)\n\t  function isStructDefinition(sexp) {\n\t    return ((isCons(sexp)) && (isSymbol(sexp[0])) && (isSymbolEqualTo(\"define-struct\", sexp[0])));\n\t  }\n\t  // (define ...)\n\t  function isValueDefinition(sexp) {\n\t    return (isCons(sexp) && isSymbol(sexp[0]) && isSymbolEqualTo(\"define\", sexp[0]));\n\t  }\n\t  // (define-values ...)\n\t  function isMultiValueDefinition(sexp) {\n\t    return (isCons(sexp) && isSymbol(sexp[0]) && isSymbolEqualTo(\"define-values\", sexp[0]));\n\t  }\n\t  // is it any kind of definition?\n\t  function isDefinition(sexp) {\n\t    return isStructDefinition(sexp) || isValueDefinition(sexp) || isMultiValueDefinition(sexp);\n\t  }\n\t \n\t  // : parseDefinition : SExp -> AST (definition)\n\t  function parseDefinition(sexp) {\n\t    function parseDefStruct(sexp) {\n\t      // is it just (define-struct)?\n\t      if(sexp.length < 2){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected the structure name after define-struct, but nothing's there\"])\n\t                   , sexp.location);\n\t      }\n\t      // is the structure name there?\n\t      if(!(sexp[1] instanceof symbolExpr)){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected the structure name after define-struct, but found \"\n\t                                      , new types.ColoredPart(\"something else\", sexp[1].location)])\n\t                   , sexp.location);\n\t      }\n\t      // is it just (define-struct <name>)?\n\t      if(sexp.length < 3){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected at least one field name (in parentheses) after the \"\n\t                                      , new types.ColoredPart(\"structure name\", sexp[1].location)\n\t                                      , \", but nothing's there\"])\n\t                   , sexp.location);\n\t      }\n\t      // is the structure name followed by a list?\n\t      if(!(sexp[2] instanceof Array)){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected at least one field name (in parentheses) after the \"\n\t                                      , new types.ColoredPart(\"structure name\", sexp[1].location)\n\t                                      , \", but found \"\n\t                                      , new types.ColoredPart(\"something else\", sexp[2].location)])\n\t                   , sexp.location);\n\t      }\n\t      // is it a list of not-all-symbols?\n\t      sexp[2].forEach(function(arg){\n\t        if (!(arg instanceof symbolExpr)){\n\t          throwError(new types.Message([new types.ColoredPart(sexp[0]. val,sexp[0].location)\n\t                                      , \": expected a field name, but found \"\n\t                                      , new types.ColoredPart(\"something else\", arg.location)])\n\t                   , sexp.location);\n\t        }\n\t      });\n\t      // too many expressions?\n\t      if(sexp.length > 3){\n\t          var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n\t              wording1 = (sexp[2].length === 1)? \"field name\" : \"field names\",\n\t              wording2 = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n\t          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected nothing after the \"\n\t                                      , new types.ColoredPart(wording1, sexp[2].location)\n\t                                      , \", but found \"\n\t                                      , new types.MultiPart(wording2, extraLocs, false)])\n\t                     , sexp.location);\n\t      }\n\t      return new defStruct(parseIdExpr(sexp[1]), sexp[2].map(parseIdExpr), sexp);\n\t    }\n\t    function parseMultiDef(sexp){\n\t      // is it just (define-values)?\n\t      if(sexp.length < 2){\n\t          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expects a list of variables and a body, but found neither\"])\n\t                     , sexp.location);\n\t      }\n\t      // is it just (define-values ... )?\n\t      if(sexp.length < 3){\n\t          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expects a list of variables and a body, but found only \"\n\t                                      , new types.ColoredPart(\"one part\", sexp[1].location)])\n\t                     , sexp.location);\n\t      }\n\t      // is it (define-values <not a list> )?\n\t      if(!(sexp[1] instanceof Array)){\n\t          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expects a list of variables and a body, but found \"\n\t                                      , new types.ColoredPart(\"something else\", sexp[1].location)])\n\t                     , sexp.location);\n\t      }\n\t      // too many parts?\n\t      if(sexp.length > 3){\n\t          var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n\t              wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\"),\n\t              msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                       , \": expects a list of variables and a body\"\n\t                                        + \", but found \"\n\t                                       , new types.MultiPart(wording, extraLocs, false)]);\n\t          throwError(msg, sexp.location);\n\t      }\n\t      return new defVars(sexp[1].map(parseIdExpr), parseExpr(sexp[2]), sexp);\n\t    }\n\t    function parseDef(sexp) {\n\t      // is it just (define)?\n\t      if(sexp.length < 2){\n\t          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a variable, or a function name and its variables \"\n\t                                      + \"(in parentheses), after define, but nothing's there\"])\n\t                     , sexp.location);\n\t      }\n\t      // If it's (define (...)...)\n\t      if(sexp[1] instanceof Array){\n\t          // is there at least one element?\n\t          if(sexp[1].length === 0){\n\t            throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a name for the function within \"\n\t                                      , new types.ColoredPart(\"the parentheses\", sexp[1].location)])\n\t                       , sexp.location);\n\t          }\n\t          // is the first element in the list a symbol?\n\t          if(!(sexp[1][0] instanceof symbolExpr)){\n\t            throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a function name after the open parenthesis but found \"\n\t                                      , new types.ColoredPart(\"something else\", sexp[1][0].location)])\n\t                       , sexp.location);\n\t          }\n\t          // is the next element a list of not-all-symbols?\n\t          sexp[1].forEach(function(arg){\n\t            if (!(arg instanceof symbolExpr)){\n\t              throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a variable but found \"\n\t                                      , new types.ColoredPart(\"something else\", arg.location)])\n\t                         , sexp.location);\n\t            }\n\t          });\n\t          // is it just (define (<name> <args>))?\n\t          if(sexp.length < 3){\n\t              throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                            , \": expected an expression for the function body, but nothing's there\"])\n\t                         , sexp.location);\n\t          }\n\t          // too many parts?\n\t          if(sexp.length > 3){\n\t              var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n\t                  wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n\t              throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                            , \": expected only one expression for the function body\"\n\t                                            + \", but found \"\n\t                                            , new types.MultiPart(wording, extraLocs, false)])\n\t                         , sexp.location);\n\t          }\n\t          var args = rest(sexp[1]).map(parseIdExpr);\n\t          args.location = sexp[1].location;\n\t          return new defFunc(parseIdExpr(sexp[1][0]), args, parseExpr(sexp[2]), sexp);\n\t      }\n\t      // If it's (define x ...)\n\t      if(sexp[1] instanceof symbolExpr){\n\t          // is it just (define x)?\n\t          if(sexp.length < 3){\n\t              throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                            , \": expected an expression after the variable \"\n\t                                            , new types.ColoredPart(sexp[1].val, sexp[1].location)\n\t                                            , \" but nothing's there\"])\n\t                         , sexp.location);\n\t          }\n\t          // too many parts?\n\t          if(sexp.length > 3){\n\t              var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n\t                  wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n\t              throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                            , \": expected only one expression after the variable \"\n\t                                            , new types.ColoredPart(sexp[1].val, sexp[1].location)\n\t                                            , \", but found \"\n\t                                            , new types.MultiPart(wording, extraLocs, false)])\n\t                         , sexp.location);\n\t          }\n\t          return new defVar(parseIdExpr(sexp[1]), parseExpr(sexp[2]), sexp);\n\t      }\n\t      // If it's (define <invalid> ...)\n\t      throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                    , \": expected a variable but found \"\n\t                                    , new types.ColoredPart(\"something else\", sexp[1].location)])\n\t                         , sexp.location);\n\t    }\n\t    var def = isStructDefinition(sexp) ? parseDefStruct(sexp) :\n\t              isValueDefinition(sexp)  ? parseDef(sexp) :\n\t              isMultiValueDefinition   ? parseMultiDef(sexp) :\n\t              throwError(new types.Message([\": expected to find a definition, but found: \"+ sexp]),\n\t                         sexp.location);\n\t    def.location = sexp.location;\n\t   return def;\n\t  }\n\t\n\t\n\t  //////////////////////////////////////// EXPRESSION PARSING ////////////////////////////////\n\t  function isExpr(sexp) {\n\t    return ((!(isDefinition(sexp))) && (!(isRequire(sexp))) && (!(isProvide(sexp))));\n\t  }\n\t\n\t  function parseExpr(sexp) {\n\t    return isCons(sexp) ? parseExprList(sexp) :\n\t    parseExprSingleton(sexp);\n\t  }\n\t\n\t  // parseExprList : SExp -> AST\n\t  // predicates and parsers for call, lambda, local, letrec, let, let*, if, and, or, quote and quasiquote exprs\n\t  function parseExprList(sexp) {\n\t    function parseFuncCall(sexp) {\n\t      if(isSymbolEqualTo(sexp[0], \"unquote\")){\n\t        throwError(new types.Message([\"misuse of a comma or 'unquote, not under a quasiquoting backquote\"])\n\t                   , sexp.location\n\t                   , \"Error-GenericSyntacticError\");\n\t      }\n\t      if(isSymbolEqualTo(sexp[0], \"unquote-splicing\")){\n\t        throwError(new types.Message([\"misuse of a ,@ or unquote-splicing, not under a quasiquoting backquote\"])\n\t                   , sexp.location\n\t                   , \"Error-GenericSyntacticError\");\n\t      }\n\t      if(isSymbolEqualTo(sexp[0], \"else\")){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp.location)\n\t                                      , \": not allowed \"\n\t                                      , new types.ColoredPart(\"here\", sexp.location)\n\t                                      , \", because this is not a question in a clause\"])\n\t                   , sexp.location);\n\t      }\n\t      return isCons(sexp)? new callExpr(parseExpr(sexp[0]), rest(sexp).map(parseExpr), sexp[0]) :\n\t                            throwError(new types.Message([\"function call sexp\"]), sexp.location);\n\t    }\n\t    function parseLambdaExpr(sexp) {\n\t      // is it just (lambda)?\n\t      if(sexp.length === 1){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected at least one variable (in parentheses) after lambda, but nothing's there\"]),\n\t                    sexp.location);\n\t      }\n\t      // is it just (lambda <not-list>)?\n\t      if(!(sexp[1] instanceof Array)){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected at least one variable (in parentheses) after lambda, but found \"\n\t                                      , new types.ColoredPart(\"something else\", sexp[1].location)]),\n\t                    sexp.location);\n\t      }\n\t      // is it a list of not-all-symbols?\n\t      sexp[1].forEach(function(arg){\n\t        if (!(arg instanceof symbolExpr)){\n\t          var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                       , \": expected a list of variables after lambda, but found \"\n\t                                       , new types.ColoredPart(\"something else\", arg.location)]);\n\t          throwError(msg, sexp.location);\n\t        }\n\t      });\n\t      // is it just (lambda (x))?\n\t      if(sexp.length === 2){\n\t          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                        , \": expected an expression for the function body, but nothing's there\"]),\n\t                    sexp.location);\n\t      }\n\t      // too many expressions?\n\t      if(sexp.length > 3){\n\t        var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n\t            wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\"),\n\t            msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected only one expression for the function body, but found \"\n\t                                     , new types.MultiPart(wording, extraLocs, false)]);\n\t        throwError(msg, sexp.location);\n\t      }\n\t      var args = sexp[1].map(parseIdExpr);\n\t      args.location = sexp[1].location;\n\t      return new lambdaExpr(args, parseExpr(sexp[2]), sexp[0]);\n\t    }\n\t    function parseLocalExpr(sexp) {\n\t      // is it just (local)?\n\t      if(sexp.length === 1){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                        , \": expected at least one definition (in square brackets) after local,\"\n\t                                        + \" but nothing's there\"]),\n\t                    sexp.location);\n\t      }\n\t      // is it just (local <not-list>)?\n\t      if(!(sexp[1] instanceof Array)){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                        , \": expected a collection of definitions, but given \"\n\t                                        , new types.ColoredPart(\"something else\", sexp[1].location)]),\n\t                    sexp[1].location);\n\t      }\n\t      // is it a list of not-all-definitions?\n\t      sexp[1].forEach(function(def){\n\t        if (!isDefinition(def)){\n\t          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                        , \": expected a definition, but given \"\n\t                                        , new types.ColoredPart(\"something else\", def.location)]),\n\t                     def.location);\n\t        }\n\t      });\n\t      // is it just (local [...defs...] ))?\n\t      if(sexp.length === 2){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a single body, but found none\"]),\n\t                     sexp.location);\n\t      }\n\t      // too many expressions?\n\t      if(sexp.length > 3){\n\t        var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n\t            wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a single body, but found \"\n\t                                      , new types.MultiPart(wording, extraLocs, false)]),\n\t                     sexp.location);\n\t      }\n\t      return new localExpr(sexp[1].map(parseDefinition), parseExpr(sexp[2]), sexp[0]);\n\t    }\n\t    function parseLetrecExpr(sexp) {\n\t      // is it just (letrec)?\n\t      if(sexp.length < 3){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected an expression after the bindings, but nothing's there\"]),\n\t                     sexp.location);\n\t      }\n\t      // is it just (letrec <not-list>)?\n\t      if(!(sexp[1] instanceof Array)){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a key/value pair, but given \"\n\t                                      , new types.ColoredPart(\"something else\", sexp[1].location)]),\n\t                     sexp.location);\n\t      }\n\t      // is it a list of not-all-bindings?\n\t      sexp[1].forEach(function(binding){\n\t        if (!sexpIsCouple(binding)){\n\t          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                        , \": expected a key/value pair, but given \"\n\t                                        , new types.ColoredPart(\"something else\", binding.location)]),\n\t                     binding.location);\n\t        }\n\t      });\n\t      // is it just (letrec (...bindings...) ))?\n\t      if(sexp.length === 2){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected an expression after the bindings, but nothing's there\"]),\n\t                     sexp.location);\n\t      }\n\t      // too many expressions?\n\t      if(sexp.length > 3){\n\t        var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n\t            wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a single body, but found \"\n\t                                      , new types.MultiPart(wording, extraLocs, false)]),\n\t                     sexp.location);\n\t      }\n\t      return new letrecExpr(sexp[1].map(parseBinding), parseExpr(sexp[2]), sexp[0]);\n\t    }\n\t    function parseLetExpr(sexp) {\n\t      // is it just (let)?\n\t      if(sexp.length === 1){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected at least one binding (in parentheses) after let, but nothing's there\"]),\n\t                     sexp.location);\n\t      }\n\t      // is it just (let <not-list>)?\n\t      if(!(sexp[1] instanceof Array)){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected sequence of key value pairs, but given \"\n\t                                      , new types.ColoredPart(\"something else\", sexp[1].location)]),\n\t                     sexp[1].location);\n\t      }\n\t      // is it a list of not-all-bindings?\n\t      sexp[1].forEach(function(binding){\n\t        if (!sexpIsCouple(binding)){\n\t          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                        , \": expected a key/value pair, but given \"\n\t                                      , new types.ColoredPart(\"something else\", binding.location)]),\n\t                     binding.location);\n\t        }\n\t      });\n\t      // too many expressions?\n\t      if(sexp.length > 3){\n\t        var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n\t            wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a single body, but found \"\n\t                                      , new types.MultiPart(wording, extraLocs, false)]),\n\t                     sexp.location);\n\t      }\n\t      // is it just (let (...bindings...) ))?\n\t      if(sexp.length === 2){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a single body, but found none\"]),\n\t                     sexp.location);\n\t      }\n\t      return new letExpr(sexp[1].map(parseBinding), parseExpr(sexp[2]), sexp);\n\t    }\n\t    function parseLetStarExpr(sexp) {\n\t      // is it just (let*)?\n\t      if(sexp.length === 1){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected an expression after the bindings, but nothing's there\"]),\n\t                     sexp.location);\n\t      }\n\t      // is it just (let* <not-list>)?\n\t      if(!(sexp[1] instanceof Array)){\n\t        var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                     , \": expected sequence of key/value pairs, but given \"\n\t                                     , new types.ColoredPart(\"something else\", sexp[1].location)]);\n\t        throwError(msg, sexp.location);\n\t      }\n\t      // is it a list of not-all-bindings?\n\t      sexp[1].forEach(function(binding){\n\t        if (!sexpIsCouple(binding)){\n\t          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a key/value pair, but given \"\n\t                                      , new types.ColoredPart(\"something else\", binding.location)]),\n\t                     binding.location);\n\t        }\n\t      });\n\t      // is it just (let* (...bindings...) ))?\n\t      if(sexp.length === 2){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a single body, but found none\"]),\n\t                     sexp.location);\n\t      }\n\t      // too many expressions?\n\t      if(sexp.length > 3){\n\t        var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n\t            wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a single body, but found \"\n\t                                      , new types.MultiPart(wording, extraLocs, false)]),\n\t                    sexp.location);\n\t      }\n\t      var bindings = sexp[1].map(parseBinding);\n\t      bindings.location = sexp[1].location;\n\t      return new letStarExpr(bindings, parseExpr(sexp[2]), sexp[0]);\n\t    }\n\t    function parseIfExpr(sexp) {\n\t      // Does it have too few parts?\n\t      if(sexp.length < 4){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a test, a consequence, and an alternative, but all three were not found\"]),\n\t                    sexp.location);\n\t      }\n\t      // Does it have too many parts?\n\t      if(sexp.length > 4){\n\t        var extraLocs = sexp.slice(1).map(function(sexp){ return sexp.location; });\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected only a test, a consequence, and an alternative, \"\n\t                                      , \"but found \"\n\t                                      , new types.MultiPart(\"more than three of these\", extraLocs, false)]),\n\t                    sexp.location);\n\t      }\n\t      return new ifExpr(parseExpr(sexp[1]), parseExpr(sexp[2]), parseExpr(sexp[3]), sexp[0]);\n\t    }\n\t    function parseBeginExpr(sexp) {\n\t      // is it just (begin)?\n\t      if(sexp.length < 2){\n\t        var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                     , \": Inside a begin, expected to find a body, but nothing was found.\"]);\n\t        throwError(msg, sexp.location);\n\t      }\n\t      return new beginExpr(rest(sexp).map(parseExpr), sexp[0]);\n\t    }\n\t    function parseAndExpr(sexp) {\n\t      // and must have 2+ arguments\n\t      if(sexp.length < 3){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected at least 2 arguments, but given \"\n\t                                      , (sexp.length===1)? \"0\" : new types.ColoredPart((sexp.length-1).toString(),\n\t                                                                                       sexp[1].location)]),\n\t                    sexp.location);\n\t      }\n\t      return new andExpr(rest(sexp).map(parseExpr), sexp[0]);\n\t    }\n\t    function parseOrExpr(sexp) {\n\t      // or must have 2+ arguments\n\t      if(sexp.length < 3){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected at least 2 arguments, but given \"\n\t                                      , (sexp.length===1)? \"0\" : new types.ColoredPart((sexp.length-1).toString(),\n\t                                                                                       sexp[1].location)]),\n\t                    sexp.location);\n\t      }\n\t      var orEx = new orExpr(rest(sexp).map(parseExpr), sexp[0]);\n\t      return orEx;\n\t    }\n\t    function parseQuotedExpr(sexp) {\n\t\n\t      function parseQuotedItem(sexp) {\n\t        return isCons(sexp) ? sexp.map(parseQuotedItem)\n\t          :  (sexp instanceof Array && sexp.length === 0)? sexp // the empty list is allowed inside quotes\n\t          : /* else */ parseExprSingleton(sexp);\n\t      }\n\t      // quote must have exactly one argument\n\t      if(sexp.length < 2){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a single argument, but did not find one.\"]),\n\t                    sexp.location);\n\t      }\n\t      if(sexp.length > 2){\n\t        var extraLocs = sexp.slice(1).map(function(sexp){ return sexp.location; });\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a single argument, but found \"\n\t                                      , new types.MultiPart(\"more than one.\", extraLocs, false)]),\n\t                    sexp.location);\n\t      }\n\t      return new quotedExpr(parseQuotedItem(sexp[1]));\n\t    }\n\t\n\t    return (function () {\n\t        var peek = sexp[0];\n\t        var expr = !(isSymbol(peek)) ? parseFuncCall(sexp) :\n\t                    isSymbolEqualTo(\"λ\", peek)       ? parseLambdaExpr(sexp) :\n\t                    isSymbolEqualTo(\"lambda\", peek)  ? parseLambdaExpr(sexp) :\n\t                    isSymbolEqualTo(\"local\", peek)   ? parseLocalExpr(sexp) :\n\t                    isSymbolEqualTo(\"letrec\", peek)  ? parseLetrecExpr(sexp) :\n\t                    isSymbolEqualTo(\"let\", peek)     ? parseLetExpr(sexp) :\n\t                    isSymbolEqualTo(\"let*\", peek)    ? parseLetStarExpr(sexp) :\n\t                    isSymbolEqualTo(\"cond\", peek)    ? parseCondExpr(sexp) :\n\t                    isSymbolEqualTo(\"case\", peek)    ? parseCaseExpr(sexp) :\n\t                    isSymbolEqualTo(\"if\", peek)      ? parseIfExpr(sexp) :\n\t                    isSymbolEqualTo(\"begin\", peek)   ? parseBeginExpr(sexp) :\n\t                    isSymbolEqualTo(\"and\", peek)     ? parseAndExpr(sexp) :\n\t                    isSymbolEqualTo(\"or\", peek)      ? parseOrExpr(sexp) :\n\t                    isSymbolEqualTo(\"when\", peek)    ? parseWhenUnlessExpr(sexp) :\n\t                    isSymbolEqualTo(\"unless\", peek)  ? parseWhenUnlessExpr(sexp) :\n\t                    isSymbolEqualTo(\"quote\", peek)   ? parseQuotedExpr(sexp) :\n\t                    isSymbolEqualTo(\"quasiquote\", peek)       ? parseQuasiQuotedExpr(sexp) :\n\t                    isSymbolEqualTo(\"unquote\", peek)          ? parseUnquoteExpr(sexp) :\n\t                    isSymbolEqualTo(\"unquote-splicing\", peek) ? parseUnquoteSplicingExpr(sexp) :\n\t                    parseFuncCall(sexp);\n\t          expr.location = sexp.location;\n\t          return expr;\n\t   })();\n\t  }\n\t \n\t  function parseWhenUnlessExpr(sexp){\n\t    // is it just (when)?\n\t    if(sexp.length < 3){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected at a test and at least one result after \"+sexp[0]+\", but nothing's there\"]),\n\t                    sexp.location);\n\t    }\n\t    var exprs = sexp.slice(2), result = new whenUnlessExpr(parseExpr(sexp[1]), parse(exprs), sexp[0]);\n\t    exprs.location = exprs[0].location; // FIXME: merge the locations\n\t    result.location = sexp.location;\n\t    return result;\n\t  }\n\t\n\t  function parseCondExpr(sexp) {\n\t    // is it just (cond)?\n\t    if(sexp.length === 1){\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected at least one clause after cond, but nothing's there\"]),\n\t                    sexp.location);\n\t    }\n\t    var condLocs = [sexp[0].location, sexp.location.start(), sexp.location.end()];\n\t \n\t    function isElseClause(couple){ return isSymbol(couple[0]) && isSymbolEqualTo(couple[0], \"else\"); }\n\t \n\t    function checkCondCouple(clause) {\n\t      var clauseLocations = [clause.location.start(), clause.location.end()];\n\t      // is it (cond ...<not-a-clause>..)?\n\t      if(!(clause instanceof Array)){\n\t        throwError(new types.Message([new types.MultiPart(sexp[0].val, condLocs, true)\n\t                                      , \": expected a clause with a question and an answer, but found \"\n\t                                      , new types.ColoredPart(\"something else\", clause.location)]),\n\t                    clause.location);\n\t      }\n\t      if(clause.length === 0){\n\t        throwError(new types.Message([new types.MultiPart(sexp[0].val, condLocs, true)\n\t                                      , \": expected a clause with a question and an answer, but found an \"\n\t                                      , new types.MultiPart(\"empty part\", clauseLocations, true)]),\n\t                    clause.location);\n\t      }\n\t      if(clause.length === 1){\n\t        throwError(new types.Message([new types.MultiPart(sexp[0].val, condLocs, true)\n\t                                      , \": expected a clause with a question and an answer, but found a \"\n\t                                      , new types.MultiPart(\"clause\", clauseLocations, true)\n\t                                      , \" with only \"\n\t                                      , new types.MultiPart(\"one part\", [clause[0].location], false)]),\n\t                    clause.location);\n\t      }\n\t      if(clause.length > 2){\n\t        var extraLocs = clause.map(function(sexp){ return sexp.location; }),\n\t            wording = extraLocs.length+\" parts\";\n\t        throwError(new types.Message([new types.MultiPart(sexp[0].val, condLocs, true)\n\t                                      , \": expected a clause with a question and an answer, but found \"\n\t                                      , new types.MultiPart(\"a clause\", clauseLocations, true)\n\t                                      , \" with \"\n\t                                      , new types.MultiPart(wording, extraLocs, false)]),\n\t                    clause.location);\n\t      }\n\t    }\n\t \n\t \n\t    function parseCondCouple(clause) {\n\t        var test = parseExpr(clause[0]), result = parseExpr(clause[1]), cpl = new couple(test, result);\n\t        // the only un-parenthesized keyword allowed in the first slot is 'else'\n\t        if((plt.compiler.keywords.indexOf(test.val) > -1) && (test.val !== \"else\")){\n\t          throwError(new types.Message([new types.ColoredPart(test.val, test.location)\n\t                                        , \": expected an open parenthesis before \"\n\t                                        , test.val\n\t                                        , \", but found none\"]),\n\t                     test.location);\n\t        }\n\t        test.isClause = true; // used to determine appropriate \"else\" use during desugaring\n\t        cpl.location = clause.location;\n\t        return cpl;\n\t    }\n\t\n\t    // first check the couples, then parse if there's no problem\n\t    rest(sexp).forEach(checkCondCouple);\n\t    var numClauses = rest(sexp).length,\n\t        parsedClauses = rest(sexp).map(parseCondCouple);\n\t    // if we see an else and we haven't seen all other clauses first\n\t    // throw an error that points to the next clause (rst + the one we're looking at + \"cond\")\n\t    rest(sexp).forEach(function(couple, idx){\n\t     if(isElseClause(couple) && (idx < (numClauses-1))){\n\t       throwError(new types.Message([new types.MultiPart(\"cond\", condLocs, true)\n\t                                     , \": \", \"found an \"\n\t                                     , new types.ColoredPart(\"else clause\", couple.location)\n\t                                     , \" that isn't the last clause in its cond expression; there is \"\n\t                                     , new types.ColoredPart(\"another clause\", sexp[idx+2].location)\n\t                                     , \" after it\"]),\n\t                  couple.location);\n\t      }\n\t    });\n\t    return new condExpr(parsedClauses, sexp[0]);\n\t  }\n\t\n\t  function parseCaseExpr(sexp) {\n\t    // is it just (case)?\n\t    if(sexp.length === 1){\n\t        var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                     , \": expected at least one clause after case, but nothing's there\"]);\n\t        throwError(msg, sexp.location);\n\t    }\n\t    var caseLocs = [sexp[0].location, sexp.location.start(), sexp.location.end()];\n\t    if(sexp.length === 2){\n\t        var msg = new types.Message([new types.MultiPart(sexp[0].val, caseLocs, true)\n\t                                    , \": expected a clause with at least one choice (in parentheses)\"\n\t                                     + \" and an answer after the expression, but nothing's there\"]);\n\t        throwError(msg, sexp.location);\n\t    }\n\t \n\t    function checkCaseCouple(clause) {\n\t      var clauseLocations = [clause.location.start(), clause.location.end()];\n\t      if(!(clause instanceof Array)){\n\t        var msg = new types.Message([new types.MultiPart(sexp[0].val, caseLocs, true)\n\t                                     , \": expected a clause with at least one choice (in parentheses), but found \"\n\t                                     , new types.ColoredPart(\"something else\", clause.location)]);\n\t        throwError(msg, sexp.location);\n\t      }\n\t      if(clause.length === 0){\n\t        var msg = new types.Message([new types.MultiPart(sexp[0].val, caseLocs, true)\n\t                                     , \": expected at least one choice (in parentheses) and an answer, but found an \"\n\t                                     , new types.ColoredPart(\"empty part\", clause.location)]);\n\t        throwError(msg, sexp.location);\n\t      }\n\t      if(!( (clause[0] instanceof Array) ||\n\t            ((clause[0] instanceof symbolExpr) && isSymbolEqualTo(clause[0], \"else\")))){\n\t        var msg = new types.Message([new types.MultiPart(sexp[0].val, caseLocs, true)\n\t                                     , \": expected 'else', or at least one choice in parentheses, but found \"\n\t                                     , new types.ColoredPart(\"something else\", clause.location)]);\n\t        throwError(msg, sexp.location);\n\t      }\n\t      if(clause.length === 1){\n\t        var msg = new types.Message([new types.MultiPart(sexp[0].val, caseLocs, true)\n\t                                     , \": expected a clause with a question and an answer, but found a \"\n\t                                     , new types.MultiPart(\"clause\", clauseLocations, true)\n\t                                     , \" with only \"\n\t                                     , new types.ColoredPart(\"one part\", clause[0].location)]);\n\t        throwError(msg, sexp.location);\n\t      }\n\t      if(clause.length > 2){\n\t        var extraLocs = clause.map(function(sexp){ return sexp.location; }),\n\t            wording = extraLocs.length+\" parts\",\n\t            msg = new types.Message([new types.MultiPart(sexp[0].val, caseLocs, true)\n\t                                     , \": expected only one expression for the answer in the case clause, but found a \"\n\t                                     , new types.MultiPart(\"clause\", clauseLocations, true)\n\t                                     , \" with \"\n\t                                     , new types.MultiPart(wording, extraLocs, false)]);\n\t        throwError(msg, sexp.location);\n\t      }\n\t    }\n\t \n\t    // is this sexp actually an else clause?\n\t    function isElseClause(sexp){ return isSymbol(sexp[0]) && (sexp[0].val===\"else\");}\n\t\n\t    // read the first item in the clause as a quotedExpr, and parse the second\n\t    // if it's an else clause, however, leave it alone\n\t    function parseCaseCouple(sexp) {\n\t        var test = isElseClause(sexp)? sexp[0] : new quotedExpr(sexp[0]),\n\t            result = parseExpr(sexp[1]), cpl = new couple(test, result);\n\t        test.isClause = true; // used to determine appropriate \"else\" use during desugaring\n\t        cpl.location = sexp.location;\n\t        return cpl;\n\t    }\n\t \n\t    var clauses = sexp.slice(2);\n\t    // first check the couples, then parse if there's no problem\n\t    clauses.forEach(checkCaseCouple);\n\t    var numClauses = clauses.length,\n\t        parsedClauses = clauses.map(parseCaseCouple);\n\t\n\t    // if we see an else and we haven't seen all other clauses first\n\t    // throw an error that points to the next clause (rst + the one we're looking at + \"cond\")\n\t    clauses.forEach(function(couple, idx){\n\t     if(isElseClause(couple) && (idx < (numClauses-1))){\n\t        var msg = new types.Message([new types.MultiPart(\"case\", caseLocs, true)\n\t                                     , \": found an \"\n\t                                     , new types.ColoredPart(\"else clause\", couple.location)\n\t                                     , \"that isn't the last clause in its case expression; there is \"\n\t                                     , new types.ColoredPart(\"another clause\", sexp[idx+2].location)\n\t                                     , \" after it\"]);\n\t        throwError(msg, sexp.location);\n\t      }\n\t    });\n\t    return new caseExpr(parseExpr(sexp[1]), parsedClauses, sexp[0]);\n\t  }\n\t \n\t  function parseBinding(sexp) {\n\t    if(sexpIsCouple(sexp)){\n\t        var binding = new couple(parseIdExpr(sexp[0]), parseExpr(sexp[1]));\n\t        binding.location = sexp.location;\n\t        binding.stx = sexp;\n\t        return binding;\n\t    } else {\n\t        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected a sequence of key/value pairs, but given \"\n\t                                      , new types.ColoredPart(\"something else\", sexp[0].location)]),\n\t                   sexp.location);\n\t    }\n\t  }\n\t\n\t  function parseUnquoteExpr(sexp, depth) {\n\t    if (typeof depth === 'undefined') {\n\t      throwError( new types.Message([\"misuse of a comma or 'unquote, not under a quasiquoting backquote\"])\n\t                , sexp.location\n\t                , \"Error-GenericSyntacticError\");\n\t    } else if((sexp.length !== 2)){\n\t     throwError( new types.Message([\"Inside an unquote, expected to find a single argument, but found \"+(sexp.length-1)])\n\t               , sexp.location);\n\t   } else if (depth === 1) {\n\t     var result = new unquotedExpr(parseExpr(sexp[1]))\n\t     result.location = sexp[1].location\n\t     return result;\n\t   } else if (depth > 1) {\n\t     var result = new unquotedExpr(parseQuasiQuotedItem(sexp[1], depth-1))\n\t     result.location = sexp[1].location\n\t     return result;\n\t   } else {\n\t     throwError( new types.Message([\"ASSERTION FAILURE: depth should have been undefined, or a natural number\"])\n\t               , sexp.location);\n\t   }\n\t  }\n\t\n\t  function parseUnquoteSplicingExpr(sexp, depth) {\n\t    if (typeof depth === 'undefined') {\n\t      throwError( new types.Message([\"misuse of a ,@ or unquote-splicing, not under a quasiquoting backquote\"])\n\t                , sexp.location\n\t                , \"Error-GenericSyntacticError\");\n\t    } else if((sexp.length !== 2)){\n\t      throwError(new types.Message([\"Inside an unquote-splicing, expected to find a single argument, but found \"+(sexp.length-1)])\n\t                 , sexp.location);\n\t    } else if (depth === 1) {\n\t      var result =  new unquoteSplice(parseExpr(sexp[1]))\n\t      result.location = sexp[1].location\n\t      return result;\n\t    } else if (depth > 1) {\n\t      var result =  new unquoteSplice(parseQuasiQuotedItem(sexp[1], depth-1))\n\t      result.location = sexp[1].location\n\t      return result;\n\t    } else {\n\t     throwError( new types.Message([\"ASSERTION FAILURE: depth should have been undefined, or a natural number\"])\n\t               , sexp.location);\n\t    }\n\t  }\n\t\n\t  /* This is what we use in place of `parseExpr` when we're in \"data-mode\",  */\n\t  /* i.e. there's an active quasiquote. Active is a bit awkward to describe, */\n\t  /* but basically it's an unmatch quasiquote, if we think of unquotes as    */\n\t  /* matching quasiquotes, so:                                               */\n\t  /*   ``,(+ 1 2)                                                            */\n\t  /* has an active quasiquote while reading (+ 1 2), whereas:                */\n\t  /*   ``,,(+ 1 2)                                                           */\n\t  /* does not.                                                               */\n\t  function parseQuasiQuotedItem(sexp, depth) {\n\t    if (isCons(sexp) && sexp[0].val === 'unquote'){\n\t      return parseUnquoteExpr(sexp, depth);\n\t    } else if(isCons(sexp) && sexp[0].val === 'unquote-splicing'){\n\t      return parseUnquoteSplicingExpr(sexp, depth);\n\t    } else if(isCons(sexp) && sexp[0].val === 'quasiquote'){\n\t      return parseQuasiQuotedExpr(sexp, depth);\n\t    } else if(isCons(sexp)){\n\t       var res = sexp.map(function (x) {return parseQuasiQuotedItem(x, depth)});\n\t       res.location = sexp.location;\n\t       return res;\n\t    } else if( depth === 0){\n\t      return parseExpr(sexp);\n\t    } else {\n\t      return (function () {\n\t              var res = new quotedExpr(sexp);\n\t              res.location=sexp.location;\n\t              return res;})()\n\t    }\n\t\n\t  }\n\t\n\t  function parseQuasiQuotedExpr(sexp, depth) {\n\t    depth = (typeof depth === 'undefined') ? 0 : depth;\n\t    // quasiquote must have exactly one argument\n\t    if(sexp.length < 2){\n\t      throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                    , \": expected a single argument, but did not find one \"]),\n\t                  sexp.location);\n\t    }\n\t    if(sexp.length > 2){\n\t      var extraLocs = sexp.slice(1).map(function(sexp){ return sexp.location; });\n\t      throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                    , \": expected a single argument, but found \"\n\t                                    , new types.MultiPart(\"more than one.\", extraLocs, false)]),\n\t                  sexp.location);\n\t    }\n\t    // if the argument is (unquote-splicing....), throw an error\n\t    if(isCons(sexp[1]) && isSymbolEqualTo(sexp[1][0], \"unquote-splicing\")){\n\t      throwError(new types.Message([\"misuse of ,@ or `unquote-splicing' within a quasiquoting backquote\"]), sexp.location);\n\t    }\n\t\n\t    var quoted = parseQuasiQuotedItem(sexp[1], depth+1);\n\t    quoted.location = sexp[1].location;\n\t    var result = new quasiquotedExpr(quoted);\n\t    result.location = sexp.location;\n\t    return result;\n\t  }\n\t \n\t  // replace all undefineds with the last sexp, and convert to a function call\n\t  function parseVector(sexp){\n\t    function buildZero(){\n\t      var lit = new literal(0);\n\t      lit.location = sexp.location;\n\t      return lit;\n\t    }\n\t    var unParsedVector = sexp.val,\n\t        vals = parseStar(unParsedVector.elts.filter(function(e){return e!==undefined;})),\n\t        last = (vals.length===0)? buildZero() : vals[vals.length-1], // if they're all undefined, use 0\n\t        elts = unParsedVector.elts.map(function(v){return (v===undefined)? last : parseExpr(v);});\n\t    var vectorFunc = new symbolExpr(\"vector\"),\n\t        buildVector = new callExpr(vectorFunc, elts);\n\t    vectorFunc.location = buildVector.location = sexp.location;\n\t    return buildVector;\n\t  }\n\t  \n\t  function parseExprSingleton(sexp) {\n\t    var singleton = isUnsupported(sexp) ? sexp :\n\t                    isVector(sexp)  ? parseVector(sexp) :\n\t                    isSymbol(sexp) ? sexp :\n\t                    isLiteral(sexp) ? sexp :\n\t                    isSymbolEqualTo(\"quote\", sexp) ? new quotedExpr(sexp) :\n\t                    isSymbolEqualTo(\"empty\", sexp) ? new callExpr(new symbolExpr(\"list\"), []) :\n\t      throwError(new types.Message([new types.ColoredPart(\"( )\", sexp.location)\n\t                                    , \": expected a function, but nothing's there\"])\n\t                 , sexp.location);\n\t   singleton.location = sexp.location;\n\t   return singleton;\n\t  }\n\t\n\t  function parseIdExpr(sexp) {\n\t    return isSymbol(sexp) ? sexp :\n\t    throwError(new types.Message([\"ID\"]), sexp.location);\n\t  }\n\t\n\t  function isTupleStartingWithOfLength(sexp, symbol, n) {\n\t    return ((isCons(sexp)) && (sexp.length === n) && (isSymbol(sexp[0])) && (isSymbolEqualTo(sexp[0], symbol)));\n\t  }\n\t\n\t  function sexpIsCouple(sexp) {\n\t    return ((isCons(sexp)) && ((sexp.length === 2)));\n\t  }\n\t\n\t  function sexpIsCondListP(sexp) {\n\t    return ((isCons(sexp)) && (sexp.length >= 2) && (isSymbol(sexp[0])) && (isSymbolEqualTo(sexp[0], \"cond\")));\n\t  }\n\t\n\t  //////////////////////////////////////// REQUIRE PARSING ////////////////////////////////\n\t  function isRequire(sexp) {\n\t    return isCons(sexp) && isSymbol(sexp[0]) && isSymbolEqualTo(sexp[0], \"require\");\n\t  }\n\t\n\t  function parseRequire(sexp) {\n\t    // is it (require)?\n\t    if(sexp.length < 2){\n\t      var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                   , \": expected a module name after `require', but found nothing\"]);\n\t      throwError(msg, sexp.location);\n\t    }\n\t    // if it's (require (lib...))\n\t    if((sexp[1] instanceof Array) && isSymbolEqualTo(sexp[1][0], \"lib\")){\n\t        // is it (require (lib)) or (require (lib <string>))\n\t        if(sexp[1].length < 3){\n\t          var partsNum = sexp[1].slice(1).length,\n\t              partsStr = partsNum + ((partsNum===1)? \" part\" : \" parts\"),\n\t              msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                      , \": expected at least two strings after \"\n\t                                      , new types.ColoredPart(\"lib\", sexp[1][0].location)\n\t                                      , \" but found only \"\n\t                                      , partsStr]);\n\t           throwError(msg, sexp.location);\n\t        }\n\t        // is it (require (lib not-strings))?\n\t        rest(sexp[1]).forEach(function(lit){\n\t          if (!(isString(lit))){\n\t            var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                        , \": expected a string for a library collection, but found \"\n\t                                        , new types.ColoredPart(\"something else\", str.location)]);\n\t            throwError(msg, sexp.location);\n\t          }\n\t         });\n\t    // if it's (require (planet...))\n\t    } else if((sexp[1] instanceof Array) && isSymbolEqualTo(sexp[1][0], \"planet\")){\n\t      var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                   , \": Importing PLaneT pacakges is not supported at this time\"]);\n\t      throwError(msg, sexp.location);\n\t    // if it's (require <not-a-string-or-symbol>)\n\t    } else if(!((sexp[1] instanceof symbolExpr) || isString(sexp[1]))){\n\t      var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                   , \": expected a module name as a string or a `(lib ...)' form, but found \"\n\t                                   , new types.ColoredPart(\"something else\", sexp[1].location)]);\n\t      throwError(msg, sexp.location);\n\t    }\n\t    var req = new requireExpr(sexp[1], sexp[0]);\n\t    req.location = sexp.location;\n\t    return req;\n\t  }\n\t\n\t  //////////////////////////////////////// PROVIDE PARSING ////////////////////////////////\n\t function isProvide(sexp) {\n\t    return isCons(sexp) && isSymbol(sexp[0]) && isSymbolEqualTo(sexp[0], \"provide\");\n\t }\n\t function parseProvide(sexp) {\n\t    var clauses = rest(sexp).map(function(p){\n\t        // symbols are ok\n\t        if(p instanceof symbolExpr){ return p;}\n\t        // (struct-out sym) is ok\n\t        if((p instanceof Array) && (p.length == 2)\n\t           && (p[0] instanceof symbolExpr) && isSymbolEqualTo(p[0], \"struct-out\")\n\t           && (p[1] instanceof symbolExpr)){\n\t          return p;\n\t        }\n\t        // everything else is NOT okay\n\t        var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n\t                                     , \": I don't recognize the syntax of this \"\n\t                                     , new types.ColoredPart(\"clause\", p.location)]);\n\t        throwError(msg, sexp.location);\n\t    });\n\t    var provide = new provideStatement(clauses, sexp[0]);\n\t    provide.location = sexp.location;\n\t    return provide;\n\t  }\n\t\n\t  /////////////////////\n\t  /* Export Bindings */\n\t  /////////////////////\n\t plt.compiler.parse = function(sexp, debug){\n\t      var start = new Date().getTime();\n\t      try{ var AST = parse(sexp); AST.location = sexp.location; }   // do the actual work\n\t      catch(e) { console.log(\"PARSING ERROR\"); throw e; }\n\t      var end = new Date().getTime();\n\t      if(debug){\n\t        console.log(\"Parsed in \"+(Math.floor(end-start))+\"ms\");\n\t        console.log(AST);\n\t      }\n\t      return AST;\n\t  };\n\t})();\n\t\n\tmodule.exports = plt.compiler;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(2);\n\t__webpack_require__(8);\n\t// if not defined, declare the compiler object as part of plt\n\twindow.plt   = window.plt   || {};\n\tplt.compiler = plt.compiler || {};\n\tvar types = __webpack_require__(3);\n\t\n\t/*\n\t TODO\n\t - stop using synchronous XmlHttpRequests -> probably only after the compiler is folded into the evaluator\n\t*/\n\t\n\t(function () {\n\t 'use strict';\n\t \n\t // import frequently-used bindings\n\t var literal          = plt.compiler.literal;\n\t var symbolExpr       = plt.compiler.symbolExpr;\n\t var Program          = plt.compiler.Program;\n\t var couple           = plt.compiler.couple;\n\t var ifExpr           = plt.compiler.ifExpr;\n\t var beginExpr        = plt.compiler.beginExpr;\n\t var letExpr          = plt.compiler.letExpr;\n\t var letStarExpr      = plt.compiler.letStarExpr;\n\t var letrecExpr       = plt.compiler.letrecExpr;\n\t var localExpr        = plt.compiler.localExpr;\n\t var andExpr          = plt.compiler.andExpr;\n\t var orExpr           = plt.compiler.orExpr;\n\t var condExpr         = plt.compiler.condExpr;\n\t var caseExpr         = plt.compiler.caseExpr;\n\t var lambdaExpr       = plt.compiler.lambdaExpr;\n\t var quotedExpr       = plt.compiler.quotedExpr;\n\t var unquotedExpr     = plt.compiler.unquotedExpr;\n\t var quasiquotedExpr  = plt.compiler.quasiquotedExpr;\n\t var unquoteSplice    = plt.compiler.unquoteSplice;\n\t var callExpr         = plt.compiler.callExpr;\n\t var whenUnlessExpr   = plt.compiler.whenUnlessExpr;\n\t var defFunc          = plt.compiler.defFunc;\n\t var defVar           = plt.compiler.defVar;\n\t var defVars          = plt.compiler.defVars;\n\t var defStruct        = plt.compiler.defStruct;\n\t var requireExpr      = plt.compiler.requireExpr;\n\t var provideStatement = plt.compiler.provideStatement;\n\t var unsupportedExpr  = plt.compiler.unsupportedExpr;\n\t \n\t var throwError       = plt.compiler.throwError;\n\t var structBinding    = plt.compiler.structBinding;\n\t var constantBinding  = plt.compiler.constantBinding;\n\t var functionBinding  = plt.compiler.functionBinding;\n\t var moduleBinding    = plt.compiler.moduleBinding;\n\t var knownModules     = plt.compiler.knownModules;\n\t \n\t  // checkDuplicateIdentifiers : [listof SymbolExprs], Program -> Void\n\t  // sort the array, and throw errors for non-symbols, keywords or duplicates\n\t  function checkDuplicateIdentifiers(lst, stx, loc){\n\t    var visitedIds = {}; // initialize a dictionary of ids we've seen\n\t    lst.forEach(function(id){\n\t        if(!(id instanceof symbolExpr)){\n\t          throwError(\"expected identifier \"+id.val, id.location);\n\t        } else if(visitedIds[id.val]) { // if we've seen this variable before, throw an error\n\t          throwError(new types.Message([new types.ColoredPart(stx.toString(), stx.location),\n\t                                    \": found \",\n\t                                    new types.ColoredPart(\"a variable\", id.location),\n\t                                    \" that is already used \",\n\t                                    new types.ColoredPart(\"here\", visitedIds[id.val].location)])\n\t                     , id.location);\n\t        } else {\n\t          visitedIds[id.val] = id; // otherwise, record the identifier as being visited\n\t        }\n\t                         \n\t    });\n\t  }\n\t \n\t // tag-application-operator/module: Stx module-name -> Stx\n\t // Adjust the lexical context of the func so it refers to the environment of a particular module.\n\t function tagApplicationOperator_Module(application, moduleName){\n\t    // get the module's env\n\t    var module = plt.compiler.defaultModuleResolver(moduleName),\n\t        env = new plt.compiler.emptyEnv().extendEnv_moduleBinding(module);\n\t    // assign it as the context of the function, and each of the arguments\n\t    [application.func].concat(application.args).forEach(function(expr){expr.context = env;});\n\t    return application;\n\t }\n\t\n\t // forceBooleanContext: stx, loc, bool -> stx\n\t // Force a boolean runtime test on the given expression.\n\t function forceBooleanContext(stx, loc, boolExpr){\n\t    stx = new literal(new types.string(stx.toString())); // turn the stx object into a string literal\n\t    var verifyCall  = new symbolExpr(\"verify-boolean-branch-value\"),\n\t        stxQuote    = new quotedExpr(stx),\n\t        locQuote    = new quotedExpr(new literal(loc.toVector())),\n\t        boolLocQuote= new quotedExpr(new literal(boolExpr.location.toVector())),\n\t        runtimeCall = new callExpr(verifyCall, [stxQuote, locQuote, boolExpr, boolLocQuote]);\n\t    runtimeCall.location = verifyCall.location = boolExpr.location;\n\t    stxQuote.location=locQuote.location=boolLocQuote.location = boolExpr.location;\n\t    tagApplicationOperator_Module(runtimeCall, 'moby/runtime/kernel/misc');\n\t    return runtimeCall;\n\t }\n\t \n\t //////////////////////////////////////////////////////////////////////////////\n\t // DESUGARING ////////////////////////////////////////////////////////////////\n\t\n\t // desugarProgram : Listof Programs null/pinfo -> [Listof Programs, pinfo]\n\t // desugar each program, appending those that desugar to multiple programs\n\t function desugarProgram(programs, pinfo, isTopLevelExpr){\n\t      var acc = [ [], (pinfo || new plt.compiler.pinfo())];\n\t      var res = programs.reduce((function(acc, p){\n\t            var desugaredAndPinfo = p.desugar(acc[1]);\n\t            // if it's an expression, insert a print-values call so it shows up in the repl\n\t            if(plt.compiler.isExpression(p) && isTopLevelExpr){\n\t              var printValues = new symbolExpr(\"print-values\"),\n\t                  printCall = new callExpr(printValues, [desugaredAndPinfo[0]]);\n\t               // set the location of the print-values call to that of the expression\n\t              printValues.location = printCall.location = desugaredAndPinfo[0].location;\n\t              desugaredAndPinfo[0] = printCall;\n\t              tagApplicationOperator_Module(printCall,'moby/runtime/kernel/misc');\n\t            }\n\t            if(desugaredAndPinfo[0].length){\n\t              acc[0] = acc[0].concat(desugaredAndPinfo[0]);\n\t            } else {\n\t              acc[0].push(desugaredAndPinfo[0]);\n\t            }\n\t            return [acc[0], desugaredAndPinfo[1]];\n\t        }), acc);\n\t      res[0].location = programs.location;\n\t      return res;\n\t }\n\t \n\t // Program.prototype.desugar: pinfo -> [Program, pinfo]\n\t Program.prototype.desugar = function(pinfo){ return [this, pinfo]; };\n\t defFunc.prototype.desugar = function(pinfo){\n\t    // check for duplicate arguments\n\t    checkDuplicateIdentifiers([this.name].concat(this.args), this.stx[0], this.location);\n\t    // check for non-symbol arguments\n\t    this.args.forEach(function(arg){\n\t       if(!(arg instanceof symbolExpr)){\n\t        throwError(new types.Message([new types.ColoredPart(this.stx.val, this.stx.location)\n\t                                , \": expected a variable but found \"\n\t                                , new types.ColoredPart(\"something else\", arg.location)])\n\t                   , sexp.location);\n\t      }\n\t    });\n\t    var bodyAndPinfo = this.body.desugar(pinfo),\n\t        newDefFunc = new defFunc(this.name, this.args, bodyAndPinfo[0], this.stx);\n\t    newDefFunc.location = this.location;\n\t    return [newDefFunc, bodyAndPinfo[1]];\n\t };\n\t defVar.prototype.desugar = function(pinfo){\n\t    // convert (define f (lambda (x) x)) into (define (f x) x)\n\t    if(this.expr instanceof lambdaExpr){\n\t      var newDefFunc = new defFunc(this.name, this.expr.args, this.expr.body, this.stx);\n\t      newDefFunc.location = this.location;\n\t      return newDefFunc.desugar(pinfo);\n\t    } else {\n\t      var exprAndPinfo = this.expr.desugar(pinfo),\n\t          newDefVar = new defVar(this.name, exprAndPinfo[0], this.stx);\n\t      newDefVar.location = this.location;\n\t      return [newDefVar, exprAndPinfo[1]];\n\t    }\n\t };\n\t defVars.prototype.desugar = function(pinfo){\n\t    var exprAndPinfo = this.expr.desugar(pinfo),\n\t        newDefVars = new defVars(this.names, exprAndPinfo[0], this.stx);\n\t    newDefVars.location = this.location;\n\t    return [newDefVars, exprAndPinfo[1]];\n\t };\n\t defStruct.prototype.desugar = function(pinfo){\n\t    var that = this,\n\t        ids = ['make-'+this.name.val, this.name.val+'?', this.name.val+'-ref', this.name.val+'-set!'],\n\t        idSymbols = ids.map(function(id){return new symbolExpr(id);}),\n\t        makeStructTypeFunc = new symbolExpr('make-struct-type'),\n\t        makeStructTypeArgs = [new quotedExpr(new symbolExpr(this.name.val)),\n\t                              new literal(false),\n\t                              new literal(this.fields.length),\n\t                              new literal(0)],\n\t        makeStructTypeCall = new callExpr(makeStructTypeFunc, makeStructTypeArgs);\n\t    // set location for all of these nodes\n\t    [makeStructTypeCall, makeStructTypeFunc].concat(idSymbols, makeStructTypeArgs).forEach(function(p){p.location = that.location});\n\t \n\t    // make the define-values stx object, but store the original stx for define-struct\n\t    var defineValuesStx = new defVars([this.name].concat(idSymbols), makeStructTypeCall, this.stx),\n\t        stxs = [defineValuesStx];\n\t    defineValuesStx.location = this.location;\n\t    // given a field, make a definition that binds struct-field to the result of\n\t    // a make-struct-field accessor call in the runtime\n\t    function makeAccessorDefn(f, i){\n\t      var makeFieldFunc = new symbolExpr('make-struct-field-accessor'),\n\t          makeFieldArgs = [new symbolExpr(that.name.val+'-ref'), new literal(i), new quotedExpr(new symbolExpr(f.val))],\n\t          makeFieldCall = new callExpr(makeFieldFunc, makeFieldArgs),\n\t          accessorSymbol= new symbolExpr(that.name.val+'-'+f.val),\n\t          defineVar = new defVar(accessorSymbol, makeFieldCall);\n\t      // set location for all of these nodes\n\t      [defineVar, makeFieldFunc, makeFieldCall, accessorSymbol].concat(makeFieldArgs).forEach(function(p){p.location = f.location});\n\t      stxs.push(defineVar);\n\t    }\n\t    this.fields.forEach(makeAccessorDefn);\n\t    return [stxs, pinfo];\n\t };\n\t beginExpr.prototype.desugar = function(pinfo){\n\t    var exprsAndPinfo = desugarProgram(this.exprs, pinfo),\n\t        newBeginExpr = new beginExpr(exprsAndPinfo[0], this.stx);\n\t    newBeginExpr.location = this.location;\n\t    return [newBeginExpr, exprsAndPinfo[1]];\n\t };\n\t lambdaExpr.prototype.desugar = function(pinfo){\n\t    // if this was parsed from raw syntax, check for duplicate arguments\n\t    if(this.stx) checkDuplicateIdentifiers(this.args, this.stx, this.location);\n\t    var bodyAndPinfo = this.body.desugar(pinfo),\n\t        newLambdaExpr = new lambdaExpr(this.args, bodyAndPinfo[0], this.stx);\n\t    newLambdaExpr.location = this.location;\n\t    return [newLambdaExpr, bodyAndPinfo[1]];\n\t };\n\t localExpr.prototype.desugar = function(pinfo){\n\t    var defnsAndPinfo = desugarProgram(this.defs, pinfo),\n\t        exprAndPinfo = this.body.desugar(defnsAndPinfo[1]),\n\t        newLocalExpr = new localExpr(defnsAndPinfo[0], exprAndPinfo[0], this.stx);\n\t    newLocalExpr.location = this.location;\n\t    return [newLocalExpr, exprAndPinfo[1]];\n\t };\n\t callExpr.prototype.desugar = function(pinfo){\n\t    var exprsAndPinfo = desugarProgram([this.func].concat(this.args), pinfo),\n\t        newCallExpr = new callExpr(exprsAndPinfo[0][0], exprsAndPinfo[0].slice(1), this.stx);\n\t    newCallExpr.location = this.location;\n\t    return [newCallExpr, exprsAndPinfo[1]];\n\t };\n\t ifExpr.prototype.desugar = function(pinfo){\n\t    var exprsAndPinfo = desugarProgram([this.predicate,\n\t                                        this.consequence,\n\t                                        this.alternative],\n\t                                       pinfo),\n\t        predicate = forceBooleanContext(this.stx, this.stx.location, exprsAndPinfo[0][0]),\n\t        consequence = exprsAndPinfo[0][1],\n\t        alternative = exprsAndPinfo[0][2],\n\t        newIfExpr = new ifExpr(predicate, consequence, alternative, this.stx);\n\t    newIfExpr.location = this.location;\n\t    return [newIfExpr, exprsAndPinfo[1]];\n\t };\n\t whenUnlessExpr.prototype.desugar = function(pinfo){\n\t    var begin_exp = new beginExpr(this.exprs, this.stx),\n\t        void_exp = new symbolExpr('void'),\n\t        call_exp = new callExpr(void_exp, [], this.stx),\n\t        consequence = (this.stx.val===\"when\")? begin_exp : call_exp,\n\t        alternative = (this.stx.val===\"when\")? call_exp : begin_exp;\n\t    begin_exp.location = this.exprs.location;\n\t    void_exp.location = call_exp.location = this.location;\n\t    // desugar each expression and construct an ifExpr\n\t    var exprsAndPinfo = desugarProgram([this.predicate,\n\t                                        consequence,\n\t                                        alternative],\n\t                                       pinfo),\n\t        if_exp = new ifExpr(exprsAndPinfo[0][0], exprsAndPinfo[0][1], exprsAndPinfo[0][2], this.stx);\n\t    if_exp.location = this.location;\n\t    // DON'T desugar the ifExpr -- we don't forceBooleanContext on when/unless!\n\t    return [if_exp, exprsAndPinfo[1]];\n\t };\n\t // letrecs become locals\n\t letrecExpr.prototype.desugar = function(pinfo){\n\t    function bindingToDefn(b){\n\t      var def = new defVar(b.first, b.second, b.stx);\n\t      def.location = b.location;\n\t      return def\n\t    };\n\t    var localAndPinfo = new localExpr(this.bindings.map(bindingToDefn), this.body, this.stx).desugar(pinfo);\n\t    localAndPinfo[0].location = this.location;\n\t    return localAndPinfo;\n\t };\n\t // lets become calls\n\t letExpr.prototype.desugar = function(pinfo){\n\t    // utility functions for accessing first and second\n\t    function coupleFirst(x) { return x.first; };\n\t    function coupleSecond(x) { return x.second; };\n\t\n\t    var ids   = this.bindings.map(coupleFirst),\n\t        exprs = this.bindings.map(coupleSecond),\n\t        lambda= new lambdaExpr(ids, this.body, this.stx),\n\t        call  = new callExpr(lambda, exprs);\n\t    lambda.location = call.location = this.location;\n\t    return call.desugar(pinfo);\n\t };\n\t // let*s become nested lets\n\t letStarExpr.prototype.desugar = function(pinfo){\n\t    function bindingToLet(body, binding){\n\t      var let_exp = new letExpr([binding], body, binding.stx);\n\t      let_exp.location = binding.location;\n\t      return let_exp;\n\t    }\n\t    // if there are no bindings, desugar the body. Otherwise, reduce to nested lets first\n\t    if(this.bindings.length === 0) return this.body.desugar(pinfo);\n\t    else return this.bindings.reduceRight(bindingToLet, this.body).desugar(pinfo);\n\t };\n\t // conds become nested ifs\n\t condExpr.prototype.desugar = function(pinfo){\n\t    // base case is all-false\n\t    var condExhausted = new symbolExpr(\"throw-cond-exhausted-error\"),\n\t        exhaustedLoc = new quotedExpr(new literal(this.location.toVector())),\n\t        expr = tagApplicationOperator_Module(new callExpr(condExhausted, [exhaustedLoc])\n\t                                             , \"moby/runtime/kernel/misc\");\n\t    var ifStx = new symbolExpr(\"if\");\n\t    ifStx.location = this.stx.location;\n\t \n\t    expr.location = condExhausted.location = exhaustedLoc.location = this.location;\n\t    for(var i=this.clauses.length-1; i>-1; i--){\n\t      // desugar else to true\n\t      if(this.clauses[i].first instanceof symbolExpr && this.clauses[i].first.val === \"else\"){\n\t        this.clauses[i].first.val = \"true\";\n\t      }\n\t      expr = new ifExpr(this.clauses[i].first, this.clauses[i].second, expr, this.stx);\n\t      expr.location = this.location;\n\t    }\n\t    return expr.desugar(pinfo);\n\t };\n\t // case become nested ifs, with ormap as the predicate\n\t caseExpr.prototype.desugar = function(pinfo){\n\t    var that = this,\n\t        caseStx = new symbolExpr(\"if\"); // TODO: The server returns \"if\" here, but I am almost certain it should be \"case\"\n\t    caseStx.location = that.location;\n\t\n\t    var pinfoAndValSym = pinfo.gensym('val'),      // create a symbol 'val'\n\t        updatedPinfo1 = pinfoAndValSym[0],        // generate pinfo containing 'val'\n\t        valStx = pinfoAndValSym[1];               // remember the symbolExpr for 'val'\n\t    var pinfoAndXSym = updatedPinfo1.gensym('x'), // create another symbol 'x' using pinfo1\n\t        updatedPinfo2 = pinfoAndXSym[0],          // generate pinfo containing 'x'\n\t        xStx = pinfoAndXSym[1],                   // remember the symbolExpr for 'x'\n\t        voidStx = new symbolExpr('void');         // make the void symbol\n\t\n\t    // track all the syntax we've created so far...\n\t    var stxs = [valStx, xStx, voidStx];\n\t    // if there's an 'else', pop off the clause and use the result as the base\n\t    var expr, clauses = this.clauses, lastClause = clauses[this.clauses.length-1];\n\t    if((lastClause.first instanceof symbolExpr) && (lastClause.first.val === 'else')){\n\t      expr = lastClause.second;\n\t      clauses.pop();\n\t    } else {\n\t      expr = new callExpr(voidStx,[], that.stx);\n\t      expr.location = that.location;\n\t    }\n\t    // This is the predicate we'll be applying using ormap: (lambda (x) (equal? x val))\n\t    var equalStx = new symbolExpr('equal?'),\n\t        equalTestStx = new callExpr(equalStx, [xStx, valStx], caseStx),\n\t        predicateStx = new lambdaExpr([xStx], equalTestStx, caseStx);\n\t    // track the syntax that will need location information reset\n\t    stxs = stxs.concat([equalStx, equalTestStx, predicateStx]);\n\t \n\t    // generate (if (ormap <predicate> clause.first) clause.second base)\n\t    function processClause(base, clause){\n\t      var ormapStx = new symbolExpr('ormap'),\n\t          callStx = new callExpr(ormapStx, [predicateStx, clause.first], that.stx),\n\t          ifStx = new ifExpr(callStx, clause.second, base, caseStx);\n\t      // track the syntax that will need location information reset\n\t      stxs = stxs.concat([ormapStx, callStx, clause.first, ifStx]);\n\t      return ifStx;\n\t    }\n\t\n\t    // build the body of the let by decomposing cases into nested ifs\n\t    var binding = new couple(valStx, this.expr),\n\t        body = clauses.reduceRight(processClause, expr),\n\t        letExp = new letExpr([binding], body, caseStx);\n\t    // track the syntax that will need location information reset\n\t    stxs = stxs.concat([binding, letExp]);\n\t \n\t    // assign location to every stx element we created\n\t    stxs.forEach(function(stx){stx.location = that.location;});\n\t \n\t    return letExp.desugar(updatedPinfo2);\n\t };\n\t \n\t // ands become nested ifs\n\t andExpr.prototype.desugar = function(pinfo){\n\t    var that = this, ifStx = new symbolExpr(\"if\"),\n\t        exprsAndPinfo = desugarProgram(this.exprs, pinfo),\n\t        exprs = exprsAndPinfo[0],\n\t        pinfo = exprsAndPinfo[1];\n\t \n\t    // recursively walk through the exprs\n\t    function desugarAndExprs(exprs){\n\t      var predicate = forceBooleanContext(that.stx, that.stx.location, exprs[0]),\n\t          // if there only two exprs in the chain, force a boolean ctx on the second expr and make it the consequence\n\t          // otherwise, desugar the rest of the chain before adding it\n\t          consequence = (exprs.length > 2)? desugarAndExprs(exprs.slice(1))\n\t                                          : forceBooleanContext(that.stx, that.stx.location, exprs[1]),\n\t          alternative = new literal(false),\n\t          ifLink = new ifExpr(predicate, consequence, alternative, ifStx),\n\t          stxs = [alternative, ifStx, ifLink];\n\t \n\t      // assign location information to everything\n\t      stxs.forEach(function(stx){return stx.location = that.location;});\n\t      return ifLink;\n\t    }\n\t \n\t    var ifChain = desugarAndExprs(exprs);\n\t    ifChain.location = that.location;\n\t    return [ifChain, pinfo];\n\t };\n\t // ors become nested lets-with-if-bodies\n\t orExpr.prototype.desugar = function(pinfo){\n\t    var that = this, orStx = new symbolExpr(\"or\"),\n\t        exprsAndPinfo = desugarProgram(this.exprs, pinfo),\n\t        exprs = exprsAndPinfo[0],\n\t        pinfo = exprsAndPinfo[1];\n\t \n\t    // recursively walk through the exprs\n\t    function desugarOrExprs(exprs, pinfo){\n\t      var firstExpr = exprs[0], exprLoc = firstExpr.location,\n\t          pinfoAndTempSym = pinfo.gensym('tmp'),\n\t          firstExprSym = pinfoAndTempSym[1],\n\t          ifStx = new symbolExpr(\"if\");\n\t      firstExprSym.notOriginalSource = true;\n\t \n\t      // to match Racket's behavior, we override any expression's\n\t      // stx to be \"if\", with the location of the whole expression\n\t      if(firstExpr.stx && (firstExpr.stx.val !== \"if\")){\n\t          ifStx.location = firstExpr.location;\n\t          firstExpr.stx = ifStx;\n\t      }\n\t      var pinfo = pinfoAndTempSym[0],\n\t          tmpBinding = new couple(firstExprSym, forceBooleanContext(that.stx, that.stx.location, firstExpr)),\n\t          secondExpr;\n\t \n\t      // if there are only two exprs in the chain, force a boolean ctx on the second expr before adding\n\t      // otherwise, desugar the rest of the chain before adding it\n\t      if(exprs.length == 2){\n\t        secondExpr = forceBooleanContext(orStx, that.stx.location, exprs[1]);\n\t      } else  {\n\t        var secondExprAndPinfo = desugarOrExprs(exprs.slice(1), pinfo);\n\t        secondExpr = secondExprAndPinfo[0];\n\t        pinfo = secondExprAndPinfo[1];\n\t      }\n\t\n\t      // create if and let expressions, using these new symbols and bindings\n\t      var if_exp = new ifExpr(firstExprSym, firstExprSym, secondExpr, new symbolExpr(\"if\")),\n\t          let_exp = new letExpr([tmpBinding], if_exp, orStx),\n\t          stxs = [orStx, firstExprSym, tmpBinding, if_exp, if_exp.stx, let_exp];\n\t      // assign location information to everything\n\t      stxs.forEach(function(stx){return stx.location = that.location; });\n\t      return let_exp.desugar(pinfo);\n\t    }\n\t \n\t    return desugarOrExprs(exprs, pinfo);\n\t };\n\t\n\t quotedExpr.prototype.desugar = function (pinfo) {\n\t   if (typeof this.location === 'undefined') {\n\t     throwError( new types.Message([\"ASSERTION ERROR: Every quotedExpr should have a location\"])\n\t               , loc)\n\t   }\n\t   // Sexp-lists (arrays) become lists\n\t   // literals and symbols stay themselves\n\t   // everything else gets desugared\n\t   function desugarQuotedItem(pinfo, loc){\n\t     return function (x) {\n\t       if (  x instanceof callExpr\n\t          || x instanceof quotedExpr\n\t          || x instanceof unsupportedExpr\n\t          ) {\n\t         return x.desugar(pinfo);\n\t       } else if (  x instanceof symbolExpr\n\t                 || x instanceof literal\n\t                 || x instanceof Array\n\t                 ) {\n\t         var res = new quotedExpr(x);\n\t         res.location = loc;\n\t         return [res, pinfo];\n\t       } else {\n\t         throwError(new types.Message([\"ASSERTION ERROR: Found an unexpected item in a quotedExpr\"])\n\t                   , loc);\n\t       }\n\t     }\n\t   }\n\t \n\t   return desugarQuotedItem(pinfo, this.location)(this.val);\n\t };\n\t\n\t unquotedExpr.prototype.desugar = function (pinfo, depth) {\n\t   if (typeof depth === 'undefined') {\n\t     throwError( new types.Message([\"misuse of a ', not under a quasiquoting backquote\"])\n\t               , this.location);\n\t   } else if (depth === 1) {\n\t     return this.val.desugar(pinfo);\n\t   } else if (depth > 1) {\n\t     if (this.val instanceof Array) {\n\t       return desugarQuasiQuotedList(element, pinfo, depth-1);\n\t     } else {\n\t       var uSym = new quotedExpr(new symbolExpr('unquote')),\n\t           listSym = new symbolExpr('list'),\n\t           listArgs = [uSym, this.val.desugar(pinfo, depth-1)[0]],\n\t           listCall = new callExpr(listSym, listArgs);\n\t       uSym.location = this.location;\n\t       uSym.parent = listArgs;\n\t       listSym.location = this.location;\n\t       listSym.parent = listCall;\n\t       listCall.location = this.location;\n\t       return [listCall, pinfo];\n\t     }\n\t   } else {\n\t     throwError( new types.Message([\"ASSERTION FAILURE: depth should have been undefined, or a natural number\"])\n\t               , this.location);\n\t   }\n\t };\n\t\n\t unquoteSplice.prototype.desugar = function (pinfo, depth) {\n\t   if (typeof depth === 'undefined') {\n\t     throwError( new types.Message([\"misuse of a ,@, not under a quasiquoting backquote\"])\n\t               , this.location);\n\t   } else if (depth === 1) {\n\t     return this.val.desugar(pinfo);\n\t   } else if (depth > 1) {\n\t     if (this.val instanceof Array) {\n\t       return desugarQuasiQuotedList(element, pinfo, depth-1);\n\t     } else {\n\t       var usSym = new quotedExpr(new symbolExpr('unquote-splicing')),\n\t           listSym = new symbolExpr('list'),\n\t           listArgs = [usSym, this.val.desugar(pinfo, depth-1)[0]],\n\t           listCall = new callExpr(listSym, listArgs);\n\t       usSym.location = this.location;\n\t       usSym.parent = listArgs;\n\t       listSym.location = this.location;\n\t       listSym.parent = listCall;\n\t       listCall.location = this.location;\n\t       return [listCall, pinfo];\n\t     }\n\t   } else {\n\t     throwError( new types.Message([\"ASSERTION FAILURE: depth should have been undefined, or a natural number\"])\n\t               , this.location);\n\t   }\n\t };\n\t\n\t function desugarQuasiQuotedList(qqlist, pinfo, depth) {\n\t \n\t    // helper function for a single QQ-list element\n\t    function desugarQuasiQuotedListElement(element, pinfo, depth, loc) {\n\t     if (depth === 0 && element instanceof unquoteSplice) {\n\t       return element.desugar(pinfo, depth);\n\t     } else {\n\t       var argument = (element instanceof Array) ?\n\t            desugarQuasiQuotedList(element, depth, depth)[0] :\n\t            element.desugar(pinfo, depth)[0],\n\t           listSym = new symbolExpr('list'),\n\t           listCall = new callExpr(listSym, [argument]);\n\t       listSym.parent = listCall;\n\t       listCall.location = listSym.location = loc;\n\t       return [listCall, pinfo];\n\t     }\n\t   }\n\t \n\t   var loc = (typeof qqlist.location != 'undefined') ? qqlist.location :\n\t              ((qqlist instanceof Array) && (typeof qqlist[0].location != 'undefined')) ? qqlist[0].location :\n\t              (throwError( types.Message([\"ASSERTION FAILURE: couldn't find a usable location\"])\n\t                          , new Location(0,0,0,0))),\n\t       appendArgs = qqlist.map(function(x){ return desugarQuasiQuotedListElement(x, pinfo, depth, loc)[0]; }),\n\t       appendSym = new symbolExpr('append');\n\t   appendSym.location = loc\n\t   var appendCall = new callExpr(appendSym, appendArgs);\n\t   appendCall.location = loc;\n\t   return [appendCall, pinfo];\n\t }\n\t\n\t // go through each item in search of unquote or unquoteSplice\n\t quasiquotedExpr.prototype.desugar = function(pinfo, depth){\n\t   depth = (typeof depth === 'undefined') ? 0 : depth;\n\t   if (depth >= 0) {\n\t     var result;\n\t     if(this.val instanceof Array){\n\t       result = desugarQuasiQuotedList(this.val, pinfo, depth+1)[0];\n\t     } else {\n\t       result = this.val.desugar(pinfo, depth+1)[0];\n\t     }\n\t   } else {\n\t     throwError( new types.Message([\"ASSERTION FAILURE: depth should have been undefined, or a natural number\"])\n\t               , this.location);\n\t   }\n\t\n\t   if (depth == 0) {\n\t     return [result, pinfo];\n\t   } else {\n\t     var qqSym = new quotedExpr(new symbolExpr('quasiquote')),\n\t         listArgs = [qqSym, result],\n\t         listSym = new symbolExpr('list'),\n\t         listCall = new callExpr(listSym, listArgs);\n\t     qqSym.parent = listArgs;\n\t     qqSym.location = this.location;\n\t     result.parent = listArgs;\n\t     listSym.parent = listCall;\n\t     listSym.location = this.location;\n\t     listCall.location = this.location;\n\t     return [listCall, pinfo]\n\t   }\n\t };\n\t \n\t symbolExpr.prototype.desugar = function(pinfo){\n\t    // if we're not in a clause, we'd better not see an \"else\"...\n\t    if(!this.isClause && (this.val === \"else\")){\n\t        var loc = (this.parent && this.parent[0] === this)? this.parent.location : this.location;\n\t        throwError(new types.Message([new types.ColoredPart(this.val, loc)\n\t                                      , \": not allowed \"\n\t                                      , new types.ColoredPart(\"here\", loc)\n\t                                      , \", because this is not a question in a clause\"]),\n\t                   loc);\n\t    }\n\t    // if this is a define without a parent, or if it's not the first child of the parent\n\t    if((this.parent && this.parent[0] !== this) && (this.val === \"define\")){\n\t        var msg = new types.Message([new types.ColoredPart(this.val, this.location)\n\t                                     , \": not allowed inside an expression\"]);\n\t        throwError(msg, this.location);\n\t    }\n\t    // if this is a keyword without a parent, or if it's not the first child of the parent\n\t    if(!this.parent &&\n\t       (plt.compiler.keywords.indexOf(this.val) > -1) && (this.val !== \"else\")){\n\t        throwError(new types.Message([new types.ColoredPart(this.val, this.location)\n\t                                      , \": expected an open parenthesis before \"\n\t                                      , this.val\n\t                                      , \", but found none\"]),\n\t                    this.location);\n\t    }\n\t    // the dot operator is not supported by WeScheme\n\t    if(this.val === \".\"){\n\t     var msg = new types.Message([this.location.source, \":\",\n\t                                   this.location.startRow.toString(), \":\",\n\t                                   this.location.startCol.toString()\n\t                                  , \": read: '.' is not supported as a symbol in WeScheme\"]);\n\t     throwError(msg\n\t                 , this.location\n\t                 , \"Error-GenericReadError\");\n\t    }\n\t    return [this, pinfo];\n\t };\n\t unsupportedExpr.prototype.desugar = function(pinfo){\n\t    this.location.span = this.errorSpan;\n\t    throwError(this.errorMsg, this.location, \"Error-GenericReadError\");\n\t }\n\t \n\t //////////////////////////////////////////////////////////////////////////////\n\t // COLLECT DEFINITIONS ///////////////////////////////////////////////////////\n\t\n\t // extend the Program class to collect definitions\n\t // Program.collectDefnitions: pinfo -> pinfo\n\t Program.prototype.collectDefinitions = function(pinfo){ return pinfo; };\n\t\n\t // bf: symbol path number boolean string -> binding:function\n\t // Helper function.\n\t function bf(name, modulePath, arity, vararity, loc){\n\t    return new functionBinding(name, modulePath, arity, vararity, [], false, loc);\n\t }\n\t defFunc.prototype.collectDefinitions = function(pinfo){\n\t    this.args.forEach(function(arg){\n\t      if(plt.compiler.keywords.indexOf(arg.val) > -1){\n\t          throwError(new types.Message([new types.ColoredPart(arg.val, arg.location),\n\t                                        \": this is a reserved keyword and cannot be used\"+\n\t                                        \" as a variable or function name\"])\n\t                     , arg.location);\n\t           \n\t               }\n\t      });\n\t \n\t    var binding = bf(this.name.val, false, this.args.length, false, this.name.location);\n\t    return pinfo.accumulateDefinedBinding(binding, this.location);\n\t };\n\t defVar.prototype.collectDefinitions = function(pinfo){\n\t    var binding = (this.expr instanceof lambdaExpr)?\n\t                    bf(this.name.val, false, this.expr.args.length, false, this.name.location)\n\t                  : new constantBinding(this.name.val, false, [], this.name.location);\n\t    return pinfo.accumulateDefinedBinding(binding, this.location);\n\t };\n\t defVars.prototype.collectDefinitions = function(pinfo){\n\t    var that = this,\n\t        fieldToAccessor = function(f){return that.stx[1].val+\"-\"+f.val;},\n\t        fieldToMutator = function(f){return \"set-\"+that.stx[1].val+\"-\"+f.val+\"!\";};\n\t    // if it's define-struct, create a struct binding\n\t    if(that.stx[0].val === \"define-struct\"){\n\t      var id      = that.stx[1].val,\n\t          fields  = that.stx[2],\n\t          constructorId = \"make-\"+id,\n\t          predicateId   = id+\"?\",\n\t          selectorIds   = fields.map(fieldToAccessor),\n\t          mutatorIds    = fields.map(fieldToMutator),\n\t          structNameLoc = that.stx[1].location,  // location of <name> in (define-struct <name> (..))\n\t          // build bindings out of these ids\n\t          structureBinding = new structBinding(id, false, fields, constructorId, predicateId,\n\t                                               selectorIds, mutatorIds, null, that.stx[1].location),\n\t          constructorBinding = bf(constructorId, false, fields.length, false, structNameLoc),\n\t          predicateBinding   = bf(predicateId, false, 1, false, structNameLoc),\n\t          mutatorBinding     = bf(id+\"-set!\", false, 1, false, structNameLoc),\n\t          refBinding         = bf(id+\"-ref\", false, 1, false, structNameLoc),\n\t // COMMENTED OUT ON PURPOSE:\n\t // these symbols are provided by separate definitions that result from desugaring, in keeping with the original compiler's behavior\n\t //        selectorBindings   = selectorIds.map(function(id){return bf(id, false, 1, false, that.location)}),\n\t // AND WOULD YOU BELIEVE IT:\n\t //  these symbols aren't exposed by the compiler either (maybe since set! isn't supported?)\n\t //        mutatorBindings    = mutatorIds.map(function(id){return bf(id, false, 2, false, that.location)}),\n\t          // assemble all the bindings together\n\t          bindings = [structureBinding, refBinding, constructorBinding, predicateBinding, mutatorBinding];\n\t      return pinfo.accumulateDefinedBindings(bindings, that.location);\n\t    } else {\n\t      return this.names.reduce(function(pinfo, id){\n\t        var binding = new constantBinding(id.val, false, [], id.location);\n\t        return pinfo.accumulateDefinedBinding(binding, that.location);\n\t      }, pinfo);\n\t    }\n\t };\n\t\n\t // When we hit a require, we have to extend our environment to include the list of module\n\t // bindings provided by that module.\n\t // FIXME: we currently override moduleName, which SHOULD just give us the proper name\n\t requireExpr.prototype.collectDefinitions = function(pinfo){\n\t    // if it's a literal, pull out the actual value. if it's a symbol use it as-is\n\t    var moduleName = (this.spec instanceof literal)? this.spec.val.toString() : this.spec.toString(),\n\t        resolvedModuleName = pinfo.modulePathResolver(moduleName, pinfo.currentModulePath),\n\t        that = this,\n\t        newPinfo;\n\t \n\t    // is this a shared WeScheme program?\n\t    function getWeSchemeModule(name){\n\t      var m = name.match(/^wescheme\\/(\\w+)$/);\n\t      return m? m[1] : false;\n\t    }\n\t \n\t    function throwModuleError(moduleName){\n\t      var bestGuess = plt.compiler.moduleGuess(that.spec.toString());\n\t      var msg = new types.Message([\"Found require of the module \"\n\t                                   , new types.ColoredPart(that.spec.toString(), that.spec.location)\n\t                                   , \", but this module is unknown.\"\n\t                                   , ((bestGuess.name===that.spec.toString())? \"\": \" Did you mean '\"+bestGuess.name+\"'?\")]);\n\t      throwError(msg, that.spec.location, \"Error-UnknownModule\");\n\t    }\n\t \n\t    // if it's an invalid moduleName, throw an error\n\t    if(!(resolvedModuleName || getWeSchemeModule(moduleName))){ throwModuleError(moduleName); }\n\t \n\t    // processModule : JS -> pinfo\n\t    // assumes the module has been assigned to window.COLLECTIONS.\n\t    // pull out the bindings, and then add them to pinfo\n\t    function processModule(moduleName){\n\t      var provides = window.COLLECTIONS[moduleName].provides;\n\t      var strToBinding = function(p){\n\t                            var b = new constantBinding(p, new symbolExpr(moduleName), false);\n\t                            b.imported = true; // WTF: Moby treats imported bindings differently, so we need to identify them\n\t                            return b;\n\t                          },\n\t          provideBindings = provides.map(strToBinding),\n\t          modulebinding = new moduleBinding(moduleName, provideBindings);\n\t      newPinfo = pinfo.accumulateModule(modulebinding).accumulateModuleBindings(provideBindings);\n\t    }\n\t \n\t    // open a *synchronous* GET request -- FIXME to use callbacks?\n\t    var url = window.location.protocol+\"//\"+window.location.host\n\t              + (getWeSchemeModule(moduleName)?  \"/loadProject?publicId=\"+(getWeSchemeModule(moduleName))\n\t                                              : \"/js/mzscheme-vm/collects/\"+moduleName+\".js\");\n\t \n\t    // if the module is already loaded, we can just process without loading\n\t    if(window.COLLECTIONS && window.COLLECTIONS[moduleName]){\n\t      processModule(moduleName);\n\t    } else {\n\t      jQuery.ajax({\n\t           url:    url,\n\t           success: function(result) {\n\t                      // if it's not a native module, manually assign it to window.COLLECTIONS\n\t                      if(getWeSchemeModule(moduleName)){\n\t                        var program = (0,eval)('(' + result + ')');\n\t                        // Create the COLLECTIONS array, if it doesn't exist\n\t                        if(window.COLLECTIONS === undefined){ window.COLLECTIONS = []; }\n\t                        // extract the sourcecode\n\t                        var lexemes     = plt.compiler.lex(program.source.src, moduleName),\n\t                            AST         = plt.compiler.parse(lexemes),\n\t                            desugared   = plt.compiler.desugar(AST)[0],  // includes [AST, pinfo]\n\t                            pinfo       = plt.compiler.analyze(desugared),\n\t                            objectCode  = plt.compiler.compile(desugared, pinfo);\n\t                        window.COLLECTIONS[moduleName] = {\n\t                                    'name': moduleName,\n\t                                    'bytecode' : (0,eval)('(' + objectCode.bytecode + ')'),\n\t                                    'provides' : objectCode.provides\n\t                                };\n\t                      // otherwise, simply evaluate the raw JS\n\t                      } else {\n\t                        eval(result);\n\t                      }\n\t                  if(result){ processModule(moduleName); }\n\t                  else { throwModuleError(moduleName); }\n\t                },\n\t           error: function (error) { throwModuleError(moduleName); },\n\t           async: false\n\t      });\n\t    }\n\t    return newPinfo;\n\t };\n\t // BINDING STRUCTS ///////////////////////////////////////////////////////\n\t function provideBindingId(symbl){ this.symbl = symbl;}\n\t function provideBindingStructId(symbl){ this.symbl = symbl; }\n\t\n\t //////////////////////////////////////////////////////////////////////////////\n\t // COLLECT PROVIDES //////////////////////////////////////////////////////////\n\t\n\t // extend the Program class to collect provides\n\t // Program.collectProvides: pinfo -> pinfo\n\t Program.prototype.collectProvides = function(pinfo){ return pinfo; };\n\t provideStatement.prototype.collectProvides = function(pinfo){\n\t    var that = this;\n\t \n\t    function addProvidedName(id){ pinfo.providedNames.put(id, new provideBindingId(id)); }\n\t \n\t    // collectProvidesFromClause : pinfo clause -> pinfo\n\t    function collectProvidesFromClause(pinfo, clause){\n\t      // if it's a symbol, make sure it's defined (otherwise error)\n\t      if (clause instanceof symbolExpr){\n\t        if(pinfo.definedNames.containsKey(clause.val)){\n\t          addProvidedName(clause.val);\n\t          return pinfo;\n\t        } else {\n\t          var msg = new types.Message([\"The name '\"\n\t                                       , new types.ColoredPart(clause.toString(), clause.location)\n\t                                       , \"', is not defined in the program, and cannot be provided.\"]);\n\t          throwError(msg, clause.location);\n\t        }\n\t      // if it's an array, make sure the struct is defined (otherwise error)\n\t      // NOTE: ONLY (struct-out id) IS SUPPORTED AT THIS TIME\n\t      } else if(clause instanceof Array){\n\t          if(pinfo.definedNames.containsKey(clause[1].val) &&\n\t             (pinfo.definedNames.get(clause[1].val) instanceof structBinding)){\n\t              // add the entire structBinding to the provided binding, so we\n\t              // can access fieldnames, predicates, and permissions later\n\t              var b = pinfo.definedNames.get(clause[1].val),\n\t                  fns = [b.name, b.constructor, b.predicate].concat(b.accessors, b.mutators);\n\t                  fns.forEach(addProvidedName);\n\t              return pinfo;\n\t          } else {\n\t            throwError(new types.Message([\"The struct '\"\n\t                                          , new types.ColoredPart(clause[1].toString(), clause[1].location)\n\t                                          , \"', is not defined in the program, and cannot be provided\"])\n\t                       , clause.location);\n\t          }\n\t      // anything with a different format throws an error\n\t      } else {\n\t        throw \"Impossible: all invalid provide clauses should have been filtered out!\";\n\t      }\n\t    }\n\t    return this.clauses.reduce(collectProvidesFromClause, pinfo);\n\t  };\n\t \n\t //////////////////////////////////////////////////////////////////////////////\n\t // ANALYZE USES //////////////////////////////////////////////////////////////\n\t\n\t // extend the Program class to analyzing uses\n\t // Program.analyzeUses: pinfo -> pinfo\n\t Program.prototype.analyzeUses = function(pinfo, env){ return pinfo; };\n\t defVar.prototype.analyzeUses = function(pinfo){\n\t    // extend the environment with the value or function, then analyze the expression\n\t    pinfo.env.extend((this.expr instanceof lambdaExpr)?\n\t                     bf(this.name.val, false, this.expr.args.length, false, this.location)\n\t                     :  new constantBinding(this.name.val, false, [], this.name.location));\n\t    return this.expr.analyzeUses(pinfo, pinfo.env);\n\t };\n\t defVars.prototype.analyzeUses = function(pinfo){\n\t    this.names.forEach(function(id){\n\t        pinfo.env.extend(new constantBinding(id.val, false, [], id.location));\n\t      });\n\t    return this.expr.analyzeUses(pinfo, pinfo.env);\n\t };\n\t // analyzeClosureUses : expr pinfo -> pinfo\n\t // given the body of a lambda, an environment and a pinfo, analyze the body\n\t function analyzeClosureUses(funcExpr, pinfo){\n\t    // 1) make a copy of all the bindings\n\t    var oldEnv = pinfo.env,\n\t        oldKeys = oldEnv.bindings.keys(),\n\t        newBindings = types.makeLowLevelEqHash();\n\t    oldKeys.forEach(function(k){newBindings.put(k, oldEnv.bindings.get(k));});\n\t \n\t    // 2) make a copy of the environment, using the newly-copied bindings, and\n\t    //    add the args to this environment\n\t    var newEnv = new plt.compiler.env(newBindings),\n\t        newEnv = funcExpr.args.reduce(function(env, arg){\n\t                                  return env.extend(new constantBinding(arg.val, false, [], arg.location));\n\t                                }, newEnv);\n\t    // 3) install the post-arg env into pinfo, analyze the body, and\n\t    //    install the original environment\n\t    pinfo.env = newEnv;\n\t    pinfo = funcExpr.body.analyzeUses(pinfo, newEnv);\n\t    pinfo.env = oldEnv;\n\t    return pinfo;\n\t }\n\t defFunc.prototype.analyzeUses = function(pinfo){\n\t    // extend the env to include the function binding, then analyze the body as if it's a lambda\n\t    pinfo.env = pinfo.env.extend(bf(this.name.val, false, this.args.length, false, this.name.location));\n\t    return analyzeClosureUses(this, pinfo);\n\t };\n\t lambdaExpr.prototype.analyzeUses = function(pinfo, env){\n\t    return analyzeClosureUses(this, pinfo);\n\t };\n\t beginExpr.prototype.analyzeUses = function(pinfo, env){\n\t    return this.exprs.reduce(function(p, expr){return expr.analyzeUses(p, env);}, pinfo);\n\t };\n\t localExpr.prototype.analyzeUses = function(pinfo, env){\n\t    var pinfoAfterDefs = this.defs.reduce(function(pinfo, d){ return d.analyzeUses(pinfo, env); }, pinfo);\n\t    return this.body.analyzeUses(pinfoAfterDefs, pinfoAfterDefs.env);\n\t };\n\t callExpr.prototype.analyzeUses = function(pinfo, env){\n\t    return [this.func].concat(this.args).reduce(function(p, arg){\n\t                            return (arg instanceof Array)?\n\t                                    // if arg is a subexpression, reduce THAT\n\t                                    arg.reduce((function(pinfo, p){return p.analyzeUses(pinfo, pinfo.env);})\n\t                                               , pinfo)\n\t                                    // otherwise analyze and return\n\t                                    : arg.analyzeUses(p, env);\n\t                            }, pinfo);\n\t }\n\t ifExpr.prototype.analyzeUses = function(pinfo, env){\n\t    var exps = [this.predicate, this.consequence, this.alternative];\n\t    return exps.reduce(function(p, exp){\n\t                            return exp.analyzeUses(p,env);\n\t                            }, pinfo);\n\t };\n\t symbolExpr.prototype.analyzeUses = function(pinfo, env){\n\t    // if this is a keyword without a parent, or if it's not the first child of the parent\n\t    if((plt.compiler.keywords.indexOf(this.val) > -1) &&\n\t       (!this.parent || this.parent[0]!== this) || (this.parent instanceof couple)){\n\t        throwError(new types.Message([new types.ColoredPart(this.val, this.location)\n\t                                      , \": expected an open parenthesis before \"\n\t                                      , this.val\n\t                                      , \", but found none\"]),\n\t                    this.location);\n\t    }\n\t    var binding = env.lookup_context(this.val);\n\t    if(binding){\n\t      this.bindingLoc = binding.loc; //  keep track of where this symbol was bound\n\t      return pinfo.accumulateBindingUse(binding, pinfo);\n\t    } else {\n\t      return pinfo.accumulateFreeVariableUse(this.val, pinfo);\n\t    }\n\t };\n\t\n\t\n\t/////////////////////////////////////////////////////////////\n\t function analyze(programs){\n\t    return programAnalyzeWithPinfo(programs, plt.compiler.getBasePinfo(\"base\"));\n\t }\n\t \n\t // programAnalyzerWithPinfo : [listof Programs], pinfo -> pinfo\n\t // build up pinfo by looking at definitions, provides and uses\n\t function programAnalyzeWithPinfo(programs, pinfo){\n\t   // collectDefinitions: [listof Programs] pinfo -> pinfo\n\t   // Collects the definitions either imported or defined by this program.\n\t   function collectDefinitions(programs, pinfo){\n\t     return programs.reduce((function(pinfo, p){ return p.collectDefinitions(pinfo); })\n\t                            , pinfo);\n\t   }\n\t   // collectProvides: [listof Programs] pinfo -> pinfo\n\t   // Walk through the program and collect all the provide statements.\n\t   function collectProvides(programs, pinfo){\n\t      return programs.reduce((function(pinfo, p){ return p.collectProvides(pinfo); })\n\t                             , pinfo);\n\t   }\n\t   // analyzeUses: [listof Programs] pinfo -> pinfo\n\t   // Collects the uses of bindings that this program uses.\n\t    function analyzeUses(programs, pinfo){\n\t      return programs.reduce((function(pinfo, p){ return p.analyzeUses(pinfo, pinfo.env); })\n\t                             , pinfo);\n\t    }\n\t    var pinfo1 = collectDefinitions(programs, pinfo);\n\t    var pinfo2 = collectProvides(programs, pinfo1);\n\t    return analyzeUses(programs, pinfo2);\n\t }\n\t \n\t /////////////////////\n\t /* Export Bindings */\n\t /////////////////////\n\t plt.compiler.desugar = function(p, pinfo, debug){\n\t    var start       = new Date().getTime();\n\t    try {\n\t      var ASTandPinfo = desugarProgram(p, pinfo, true), // do the actual work\n\t          program     = ASTandPinfo[0],\n\t          pinfo       = ASTandPinfo[1];\n\t    } catch (e) { console.log(\"DESUGARING ERROR\"); throw e; }\n\t    var end = new Date().getTime();\n\t    if(debug){\n\t      console.log(\"Desugared in \"+(Math.floor(end-start))+\"ms\");\n\t      console.log(program);\n\t      console.log(program.toString());\n\t    }\n\t    return ASTandPinfo;\n\t  };\n\t plt.compiler.analyze = function(program, debug){\n\t    var start       = new Date().getTime();\n\t    try { var pinfo       = analyze(program); }             // do the actual work\n\t    catch (e) { console.log(\"ANALYSIS ERROR\"); throw e; }\n\t    var end         = new Date().getTime();\n\t    if(debug){\n\t      console.log(\"Analyzed in \"+(Math.floor(end-start))+\"ms\");\n\t//      console.log(pinfo.toString());\n\t    }\n\t    return pinfo;\n\t  };\n\t plt.compiler.provideBindingId = provideBindingId;\n\t plt.compiler.provideBindingStructId = provideBindingStructId;\n\t})();\n\t\n\tmodule.exports = plt.compiler;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// if not defined, declare the compiler object as part of plt\n\twindow.plt   = window.plt   || {};\n\tplt.compiler = __webpack_require__(2);\n\t/*\n\t TODO\n\t -\n\t */\n\t\n\t//////////////////////////////////////////////////////////////////////////////\n\t/////////////////// MODULE BINDINGS //////////////////////////\n\t(function (){\n\t \n\t  var moduleBinding   = plt.compiler.moduleBinding;\n\t  var functionBinding = plt.compiler.functionBinding;\n\t  var constantBinding = plt.compiler.constantBinding;\n\t \n\t  // given a moduleName, return a function that converts binding specs into function bindings\n\t  function makeFunctionBinding(modulePath){\n\t    return function(binding){\n\t            binding[3] = binding[3] || [];      // permissions default to none\n\t            binding[4] = binding[4] || false;   // isCps defaults to false\n\t            binding[5] = binding[5] || false;   // loc defaults to false\n\t            return new functionBinding(binding[0], modulePath, binding[1], binding[2], binding[3], binding[4], binding[5]);\n\t           };\n\t  }\n\t  \n\t  // kernel-misc-module\n\t  var kernelMiscModule  = new moduleBinding(\"moby/runtime/kernel/misc\",\n\t                                           [[\"verify-boolean-branch-value\", 2]\n\t                                            ,[\"throw-cond-exhausted-error\", 1 ]\n\t                                            ,[\"'check-operator-is-function\", 3]\n\t                                            ,[\"print-values\", 0]\n\t                                           ].map(makeFunctionBinding('\"moby/runtime/kernel/misc\"'))\n\t  );\n\t  \n\t  // foreign-module\n\t  var foreignModule     = new moduleBinding(\"moby/foreign\",\n\t                                           [[\"get-js-object\", 2, false, [\"android.permission.FOREIGN-FUNCTION-INTERFACE\"]]\n\t                                           ].map(makeFunctionBinding('\"moby/foreign\"'))\n\t  );\n\t  \n\t  // world-effects-module\n\t  var worldEffectsModule= new moduleBinding(\"world-effects\",\n\t                                            [[\"make-effect:none\", 0, false]\n\t                                             ,[\"make-effect:beep\", 0, false, [\"android.permission.VIBRATE\"]]\n\t                                             ,[\"make-effect:play-dtmf-tone\", 2, false]\n\t                                             ,[\"make-effect:send-sms\", 2, false, [\"android.permission.SEND-SMS\"]]\n\t                                             ,[\"make-effect:play-sound\", 1, false, [\"android.permission.INTERNET\"]]\n\t                                             ,[\"make-effect:stop-sound\", 1, false]\n\t                                             ,[\"make-effect:pause-sound\", 1, false]\n\t                                             ,[\"make-effect:set-sound-volume\", 1, false]\n\t                                             ,[\"make-effect:set-beep-volume\", 1, false]\n\t                                             ,[\"make-effect:raise-sound-volume\", 0, false]\n\t                                             ,[\"make-effect:lower-sound-volume\", 1, false]\n\t                                             ,[\"make-effect:set-wake-lock\", 1, false, [\"android.permission.WAKE-LOCK\"]]\n\t                                             ,[\"make-effect:release-wake-lock\", 1, false, [\"android.permission.WAKE-LOCK\"]]\n\t                                             ,[\"make-effect:pick-playlist\", 1, false]\n\t                                             ,[\"make-effect:pick-random\", 2, false]\n\t                                             ].map(makeFunctionBinding('\"moby/world-effects\"'))\n\t  );\n\t  \n\t  // world-handlers-module\n\t  var worldHandlersModule=new moduleBinding(\"world-config\",\n\t                                           [[\"on-tick\", 1, true]\n\t                                            ,[\"initial-effect\", 1, false]\n\t                                            ,[\"on-key\", 1, false]\n\t                                            ,[\"on-key!\", 2, false]\n\t                                            ,[\"on-mouse\", 1, false]\n\t                                            ,[\"on-tap\", 1, false]\n\t                                            ,[\"on-tilt\", 1, false]\n\t                                            ,[\"on-redraw\", 1, false]\n\t                                            ,[\"to-draw\", 1, false]\n\t                                            ,[\"on-draw\", 2, false]\n\t                                            ,[\"stop-when\", 1, false]\n\t                                           ].map(makeFunctionBinding('\"moby/world-handlers\"'))\n\t  );\n\t  \n\t  // bootstrap-teachpack\n\t  var bootstrapTeachpackFunctions = [[\"START\", 14, false] ,[\"test-frame\", 1, false] ,[\"sine\", 1, false]\n\t                                     ,[\"cosine\", 1, false] ,[\"tangent\", 1, false]];\n\t  var bootstrapTeachpack = new moduleBinding(\"bootstrap/bootstrap-teachpack\",\n\t                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap/bootstrap-teachpack\"'))),\n\t      bootstrapTeachpack2011 = new moduleBinding(\"bootstrap2011/bootstrap-teachpack\",\n\t                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2011/bootstrap-teachpack\"'))),\n\t      bootstrapTeachpack2012 = new moduleBinding(\"bootstrap2012/bootstrap-teachpack\",\n\t                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2012/bootstrap-teachpack\"'))),\n\t      bootstrapTiltTeachpack2012 = new moduleBinding(\"bootstrap2012/bootstrap-tilt-teachpack\",\n\t                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2012/bootstrap-tilt-teachpack\"'))),\n\t      bootstrapTeachpack2014 = new moduleBinding(\"bootstrap2014/bootstrap-teachpack\",\n\t                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2014/bootstrap-teachpack\"'))),\n\t      bootstrapTiltTeachpack2014 = new moduleBinding(\"bootstrap2014/bootstrap-tilt-teachpack\",\n\t                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2014/bootstrap-tilt-teachpack\"'))),\n\t      bootstrapTeachpack2015 = new moduleBinding(\"bootstrap2015/bootstrap-teachpack\",\n\t                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2015/bootstrap-teachpack\"'))),\n\t      bootstrapTiltTeachpack2015 = new moduleBinding(\"bootstrap2015/bootstrap-tilt-teachpack\",\n\t                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2015/bootstrap-tilt-teachpack\"')));\n\t \n\t  // cage-teachpack\n\t  var cageTeachpack = new moduleBinding(\"bootstrap/cage-teachpack\",[[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap/cage-teachpack\"'))),\n\t      cageTeachpack2011 = new moduleBinding(\"bootstrap2011/cage-teachpack\",\n\t                                            [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2011/cage-teachpack\"'))),\n\t      cageTeachpack2012 = new moduleBinding(\"bootstrap2012/cage-teachpack\",\n\t                                            [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2012/cage-teachpack\"'))),\n\t      cageTeachpack2014 = new moduleBinding(\"bootstrap2014/cage-teachpack\",\n\t                                            [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2014/cage-teachpack\"')));\n\t \n\t  // function-teachpack\n\t  var functionTeachpack = new moduleBinding(\"bootstrap/function-teachpack\",\n\t                                            [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap/function-teachpack\"'))),\n\t      functionTeachpack2011 = new moduleBinding(\"bootstrap2011/function-teachpack\",\n\t                                                [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2011/function-teachpack\"'))),\n\t      functionTeachpack2012 = new moduleBinding(\"bootstrap2012/function-teachpack\",\n\t                                                [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2012/function-teachpack\"'))),\n\t      functionTeachpack2014 = new moduleBinding(\"bootstrap2014/function-teachpack\",\n\t                                                [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2014/function-teachpack\"'))),\n\t      functionTeachpack2015 = new moduleBinding(\"bootstrap2015/function-teachpack\",\n\t                                                [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2015/function-teachpack\"')));\n\t  \n\t  // location module\n\t  var locationModule     = new moduleBinding(\"location\",\n\t                                             [[\"get-latitude\",      0, false, [\"android.permission.LOCATION\"]]\n\t                                              ,[\"get-longitude\",    0, false, [\"android.permission.LOCATION\"]]\n\t                                              ,[\"get-altitude\",     0, false, [\"android.permission.LOCATION\"]]\n\t                                              ,[\"get-bearing\",      0, false, [\"android.permission.LOCATION\"]]\n\t                                              ,[\"get-speed\",        0, false, [\"android.permission.LOCATION\"]]\n\t                                              ,[\"location-distance\", 0, false, [\"android.permission.LOCATION\"]]\n\t                                              ].map(makeFunctionBinding('\"moby/geolocation\"'))\n\t  );\n\t\n\t  // accelerometer library\n\t  var tiltModule        = new moduleBinding(\"tilt\",\n\t                                             [[\"get-x-acceleration\",  0, false, [\"android.permission.TILT\"]]\n\t                                              ,[\"get-y-acceleration\", 0, false, [\"android.permission.TILT\"]]\n\t                                              ,[\"get-z-acceleration\", 0, false, [\"android.permission.TILT\"]]\n\t                                              ,[\"get-azimuth\",        0, false, [\"android.permission.TILT\"]]\n\t                                              ,[\"get-pitch\",          0, false, [\"android.permission.TILT\"]]\n\t                                              ,[\"get-roll\",           0, false, [\"android.permission.TILT\"]]\n\t                                              ].map(makeFunctionBinding('\"moby/tilt\"'))\n\t  );\n\t\n\t  // telephony module\n\t  var telephonyModule    = new moduleBinding(\"telephony\",\n\t                                             [[\"get-signal-strength\",  0, false, [\"android.permission.TELEPHONY\"]]\n\t                                             ].map(makeFunctionBinding('\"moby/net\"'))\n\t  );\n\t\n\t  // net module\n\t  var netModule         = new moduleBinding(\"net\",\n\t                                             [[\"get-url\",  1, false, [\"android.permission.INTERNET\"]]\n\t                                             ].map(makeFunctionBinding('\"moby/net\"'))\n\t  );\n\t                                              \n\t  // parser module\n\t  var parserModule      = new moduleBinding(\"parser\",\n\t                                             [[\"xml->s-sexp\",  1, false]\n\t                                             ].map(makeFunctionBinding('\"moby/parser\"'))\n\t  );\n\t\n\t  // js-world module\n\t  var jsWorldModule     = new moduleBinding(\"jsworld\",\n\t                                            [[\"js-big-bang\",  1, false]\n\t                                             ,[\"big-bang\",    1, false]\n\t                                             ,[\"js-div\",      0, false]\n\t                                             ,[\"js-p\",        0, false]\n\t                                             ,[\"js-button\",   2, false]\n\t                                             ,[\"js-button!\",  2, false]\n\t                                             ,[\"js-node\",     1, false]\n\t                                             ,[\"js-text\",    1, false]\n\t                                             ,[\"js-select\",   2, false]\n\t                                             ,[\"js-img\",      1, false, [\"android.permission.INTERNET\"]]\n\t                                             ].map(makeFunctionBinding('\"moby/jsworld\"'))\n\t  );\n\t  \n\t  // world\n\t  var worldModule       = new moduleBinding(\"world\",\n\t                                           worldHandlersModule.bindings.concat(worldEffectsModule.bindings,\n\t                                           [\"key=?\"\n\t                                            ,\"play-sound\"\n\t                                            ,\"animate\"\n\t                                            ,\"big-bang\"\n\t                                            // colors\n\t                                            ,\"make-color\"\n\t                                            ,\"color?\"\n\t                                            ,\"color-red\"\n\t                                            ,\"color-green\"\n\t                                            ,\"color-blue\"\n\t                                            ,\"color-alpha\"\n\t                                            \n\t                                            ,\"empty-scene\"\n\t                                            ,\"empty-image\"\n\t                                            ,\"scene+line\"\n\t                                            ,\"put-image\"\n\t                                            ,\"place-image\"\n\t                                            ,\"place-image/align\"\n\t                                            ,\"put-pinhole\"\n\t                                            ,\"circle\"\n\t                                            ,\"star\"\n\t                                            ,\"polygon\"\n\t                                            ,\"radial-star\"\n\t                                            ,\"star-polygon\"\n\t                                            ,\"nw:rectangle\"\n\t                                            ,\"rectangle\"\n\t                                            ,\"regular-polygon\"\n\t                                            ,\"rhombus\"\n\t                                            ,\"square\"\n\t                                            ,\"triangle\"\n\t                                            ,\"triangle/sas\"\n\t                                            ,\"triangle/sss\"\n\t                                            ,\"triangle/ass\"\n\t                                            ,\"triangle/ssa\"\n\t                                            ,\"triangle/aas\"\n\t                                            ,\"triangle/asa\"\n\t                                            ,\"triangle/saa\"\n\t                                            ,\"right-triangle\"\n\t                                            ,\"isosceles-triangle\"\n\t                                            ,\"ellipse\"\n\t                                            ,\"line\"\n\t                                            ,\"add-line\"\n\t                                            ,\"overlay\"\n\t                                            ,\"overlay/xy\"\n\t                                            ,\"overlay/align\"\n\t                                            ,\"underlay\"\n\t                                            ,\"underlay/xy\"\n\t                                            ,\"underlay/align\"\n\t                                            ,\"beside\"\n\t                                            ,\"beside/align\"\n\t                                            ,\"above\"\n\t                                            ,\"above/align\"\n\t                                            ,\"rotate\"\n\t                                            ,\"scale\"\n\t                                            ,\"scale/xy\"\n\t                                            ,\"crop\"\n\t                                            ,\"frame\"\n\t                                            ,\"flip-horizontal\"\n\t                                            ,\"flip-vertical\"\n\t                                            ,\"text\"\n\t                                            ,\"text/font\"\n\t                                            ,\"video-url\"       // needs network\n\t                                            ,\"video/url\"       // needs network\n\t                                            ,\"bitmap/url\"      // needs network\n\t                                            ,\"image-url\"       // needs network\n\t                                            ,\"open-image-url\"  // needs network\n\t                                            ,\"image?\"\n\t                                            ,\"image=?\"\n\t                                            ,\"image-width\"\n\t                                            ,\"image-height\"\n\t                                            \n\t                                            // mouse-events\n\t                                            ,\"mouse-event?\"\n\t                                            ,\"mouse=?\"\n\t                                            \n\t                                            ,\"image->color-list\"\n\t                                            ,\"color-list->image\"\n\t                                            ,\"color-list->bitmap\"\n\t                                            \n\t                                            ,\"image-baseline\"\n\t                                            ,\"mode?\"\n\t                                            ,\"image-color?\"\n\t                                            ,\"name->color\"\n\t                                            ,\"x-place?\"\n\t                                            ,\"y-place?\"\n\t                                            ,\"angle?\"\n\t                                            ,\"side-count?\"\n\t                                            ,\"step-count?\"\n\t                                            ].map(function(binding){\n\t                                                    var needsPermission = [\"video/url\", \"bitmap/url\", \"image-url\", \"open-image-url\"];\n\t                                                    var permissions = (needsPermission.indexOf(binding) > -1)? [\"android.permission.INTERNET\"] : [];\n\t                                                    return new constantBinding(binding, '\"moby/world\"', permissions, false);\n\t                                                  }))\n\t  );\n\t\n\t  // top-level\n\t  var topLevelModule = new moduleBinding(\"moby/topLevel\",\n\t                                         [[\"<\", 2, true] // Numerics\n\t                                         ,[\"<=\", 2, true]\n\t                                         ,[\"=\", 2, true]\n\t                                         ,[\">\", 2, true]\n\t                                         ,[\">=\", 2, true]\n\t                                         \n\t                                         ,[\"=~\", 3]\n\t                                         ,[\"number->string\", 1]\n\t                                         ,[\"even?\", 1]\n\t                                         ,[\"odd?\", 1]\n\t                                         ,[\"positive?\", 1]\n\t                                         ,[\"negative?\", 1]\n\t                                         ,[\"number?\", 1]\n\t                                         ,[\"rational?\", 1]\n\t                                         ,[\"quotient\", 2]\n\t                                         ,[\"remainder\", 2]\n\t                                         ,[\"numerator\", 1]\n\t                                         ,[\"denominator\", 1]\n\t                                         ,[\"integer?\", 1]\n\t                                         ,[\"real?\", 1]\n\t                                         ,[\"abs\", 1]\n\t                                         ,[\"acos\", 1]\n\t                                         ,[\"add1\", 1]\n\t                                         ,[\"angle\", 1]\n\t                                         ,[\"asin\", 1]\n\t                                         ,[\"atan\", 1, true]           // arity is either 1 or 2\n\t                                         ,[\"ceiling\", 1]\n\t                                         ,[\"complex?\", 1]\n\t                                         ,[\"conjugate\", 1]\n\t                                         ,[\"cos\", 1]\n\t                                         ,[\"cosh\", 1]\n\t                                         ,[\"denominator\", 1]\n\t                                         ,[\"even?\", 1]\n\t                                         ,[\"exact->inexact\", 1]\n\t                                         ,[\"exact?\", 1]               // *\n\t                                         ,[\"exp\", 1]\n\t                                         ,[\"expt\", 2]\n\t                                         ,[\"floor\", 1]\n\t                                         ,[\"gcd\", 1, true]\n\t                                         ,[\"imag-part\", 1]\n\t                                         ,[\"inexact->exact\", 1]\n\t                                         ,[\"inexact?\", 1]\n\t                                         ,[\"integer->char\", 1]\n\t                                         ,[\"integer-sqrt\", 1]         // *\n\t                                         ,[\"integer?\", 1]\n\t                                         ,[\"lcm\", 1, true]\n\t                                         ,[\"log\", 1]\n\t                                         ,[\"magnitude\", 1]\n\t                                         ,[\"make-polar\", 2]           // *\n\t                                         ,[\"make-rectangular\", 2]     // *\n\t                                         ,[\"max\", 1, true]\n\t                                         ,[\"min\", 1, true]\n\t                                         ,[\"modulo\", 2]\n\t                                         ,[\"negative?\", 1]\n\t                                         ,[\"number?\", 1]\n\t                                         ,[\"numerator\", 1]\n\t                                         ,[\"odd?\", 1]\n\t                                         ,[\"positive?\", 1]\n\t                                         ,[\"random\", 1]\n\t                                         ,[\"rational?\", 1]\n\t                                         ,[\"real-part\", 1]\n\t                                         ,[\"real?\", 1]\n\t                                         ,[\"round\", 1]\n\t                                         ,[\"sgn\", 1]\n\t                                         ,[\"sin\", 1]\n\t                                         ,[\"sinh\", 1]\n\t                                         //,[\"sq\", 1]\n\t                                         ,[\"sqr\", 1]\n\t                                         ,[\"sqrt\", 1]\n\t                                         ,[\"sub1\", 1]\n\t                                         ,[\"tan\", 1]\n\t                                         ,[\"zero?\", 1]\n\t                                         \n\t                                         ,[\"+\", 0, true]\n\t                                         ,[\"-\", 1, true]\n\t                                         ,[\"*\", 0, true]\n\t                                         ,[\"/\", 1, true]\n\t                                         \n\t                                         // Logic\n\t                                         ,[\"not\", 1]\n\t                                         ,[\"false?\", 1]\n\t                                         ,[\"boolean?\", 1]\n\t                                         ,[\"boolean=?\", 2]\n\t                                         \n\t                                         // Symbols\n\t                                         ,[\"symbol->string\", 1]\n\t                                         ,[\"symbol=?\", 2]\n\t                                         ,[\"symbol?\", 1]\n\t                                         \n\t                                         // Lists\n\t                                         ,[\"append\", 0, true]\n\t                                         ,[\"assq\", 2]                 // *\n\t                                         ,[\"assv\", 2]                 // *\n\t                                         ,[\"assoc\", 2]                 // *\n\t                                         ,[\"caaar\", 1]\n\t                                         ,[\"caadr\", 1]\n\t                                         ,[\"caar\", 1]\n\t                                         ,[\"cadar\", 1]\n\t                                         ,[\"cadddr\", 1]\n\t                                         ,[\"caddr\", 1]\n\t                                         ,[\"cadr\", 1]\n\t                                         ,[\"car\", 1]\n\t                                         ,[\"cddar\", 1]\n\t                                         ,[\"cdddr\", 1]\n\t                                         ,[\"cddr\", 1]\n\t                                         ,[\"cdr\", 1]\n\t                                         ,[\"cdaar\", 1]\n\t                                         ,[\"cdadr\", 1]\n\t                                         ,[\"cdar\", 1]\n\t                                         ,[\"cons?\", 1]\n\t                                         ,[\"list?\", 1]\n\t                                         ,[\"cons\", 2]\n\t                                         ,[\"empty?\", 1]\n\t                                         ,[\"length\", 1]\n\t                                         ,[\"list\", 0, true]\n\t                                         ,[\"list*\", 1, true]\n\t                                         ,[\"list-ref\", 2]\n\t                                         ,[\"remove\", 2]\n\t                                         ,[\"member\", 2]\n\t                                         ,[\"member?\", 2]\n\t                                         ,[\"memq\", 2]\n\t                                         ,[\"memv\", 2]\n\t                                         ,[\"null?\", 1]\n\t                                         ,[\"pair?\", 1]\n\t                                         ,[\"rest\", 1]\n\t                                         ,[\"reverse\", 1]\n\t                                         ,[\"first\", 1]\n\t                                         ,[\"second\", 1]\n\t                                         ,[\"third\", 1]\n\t                                         ,[\"fourth\", 1]\n\t                                         ,[\"fifth\", 1]\n\t                                         ,[\"sixth\", 1]\n\t                                         ,[\"seventh\", 1]\n\t                                         ,[\"eighth\", 1]\n\t                                         \n\t                                         // We're commenting out the mutation operation on pairs\n\t                                         // because they're not supported in ISL/ASL anymore.\n\t                                         //;,[\"set-car! 2]\n\t                                         //;,[\"set-cdr! 2]\n\t                                         \n\t                                         // Box\n\t                                         ,[\"box\", 1]\n\t                                         ,[\"unbox\", 1]\n\t                                         ,[\"set-box!\", 2]\n\t                                         ,[\"box?\", 1]\n\t                                         \n\t                                         // Posn\n\t                                         ,[\"make-posn\", 2]\n\t                                         ,[\"posn-x\", 1]\n\t                                         ,[\"posn-y\", 1]\n\t                                         ,[\"posn?\", 1]\n\t                                         \n\t                                         // Characters\n\t                                         ,[\"char->integer\", 1]\n\t                                         ,[\"char-alphabetic?\", 1]\n\t                                         ,[\"char-ci<=?\", 2, true]\n\t                                         ,[\"char-ci<?\", 2, true]\n\t                                         ,[\"char-ci=?\", 2, true]\n\t                                         ,[\"char-ci>=?\", 2, true]\n\t                                         ,[\"char-ci>?\", 2, true]\n\t                                         ,[\"char-downcase\", 1]\n\t                                         ,[\"char-lower-case?\", 1]\n\t                                         ,[\"char-numeric?\", 1]\n\t                                         ,[\"char-upcase\", 1]\n\t                                         ,[\"char-upper-case?\", 1]\n\t                                         ,[\"char-whitespace?\", 1]\n\t                                         ,[\"char<=?\", 2, true]\n\t                                         ,[\"char<?\", 2, true]\n\t                                         ,[\"char=?\", 2, true]\n\t                                         ,[\"char>=?\", 2, true]\n\t                                         ,[\"char>?\", 2, true]\n\t                                         ,[\"char?\", 1]\n\t                                         \n\t                                         // Strings\n\t                                         ,[\"format\", 1, true]\n\t                                         ,[\"list->string\", 1]\n\t                                         ,[\"make-string\", 2]\n\t                                         ,[\"replicate\", 2]\n\t                                         ,[\"string\", 0, true]\n\t                                         ,[\"string->list\", 1]\n\t                                         ,[\"string->number\", 1]\n\t                                         ,[\"string->symbol\", 1]\n\t                                         ,[\"string-alphabetic?\", 1]\n\t                                         ,[\"string-append\", 0, true]\n\t                                         ,[\"string-ci<=?\", 2, true]\n\t                                         ,[\"string-ci<?\", 2, true]\n\t                                         ,[\"string-ci=?\", 2, true]\n\t                                         ,[\"string-ci>=?\", 2, true]\n\t                                         ,[\"string-ci>?\", 2, true]\n\t                                         ,[\"string-copy\", 1]\n\t                                         ,[\"string-length\", 1]\n\t                                         ,[\"string-lower-case?\", 1]   // *\n\t                                         ,[\"string-numeric?\", 1]      // *\n\t                                         ,[\"string-ref\", 2]\n\t                                         ,[\"string-upper-case?\", 1]   // *\n\t                                         ,[\"string-whitespace?\", 1]   // *\n\t                                         ,[\"string<=?\", 2, true]\n\t                                         ,[\"string<?\", 2, true]\n\t                                         ,[\"string=?\", 2, true]\n\t                                         ,[\"string>=?\", 2, true]\n\t                                         ,[\"string>?\", 2, true]\n\t                                         ,[\"string?\", 1]\n\t                                         ,[\"substring\", 3 ]\n\t                                         ,[\"string-ith\", 2]\n\t                                         ,[\"int->string\", 1]\n\t                                         ,[\"string->int\", 1]\n\t                                         ,[\"explode\", 1]\n\t                                         ,[\"implode\", 1]\n\t                                         \n\t                                         // Eof\n\t                                         ,[\"eof-object?\", 1]\n\t                                         \n\t                                         // Misc\n\t                                         ,[\"=~\", 3]\n\t                                         ,[\"eq?\", 2]\n\t                                         ,[\"equal?\", 2]\n\t                                         ,[\"equal~?\", 3]\n\t                                         ,[\"eqv?\", 2]\n\t                                         ,[\"error\", 2]\n\t                                         \n\t                                         ,[\"identity\", 1]\n\t                                         ,[\"struct?\", 1]\n\t                                         ,[\"current-seconds\", 0]\n\t                                         \n\t                                         // Higher-Order Functions\n\t                                         ,[\"andmap\", 1, true]\n\t                                         ,[\"apply\", 2, true]           // *\n\t                                         ,[\"argmax\", 2]               // *\n\t                                         ,[\"argmin\", 2]               // *\n\t                                         ,[\"build-list\", 2]\n\t                                         ,[\"build-string\", 2]         // *\n\t                                         ,[\"compose\", 0, true]         // *\n\t                                         ,[\"filter\", 2]               // *\n\t                                         ,[\"foldl\", 2, true]\n\t                                         ,[\"foldr\", 2, true]                // *\n\t                                         ,[\"map\", 1, true]\n\t                                         ,[\"for-each\", 1, true]\n\t                                         ,[\"memf\", 2]                 // *\n\t                                         ,[\"ormap\", 1, true]                // *\n\t                                         ,[\"procedure?\", 1]           // *\n\t                                         ,[\"quicksort\", 2]            // *\n\t                                         ,[\"sort\", 2]                 // *\n\t                                         \n\t                                         ,[\"void\", 0, true]\n\t                                           \n\t                                         // Parsing\n\t                                         ,[\"xml->s-exp\", 1]\n\t                                         \n\t                                         // Vectors\n\t                                         ,[\"build-vector\", 2]\n\t                                         // FIXME: should only take one or two arguments\", not vararity\n\t                                         ,[\"make-vector\", 1, true]\n\t                                         ,[\"vector\", 0, true]\n\t                                         ,[\"vector-length\", 1]\n\t                                         ,[\"vector-ref\", 2]\n\t                                         ,[\"vector-set!\", 3]\n\t                                         ,[\"vector->list\", 1]\n\t                                         ,[\"list->vector\", 1]\n\t                                         ,[\"vector?\", 1]\n\t                                         \n\t                                         ,[\"printf\", 1, true]\n\t                                         ,[\"display\", 1]\n\t                                         ,[\"write\", 1]\n\t                                         ,[\"newline\", 0]\n\t                                         ,[\"call/cc\", 1]\n\t                                         ,[\"procedure-arity\", 1]\n\t                                         \n\t                                         \n\t                                         // Testing functions.\n\t                                         // NOTE: the desugar.ss module converts use of check-expect into ones that\n\t                                         // thunk its arguments\", and pass an additional location argument.\n\t                                         ,[\"check-expect\", 2]\n\t                                         ,[\"EXAMPLE\", 2]\n\t                                         ,[\"check-within\", 3]\n\t                                         ,[\"check-error\", 2]\n\t                                         ,[\"make-hasheq\", 0]\n\t                                         ,[\"make-hash\", 0]\n\t                                         ,[\"hash-set!\", 3 ]\n\t                                         ,[\"hash-ref\", 3]\n\t                                         ,[\"hash-remove!\", 2]\n\t                                         ,[\"hash-map\", 2]\n\t                                         ,[\"hash-for-each\", 2]\n\t                                         ,[\"hash?\", 1]\n\t                                         \n\t                                         // Exception raising\n\t                                         ,[\"raise\", 1]\n\t                                         \n\t                                         // Checking for undefined\n\t                                         ,[\"undefined?\", 1]\n\t                                         \n\t                                         // values for multiple value definition\n\t                                         ,[\"values\", 0, true]\n\t                                         \n\t                                         // structures\n\t                                         ,[\"make-struct-type\", 4, true]\n\t                                         ,[\"make-struct-field-accessor\", 2, true]\n\t                                         ,[\"make-struct-field-mutator\", 2, true]\n\t                                         \n\t                                         // continuation mark stuff\n\t                                         // FIXME: add support for prompt optional argument\n\t                                         ,[\"current-continuation-marks\", 0, false]\n\t                                         ,[\"continuation-mark-set->list\", 2, false]\n\t                                         \n\t                                         // Things for javascript FFI and world\n\t                                         ,[\"scheme->prim-js\", 1, false]\n\t                                         ,[\"prim-js->scheme\", 1, false]\n\t                                         ,[\"procedure->cps-js-fun\", 1, false]\n\t                                         ,[\"procedure->void-js-fun\", 1, false]\n\t                                         ,[\"js-===\", 2, false]\n\t                                         ,[\"js-get-named-object\", 1, false]\n\t                                         ,[\"js-get-field\", 2, true]\n\t                                         //,[\"get-js-array-field\", 2, false]\n\t                                         ,[\"js-set-field!\", 3, false]\n\t                                         //,[\"js-set-array-field!\", 3, false]\n\t                                         ,[\"js-typeof\", 1, false]\n\t                                         ,[\"js-instanceof\", 2, false]\n\t                                         ,[\"js-call\", 2, true]\n\t                                         ,[\"js-new\", 1, true]\n\t                                         ,[\"js-make-hash\", 0, true]\n\t                                         \n\t                                         ,[\"make-world-config\", 2, true]\n\t                                         ,[\"make-bb-info\", 2, false]\n\t                                         ,[\"bb-info?\", 1, false]\n\t                                         ,[\"bb-info-change-world\", 1, false]\n\t                                         ,[\"bb-info-toplevel-node\", 1, false]\n\t                                         \n\t                                         ,[\"make-effect-type\", 4, true]\n\t                                         ,[\"effect?\", 1, false]\n\t                                         ,[\"world-with-effects\", 2, false]\n\t                                         //,[\"coerce-world-handler\", 1, false]\n\t                                         ,[\"make-render-effect-type\", 4, true]\n\t                                         ,[\"render-effect-type?\", 1]\n\t                                         ,[\"render-effect?\", 1]\n\t                                         \n\t                                         //,[\"make-effect:do-nothing 0, false]\n\t                                         //,[\"effect:do-nothing? 1, false]\n\t                                         \n\t                                         ,[\"make-render-effect-type\", 4, true]\n\t                                         //,[\"render-effect-name 1, false]\n\t                                         //,[\"render-effect-dom-node 1, false]\n\t                                         //,[\"render-effect-effects 1, false]\n\t                                         //,[\"render-effect? 1, false]\n\t                                         \n\t                                         ,[\"values\", 0, true]\n\t                                         ,[\"sleep\", 0, true]\n\t                                         ,[\"current-inexact-milliseconds\", 0, false]\n\t                                         \n\t                                         ,[\"make-exn\", 2, false]\n\t                                         ,[\"exn-message\", 1, false]\n\t                                         ,[\"exn-continuation-marks\", 1, false]\n\t                                        ].map(makeFunctionBinding('\"moby/toplevel\"'))\n\t  );\n\t\n\t  // The core environment includes the baseConstants, the topLevel bindings, and the world bindings\n\t  // NOTE: worldModule *includes* worldEffects and worldHandlers, according to Danny's modules.ss file\n\t plt.compiler.topLevelModules = [topLevelModule, kernelMiscModule, , jsWorldModule, worldModule];\n\t plt.compiler.knownCollections = [\"bootstrap\", \"bootstrap2011\", \"bootstrap2012\", \"bootstrap2014\", \"bootstrap2015\"];\n\t \n\t \n\t plt.compiler.knownModules = [kernelMiscModule\n\t                              , jsWorldModule\n\t                              , foreignModule\n\t                              , worldModule\n\t                              , bootstrapTeachpack\n\t                              , bootstrapTeachpack2011\n\t                              , bootstrapTeachpack2012\n\t                              , bootstrapTeachpack2014\n\t                              , bootstrapTeachpack2015\n\t                              , bootstrapTiltTeachpack2012\n\t                              , bootstrapTiltTeachpack2014\n\t                              , bootstrapTiltTeachpack2015\n\t                              , cageTeachpack\n\t                              , cageTeachpack2011\n\t                              , cageTeachpack2012\n\t                              , cageTeachpack2014\n\t                              , functionTeachpack\n\t                              , functionTeachpack2011\n\t                              , functionTeachpack2012\n\t                              , functionTeachpack2014\n\t                              , functionTeachpack2015\n\t                              , locationModule\n\t                              , tiltModule\n\t                              , telephonyModule\n\t                              , netModule\n\t                              , parserModule\n\t                              , topLevelModule];\n\t})();\n\t\n\tmodule.exports = plt.compiler;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(2);\n\tvar jsnums = __webpack_require__(4);\n\tvar types = __webpack_require__(3);\n\t\n\t// if not defined, declare the compiler object as part of plt\n\twindow.plt   = window.plt   || {};\n\tplt.compiler = plt.compiler || {};\n\t\n\t/*\n\t TODO\n\t - compiled-indirects\n\t - someday, get rid of convertToBytecode()\n\t - PERF: Switch from array to hashtable for freeVariables search\n\t - fix uniqueGlobalNames hack!\n\t - deal with more complex module resolution (e.g. - rename-out, etc)\n\t */\n\t\n\t(function (){\n\t \n\t   // import frequently-used bindings\n\t   var literal          = plt.compiler.literal;\n\t   var symbolExpr       = plt.compiler.symbolExpr;\n\t   var Program          = plt.compiler.Program;\n\t   var ifExpr           = plt.compiler.ifExpr;\n\t   var beginExpr        = plt.compiler.beginExpr;\n\t   var localExpr        = plt.compiler.localExpr;\n\t   var andExpr          = plt.compiler.andExpr;\n\t   var orExpr           = plt.compiler.orExpr;\n\t   var lambdaExpr       = plt.compiler.lambdaExpr;\n\t   var quotedExpr       = plt.compiler.quotedExpr;\n\t   var callExpr         = plt.compiler.callExpr;\n\t   var defFunc          = plt.compiler.defFunc;\n\t   var defVar           = plt.compiler.defVar;\n\t   var defVars          = plt.compiler.defVars;\n\t   var defStruct        = plt.compiler.defStruct;\n\t   var requireExpr      = plt.compiler.requireExpr;\n\t   var provideStatement = plt.compiler.provideStatement;   \n\t\n\t   // Inheritance from pg 168: Javascript, the Definitive Guide.\n\t    var heir = function(p) {\n\t      var f = function() {};\n\t      f.prototype = p;\n\t      return new f();\n\t    };\n\t\n\t \n\t \n\t    literal.prototype.toBytecode = function(){\n\t      var str = this.val.toBytecode? this.val.toBytecode()\n\t              : this.val===true? \"true\"\n\t              : this.val===false? \"false\"\n\t              : this.toString();\n\t      return '{\"$\":\"constant\",\"value\":'+str+'}';\n\t    };\n\t    symbolExpr.prototype.toBytecode = function(){\n\t      return 'types.symbol(\"'+escapeSym(this.val)+'\")';\n\t    };\n\t    Vector.prototype.toBytecode = function(){\n\t      return 'types.vector(['+this.elts.join(',')+'])';\n\t    };\n\t    Array.prototype.toBytecode = function(quoted){\n\t      return 'types.'+(this.length===0? 'EMPTY':'list(['+this.map(convertToBytecode).join(',')+'])');\n\t    };\n\t    // Bytecode generation for jsnums types\n\t    jsnums.Rational.prototype.toBytecode = function(){\n\t      return 'types.rational('+convertToBytecode(this.n)+', '+convertToBytecode(this.d)+')';\n\t    };\n\t    jsnums.BigInteger.prototype.toBytecode = function(){\n\t      return 'types.bignum(\"'+this.toString()+'\")';\n\t    };\n\t    jsnums.FloatPoint.prototype.toBytecode = function(){\n\t      var num = this.toString();\n\t      if(num===\"+nan.0\") num = \"NaN\";\n\t      if(num===\"+inf.0\") num = \"Infinity\";\n\t      if(num===\"-inf.0\") num = \"-Infinity\";\n\t      return 'types[\"float\"]('+num+')';\n\t    };\n\t    jsnums.Complex.prototype.toBytecode = function(){\n\t      return 'types.complex('+convertToBytecode(this.r)+', '+convertToBytecode(this.i)+')';\n\t    };\n\t    Char.prototype.toBytecode = function(){\n\t      return 'types[\\'char\\'](String.fromCharCode('+this.val.charCodeAt(0)+'))';\n\t    };\n\t    // STACKREF STRUCTS ////////////////////////////////////////////////////////////////\n\t    function stackReference(){}\n\t    function localStackReference(name, isBoxed, depth){\n\t      stackReference.call(this);\n\t      this.name = name;\n\t      this.isBoxed = isBoxed;\n\t      this.depth = depth;\n\t    }\n\t    localStackReference.prototype = heir(stackReference.prototype);\n\t    function globalStackReference(name, depth, pos){\n\t      stackReference.call(this);\n\t      this.name = name;\n\t      this.pos = pos;\n\t      this.depth = depth;\n\t    }\n\t    globalStackReference.prototype = heir(stackReference.prototype);\n\t    function unboundStackReference(name){\n\t      stackReference.call(this);\n\t      this.name = name;\n\t    }\n\t    unboundStackReference.prototype = heir(stackReference.prototype);\n\t\n\t\n\t    /**************************************************************************\n\t     *\n\t     *    BYTECODE STRUCTS -\n\t     *    (see https://github.com/bootstrapworld/wescheme-compiler2012/blob/master/js-runtime/src/bytecode-structs.ss)\n\t     *\n\t     **************************************************************************/\n\t \n\t \n\t    // all Programs, by default, print out their values and have no location\n\t    // anything that behaves differently must provide their own toBytecode() function\n\t    var Bytecode = function() {\n\t      // -> JSON\n\t      this.toBytecode = function(){ console.log(this); throw \"IMPOSSIBLE - generic bytecode toBytecode method was called\"; };\n\t    };\n\t\n\t    // for mapping JSON conversion over an array\n\t    function convertToBytecode(bc){\n\t       if(types.isString(bc) && bc.chars!==undefined) return '\"'+bc.toString()+'\"';\n\t       return (bc.toBytecode)? bc.toBytecode() : bc;\n\t    }\n\t \n\t    // convert a symbol-name into bytecode string\n\t    function escapeSym(symName){\n\t      var str = symName.toString().replace(/\\|/g,''),  bcStr = \"\";\n\t      // possible characters that need to be escaped\n\t      var escapes = [\"{\", \"}\", \"[\", \"]\", \",\", \"'\", \"`\", \" \", \"\\\\\", '\"'];\n\t      for(var j=0; j<str.length; j++){\n\t        bcStr += ((escapes.indexOf(str.charAt(j)) > -1)? '\\\\' : '') + str.charAt(j);\n\t      }\n\t      // special-case for newline characters\n\t      bcStr= bcStr.replace(/\\n/g,\"\\\\n\");\n\t      return bcStr;\n\t    }\n\t \n\t    // Global bucket\n\t    function globalBucket(name) {\n\t      Bytecode.call(this);\n\t      this.name = name;  // symbol\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"global-bucket\",\"value\":\"'+escapeSym(this.name)+'\"}';\n\t      };\n\t    };\n\t    globalBucket.prototype = heir(Bytecode.prototype);\n\t\n\t    // Module variable\n\t    function moduleVariable(modidx, sym, pos, phase) {\n\t      Bytecode.call(this);\n\t      this.$    = 'module-variable';\n\t      this.modidx = modidx; // module-path-index\n\t      this.sym    = sym;    // symbol\n\t      this.pos    = pos;    // exact integer\n\t      this.phase  = phase;  // 1/0 - direct access to exported id\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"module-variable\",\"sym\":'+this.sym.toBytecode()\n\t                +',\"modidx\":'+this.modidx.toBytecode()+',\"pos\":'+this.pos\n\t                +',\"phase\":'+this.phase+'}';\n\t      };\n\t    };\n\t    moduleVariable.prototype = heir(Bytecode.prototype);\n\t\n\t    // Wrap syntax object\n\t    function wrap() {\n\t      Bytecode.call(this);\n\t    };\n\t    wrap.prototype = heir(Bytecode.prototype);\n\t\n\t    // Wrapped syntax object\n\t    function wrapped(datum, wraps, certs) {\n\t      Bytecode.call(this);\n\t      this.datum  = datum;  // any\n\t      this.wraps  = wraps;  // list of wrap\n\t      this.certs = certs;   // list or false\n\t    };\n\t    wrapped.prototype = heir(Bytecode.prototype);\n\t\n\t    // Stx\n\t    function stx(encoded) {\n\t      this.encoded  = encoded;  // wrapped\n\t      Bytecode.call(this);\n\t    };\n\t    stx.prototype = heir(Bytecode.prototype);\n\t\n\t    // prefix\n\t    function prefix(numLifts, topLevels, stxs) {\n\t      Bytecode.call(this);\n\t      this.numLifts   = numLifts;  // exact, non-negative integer\n\t      this.topLevels  = topLevels; // list of (false, symbol, globalBucket or moduleVariable)\n\t      this.stxs       = stxs;      // list of stxs\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"prefix\",\"num-lifts\":'+this.numLifts+',\"toplevels\":['\n\t                +this.topLevels.map(function(v){return convertToBytecode(v);}).join(',')\n\t                +'],\"stxs\":['\n\t                +this.stxs.map(convertToBytecode)+']}';\n\t      };\n\t    };\n\t    prefix.prototype = heir(Bytecode.prototype);\n\t\n\t    // form\n\t    function form() {\n\t      Bytecode.call(this);\n\t    };\n\t    form.prototype = heir(Bytecode.prototype);\n\t\n\t    // expr\n\t    function expr(form) {\n\t      Bytecode.call(this);\n\t    };\n\t    expr.prototype = heir(Bytecode.prototype);\n\t\n\t    // Indirect\n\t    function indirect(v) {\n\t      Bytecode.call(this);\n\t      this.v  = v; // ??\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"indirect\",\"v\":'+this.v.toBytecode()+'}';\n\t      };\n\t    };\n\t    indirect.prototype = heir(Bytecode.prototype);\n\t\n\t    // compilationTop\n\t    function compilationTop(maxLetDepth, prefix, code) {\n\t      Bytecode.call(this);\n\t      this.maxLetDepth= maxLetDepth;  // exact non-negative integer\n\t      this.prefix     = prefix;       // prefix\n\t      this.code       = code;         // form, indirect, or any\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"compilation-top\",\"max-let-depth\":'+this.maxLetDepth+',\"prefix\":'\n\t              + this.prefix.toBytecode()+',\"compiled-indirects\":[],\"code\":'\n\t              + this.code.toBytecode()+'}';\n\t      };\n\t    };\n\t    compilationTop.prototype = heir(Bytecode.prototype);\n\t\n\t    // provided\n\t    function provided(name, src, srcName, nomSrc, srcPhase, isProtected, insp) {\n\t      Bytecode.call(this);\n\t      this.name     = name;      // symbol\n\t      this.src      = src;       // false or modulePathIndex\n\t      this.srcName  = srcName;   // symbol\n\t      this.nomSrc   = nomSrc;    // false or modulePathIndex\n\t      this.srcPhase = srcPhase;  // 0/1\n\t      this.insp     = insp;      // boolean or void\n\t      this.isProtected=isProtected; // boolean\n\t    };\n\t    provided.prototype = heir(Bytecode.prototype);\n\t\n\t    // topLevel\n\t    function topLevel(depth, pos, constant, ready, loc) {\n\t      Bytecode.call(this);\n\t      this.depth    = depth;    // exact, non-negative integer\n\t      this.pos      = pos;      // exact, non-negative integer\n\t      this.constant = constant; // boolean\n\t      this.ready    = ready;    // boolean\n\t      this.loc      = loc;      // false or Location\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"toplevel\",\"depth\":'+this.depth.toString()+',\"pos\":'+this.pos.toString()\n\t                +',\"const?\":'+this.constant+',\"ready?\":'+this.ready+',\"loc\":'\n\t                + (this.loc && this.loc.toVector().toBytecode())+'}';\n\t      };\n\t    };\n\t    topLevel.prototype = heir(Bytecode.prototype);\n\t\n\t    // seq\n\t    function seq(forms) {\n\t      Bytecode.call(this);\n\t      this.forms    = forms;  // list of form, indirect, any\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"seq\",\"forms\":['+this.forms.map(convertToBytecode).join(',')+']}';\n\t      };\n\t    };\n\t    seq.prototype = heir(Bytecode.prototype);\n\t\n\t    // defValues\n\t    function defValues(ids, rhs) {\n\t      Bytecode.call(this);\n\t      this.ids  = ids;  // list of toplevel or symbol\n\t      this.rhs  = rhs;  // expr, indirect, seq, any\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"def-values\",\"ids\":['+this.ids.map(convertToBytecode).join(',')\n\t                +'],\"body\":'+this.rhs.toBytecode()+'}';\n\t      };\n\t    };\n\t    defValues.prototype = heir(Bytecode.prototype);\n\t\n\t    // defSyntaxes\n\t    function defSyntaxes(ids, rhs, prefix, maxLetDepth) {\n\t      Bytecode.call(this);\n\t      this.$          = 'def-values';\n\t      this.ids        = ids;      // list of toplevel or symbol\n\t      this.rhs        = rhs;      // expr, indirect, seq, any\n\t      this.prefix     = prefix;   // prefix\n\t      this.maxLetDepth= maxLetDepth; // exact, non-negative integer\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"def-values\",\"ids\":['+this.ids.toBytecode().join(',')\n\t                +'],\"rhs\":'+this.rhs.toBytecode()\n\t                +',\"prefix\":'+this.prefix.toBytecode()+',\"max-let-depth\":'+this.maxLetDepth.toBytecode()+'}';\n\t      };\n\t    };\n\t    defSyntaxes.prototype = heir(Bytecode.prototype);\n\t\n\t    // defForSyntax\n\t    function defForSyntax(ids, rhs, prefix, maxLetDepth) {\n\t      Bytecode.call(this);\n\t      this.ids        = ids;      // list of toplevel or symbol\n\t      this.rhs        = rhs;      // expr, indirect, seq, any\n\t      this.prefix     = prefix;   // prefix\n\t      this.maxLetDepth= maxLetDepth; // exact, non-negative integer\n\t    };\n\t    defForSyntax.prototype = heir(Bytecode.prototype);\n\t\n\t    // mod\n\t    function mod(name, selfModidx, prefix, provides, requires, body,\n\t                 syntaxBody, unexported, maxLetDepth, dummy, langInfo,\n\t                 internalContext) {\n\t      Bytecode.call(this);\n\t      this.name       = name;         // exact, non-negative integer\n\t      this.selfModidx = selfModidx;   // exact, non-negative integer\n\t      this.prefix     = prefix;       // boolean\n\t      this.provides   = provides;     // boolean\n\t      this.requires   = requires;     // false or Location\n\t      this.body       = body;         // exact, non-negative integer\n\t      this.syntaxBody = syntaxBody;   // exact, non-negative integer\n\t      this.unexported = unexported;   // boolean\n\t      this.maxLetDepth= maxLetDepth;  // exact, non-negative integer\n\t      this.dummy      = dummy;        // false or Location\n\t      this.langInfo   = langInfo;     // false or (vector modulePath symbol any)\n\t      this.internalContext = internalContext;\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"mod\",\"name\":'+this.name.toBytecode()+',\"self-modidx\":'+this.selfModidx.toBytecode()\n\t                +',\"prefix\":'+this.prefix.toBytecode()+',\"provides\":'+this.provides.toBytecode()\n\t                +',\"requires\":'+(this.requires && this.requires.toVector().toBytecode())+',\"body\":'\n\t                +this.body.toBytecode()+',\"stx-body\":'+this.syntaxBody.toBytecode()+',\"max-let-depth\":'\n\t                +this.maxLetDepth.toBytecode()+'}';\n\t      };\n\t    };\n\t    mod.prototype = heir(Bytecode.prototype);\n\t\n\t    // lam\n\t    function lam(name, operatorAndRandLocs, flags, numParams, paramTypes,\n\t                 rest, closureMap, closureTypes, maxLetDepth, body) {\n\t \n\t      Bytecode.call(this);\n\t      this.name       = name;         // symbol, vector, empty\n\t      this.flags      = flags;        // (list of ('preserves-marks 'is-method 'single-result))\n\t      this.numParams  = numParams;    // exact, non-negative integer\n\t      this.paramTypes = paramTypes;   // list of ('val 'ref 'flonum)\n\t      this.rest       = rest;         // boolean\n\t      this.body       = body;         // expr, seq, indirect\n\t      this.closureMap = closureMap;   // vector of exact, non-negative integers\n\t      this.maxLetDepth= maxLetDepth;  // exact, non-negative integer\n\t      this.closureTypes=closureTypes; // list of ('val/ref or 'flonum)\n\t      this.operatorAndRandLocs = operatorAndRandLocs; // list of Vectors\n\t      // operator+rand-locs includes a list of vectors corresponding to the location\n\t      // of the operator, operands, etc if we can pick them out.  If we can't get\n\t      // this information, it's false\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"lam\",\"name\":'+this.name.toBytecode()+',\"locs\":['\n\t                +this.operatorAndRandLocs.map(convertToBytecode).join(',')+'],\"flags\":['\n\t                +this.flags.map(convertToBytecode).join(',')+'],\"num-params\":'+this.numParams\n\t                +',\"param-types\":['+this.paramTypes.map(convertToBytecode).join(',')+'],\"rest?\":'+this.rest\n\t                +',\"closure-map\":['+this.closureMap.map(convertToBytecode).join(',')+'],\"closure-types\":['\n\t                +this.closureTypes.map(convertToBytecode).join(',')+'],\"max-let-depth\":'+this.maxLetDepth\n\t                +',\"body\":'+this.body.toBytecode()+'}';\n\t      };\n\t    };\n\t    lam.prototype = heir(Bytecode.prototype);\n\t\n\t\n\t    // closure: a static closure (nothing to close over)\n\t    function closure(code, genId) {\n\t      Bytecode.call(this);\n\t      this.code     = code;  // lam\n\t      this.genId    = genId; // symbol\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"closure\",\"code\":'+this.code.toBytecode()+',\"gen-id\":'+this.genId.toBytecode()+'}';\n\t      };\n\t    };\n\t    closure.prototype = heir(Bytecode.prototype);\n\t\n\t    // caseLam: each clause is a lam (added indirect)\n\t    function caseLam(name, clauses) {\n\t      Bytecode.call(this);\n\t      this.name     = name;  // symbol, vector, empty\n\t      this.clauses  = clauses; // list of (lambda or indirect)\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"case-lam\",\"name\":'+this.name.toBytecode()+',\"clauses\":'+this.clauses.toBytecode()+'}';\n\t      };\n\t    };\n\t    caseLam.prototype = heir(Bytecode.prototype);\n\t\n\t    // letOne\n\t    function letOne(rhs, body, flonum) {\n\t      Bytecode.call(this);\n\t      this.rhs     = rhs;   // expr, seq, indirect, any\n\t      this.body    = body;  // expr, seq, indirect, any\n\t      this.flonum  = flonum;// boolean\n\t      this.toBytecode = function(){\n\t        return '{\"$\": \"let-one\",\"rhs\":'+this.rhs.toBytecode()+',\"body\":'+this.body.toBytecode()\n\t                +',\"flonum\":'+this.flonum.toBytecode()+'}';\n\t      };\n\t    };\n\t    letOne.prototype = heir(Bytecode.prototype);\n\t\n\t    // letVoid\n\t    function letVoid(count, boxes, body) {\n\t      Bytecode.call(this);\n\t      this.count   = count;   // exact, non-negative integer\n\t      this.boxes   = boxes;   // boolean\n\t      this.body    = body;    // expr, seq, indirect, any\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"let-void\",\"count\":'+convertToBytecode(this.count)+',\"boxes?\":'\n\t                +convertToBytecode(this.boxes)+',\"body\":'+this.body.toBytecode()+'}';\n\t      };\n\t    };\n\t    letVoid.prototype = heir(Bytecode.prototype);\n\t\n\t    // letRec: put `letrec'-bound closures into existing stack slots\n\t    function letRec(procs, body) {\n\t      Bytecode.call(this);\n\t      this.procs   = procs;   // list of lambdas\n\t      this.body    = body;    // expr, seq, indirect, any\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"let-rec\",\"procs\":'+this.procs.toBytecode()+',\"body\":'+this.body.toBytecode()+'}';\n\t      };\n\t    };\n\t    letRec.prototype = heir(Bytecode.prototype);\n\t\n\t    // installValue\n\t    function installValue(count, pos, boxes, rhs, body) {\n\t      Bytecode.call(this);\n\t      this.count   = count;   // exact, non-negative integer\n\t      this.pos     = pos;     // exact, non-negative integer\n\t      this.boxes   = boxes;   // boolean\n\t      this.rhs     = rhs;     // expr, seq, indirect, any\n\t      this.body    = body;    // expr, seq, indirect, any -- set existing stack slot(s)\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"install-value\",\"count\":'+convertToBytecode(this.count)+',\"pos\":'+convertToBytecode(this.pos)\n\t                +',\"boxes?\":'+convertToBytecode(this.boxes)+',\"rhs\":'+this.rhs.toBytecode()\n\t                +',\"body\":'+this.body.toBytecode()+'}';\n\t      };\n\t    };\n\t    installValue.prototype = heir(Bytecode.prototype);\n\t\n\t    // boxEnv: box existing stack element\n\t    function boxEnv(pos, body) {\n\t      Bytecode.call(this);\n\t      this.pos     = pos;     // exact, non-negative integer\n\t      this.body    = body;    // expr, seq, indirect, any\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"boxenv\",\"pos\":'+this.pos.toBytecode()+',\"body\":'+this.body.toBytecode()+'}';\n\t      };\n\t    };\n\t    boxEnv.prototype = heir(Bytecode.prototype);\n\t\n\t    // localRef: access local via stack\n\t    function localRef(unbox, pos, clear, otherClears, flonum) {\n\t      Bytecode.call(this);\n\t      this.unbox   = unbox || false;   // boolean\n\t      this.pos     = pos;     // exact, non-negative integer\n\t      this.clear   = clear;   // boolean\n\t      this.flonum  = flonum;  // boolean\n\t      this.otherClears= otherClears; // boolean\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"localref\",\"unbox?\":'+this.unbox+',\"pos\":'+this.pos+',\"clear\":'+this.clear\n\t                +',\"other-clears?\":'+this.otherClears+',\"flonum?\":'+this.flonum+'}';\n\t      };\n\t    };\n\t    localRef.prototype = heir(Bytecode.prototype);\n\t\n\t    // topSyntax : access syntax object via prefix array (which is on stack)\n\t    function topSyntax(depth, pos, midpt) {\n\t      Bytecode.call(this);\n\t      this.depth   = depth;   // exact, non-negative integer\n\t      this.pos     = pos;     // exact, non-negative integer\n\t      this.midpt   = midpt;   // exact, non-negative integer\n\t    };\n\t    topSyntax.prototype = heir(Bytecode.prototype);\n\t\n\t    // application: function call\n\t    function application(rator, rands) {\n\t      Bytecode.call(this);\n\t      this.rator   = rator;   // expr, seq, indirect, any\n\t      this.rands   = rands;   // list of (expr, seq, indirect, any)\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"application\",\"rator\":'+this.rator.toBytecode()+',\"rands\":['\n\t                +this.rands.map(convertToBytecode).join(',')+']}';\n\t      };\n\t    };\n\t    application.prototype = heir(Bytecode.prototype);\n\t\n\t    // branch\n\t    function branch(testExpr, thenExpr, elseExpr) {\n\t      Bytecode.call(this);\n\t      this.testExpr = testExpr;   // expr, seq, indirect, any\n\t      this.thenExpr = thenExpr;   // expr, seq, indirect, any\n\t      this.elseExpr = elseExpr;   // expr, seq, indirect, any\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"branch\",\"test\":'+this.testExpr.toBytecode()\n\t                +',\"then\":'+this.thenExpr.toBytecode()\n\t                +',\"else\":'+this.elseExpr.toBytecode()+'}';\n\t      };\n\t    };\n\t    branch.prototype = heir(Bytecode.prototype);\n\t\n\t    // withContMark:'with-cont-mark'\n\t    function withContMark(key, val, body) {\n\t      Bytecode.call(this);\n\t      this.$    = 'with-cont-mark';\n\t      this.key  = key;   // expr, seq, indirect, any\n\t      this.val  = val;   // expr, seq, indirect, any\n\t      this.body = body;  // expr, seq, indirect, any\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"with-cont-mark\",\"key\":'+new literal(new symbolExpr(this.key)).toBytecode()\n\t                +',\"val\":'+new literal(this.val).toBytecode()\n\t                +',\"body\":'+this.body.toBytecode()+'}';\n\t      };\n\t    };\n\t    withContMark.prototype = heir(Bytecode.prototype);\n\t\n\t    // beg0: begin0\n\t    function beg0(seq) {\n\t      Bytecode.call(this);\n\t      this.seq  = seq;   // list  of (expr, seq, indirect, any)\n\t      this.toBytecode = function(){ return '{\"$\":\"beg0\",\"seq\":'+this.seq.toBytecode()+'}';  };\n\t    };\n\t    beg0.prototype = heir(Bytecode.prototype);\n\t\n\t    // splice: top-level 'begin'\n\t    function splice(forms) {\n\t      Bytecode.call(this);\n\t      this.forms  = forms;   // list  of (expr, seq, indirect, any)\n\t      this.toBytecode = function(){ return '{\"$\":\"splice\",\"forms\":'+this.forms.toBytecode()+'}';  };\n\t    };\n\t    splice.prototype = heir(Bytecode.prototype);\n\t\n\t    // varRef: `#%variable-reference'\n\t    function varRef(topLevel) {\n\t      Bytecode.call(this);\n\t      this.topLevel  = topLevel;   // topLevel\n\t      this.toBytecode = function(){ return '{\"$\":\"varref\",\"top-level\":'+this.topLevel.toBytecode()+'}';  };\n\t    };\n\t    varRef.prototype = heir(Bytecode.prototype);\n\t\n\t    // assign: top-level or module-level set!\n\t    function assign(id, rhs, undefOk) {\n\t      Bytecode.call(this);\n\t      this.id      = id;      // topLevel\n\t      this.rhs     = rhs;     // expr, seq, indirect, any\n\t      this.undefOk = undefOk; // boolean\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"assign\",\"id\":'+this.id.toBytecode()+',\"rhs\":'+this.rhs.toBytecode()\n\t                +',\"undef-ok\":'+this.undefOk.toBytecode()+'}';\n\t      };\n\t    };\n\t    assign.prototype = heir(Bytecode.prototype);\n\t\n\t    // applyValues: `(call-with-values (lambda () ,args-expr) ,proc)\n\t    function applyValues(proc, args) {\n\t      Bytecode.call(this);\n\t      this.proc    = proc;    // expr, seq, indirect, any\n\t      this.args    = args;    // expr, seq, indirect, any\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"apply-values\",\"proc\":'+this.proc.toBytecode()+',\"args\":'+this.args.toBytecode()+'}';\n\t      };\n\t    };\n\t    applyValues.prototype = heir(Bytecode.prototype);\n\t\n\t    // primVal: direct preference to a kernel primitive\n\t    function primVal(id) {\n\t      Bytecode.call(this);\n\t      this.id      = id;    // exact, non-negative integer\n\t      this.toBytecode = function(){ return '{\"$\":\"primval\",\"id\":'+this.id.toBytecode()+'}';  };\n\t    };\n\t    primVal.prototype = heir(Bytecode.prototype);\n\t\n\t    // req\n\t    function req(reqs, dummy) {\n\t      Bytecode.call(this);\n\t      this.$        = 'req';\n\t      this.reqs    = reqs;    // syntax\n\t      this.dummy   = dummy;   // toplevel\n\t      this.toBytecode = function(){\n\t        var reqBytecode = (this.reqs instanceof literal)? '\"'+this.reqs.val+'\"' : this.reqs.toBytecode();\n\t        return '{\"$\":\"req\",\"reqs\":'+reqBytecode+',\"dummy\":'+this.dummy.toBytecode()+'}';\n\t      };\n\t    };\n\t    req.prototype = heir(Bytecode.prototype);\n\t\n\t    // lexicalRename\n\t    function lexicalRename(bool1, bool2, alist) {\n\t      this.bool1   = bool1;    // boolean\n\t      this.bool2   = bool2;    // boolean\n\t      this.alist   = alist;    // should be list of (cons symbol, symbol)\n\t      Bytecode.call(this);\n\t    };\n\t    lexicalRename.prototype = heir(Bytecode.prototype);\n\t\n\t    // phaseShift\n\t    function phaseShift(amt, src, dest) {\n\t      this.amt     = amt;    // syntax\n\t      this.src     = src;    // false or modulePathIndex\n\t      this.dest    = dest;   // false or modulePathIndex\n\t      Bytecode.call(this);\n\t    };\n\t    phaseShift.prototype = heir(Bytecode.prototype);\n\t\n\t    // wrapMark\n\t    function wrapMark(val) {\n\t      this.val     = val;    // exact integer\n\t      Bytecode.call(this);\n\t    };\n\t    wrapMark.prototype = heir(Bytecode.prototype);\n\t\n\t    // prune\n\t    function prune(sym) {\n\t      this.sym     = sym;    // any\n\t      Bytecode.call(this);\n\t    };\n\t    prune.prototype = heir(Bytecode.prototype);\n\t\n\t    // allFromModule\n\t    function allFromModule(path, phase, srcPhase, exceptions, prefix) {\n\t      this.path     = path;       // modulePathIndex\n\t      this.phase    = phase;      // false or exact integer\n\t      this.srcPhase = srcPhase;   // any\n\t      this.prefix   = prefix;     // false or symbol\n\t      this.exceptions=exceptions; // list of symbols\n\t      Bytecode.call(this);\n\t    };\n\t    allFromModule.prototype = heir(Bytecode.prototype);\n\t\n\t    // nominalPath\n\t    function nominalPath() {\n\t      Bytecode.call(this);\n\t    };\n\t    nominalPath.prototype = heir(Bytecode.prototype);\n\t\n\t    // simpleNominalPath\n\t    function simpleNominalPath(value) {\n\t      this.value = value; // modulePathIndex\n\t      Bytecode.call(this);\n\t    };\n\t    simpleNominalPath.prototype = heir(Bytecode.prototype);\n\t\n\t/*    // moduleBinding\n\t    function moduleBinding() {\n\t      Bytecode.call(this);\n\t    };\n\t    moduleBinding.prototype = heir(Bytecode.prototype);\n\t*/\n\t    // phasedModuleBinding\n\t    function phasedModuleBinding(path, phase, exportName, nominalPath, nominalExportName) {\n\t      this.path       = path;       // modulePathIndex\n\t      this.phase      = phase;      // exact integer\n\t      this.exportName = nominalPath;// nominalPath\n\t      this.nominalExportName  = nominalExportName; // any\n\t      Bytecode.call(this);\n\t    };\n\t    phasedModuleBinding.prototype = heir(Bytecode.prototype);\n\t\n\t    // exportedNominalModuleBinding\n\t    function exportedNominalModuleBinding(path, exportName, nominalPath, nominalExportName) {\n\t      this.path       = path;       // modulePathIndex\n\t      this.exportName = exportName; // any\n\t      this.nominalPath= nominalPath;// nominalPath\n\t      this.nominalExportName  = nominalExportName; // any\n\t      Bytecode.call(this);\n\t    };\n\t    exportedNominalModuleBinding.prototype = heir(Bytecode.prototype);\n\t\n\t    // nominalModuleBinding\n\t    function nominalModuleBinding(path, nominalPath) {\n\t      this.path       = path;        // modulePathIndex\n\t      this.nominalPath= nominalPath; // any\n\t      Bytecode.call(this);\n\t    };\n\t    nominalModuleBinding.prototype = heir(Bytecode.prototype);\n\t\n\t    // exportedModuleBinding\n\t    function exportedModuleBinding(path, exportName) {\n\t      this.path       = path;       // modulePathIndex\n\t      this.exportName = exportName; // any\n\t      Bytecode.call(this);\n\t    };\n\t    exportedModuleBinding.prototype = heir(Bytecode.prototype);\n\t\n\t    // simpleModuleBinding\n\t    function simpleModuleBinding(path) {\n\t      this.path       = path;       // modulePathIndex\n\t      Bytecode.call(this);\n\t    };\n\t    simpleModuleBinding.prototype = heir(Bytecode.prototype);\n\t\n\t    // ModuleRename\n\t    function ModuleRename(phase, kind, setId, unmarshals, renames, markRenames, plusKern) {\n\t      this.phase      = phase;       // false or exact integer\n\t      this.kind       = kind;        // \"marked\" or \"normal\"\n\t      this.unmarshals = unmarshals;  // list of allFromModule\n\t      this.renames    = renames;     // list of (symbol or moduleBinding)\n\t      this.markRenames= markRenames; // any\n\t      this.plusKern   = plusKern;    // boolean\n\t      Bytecode.call(this);\n\t    };\n\t    ModuleRename.prototype = heir(Bytecode.prototype);\n\t \n\t    // HACK: module-path\n\t    function modulePath(path, base){\n\t      this.path = path;\n\t      this.base = base;\n\t      Bytecode.call(this);\n\t      this.toBytecode = function(){\n\t        return '{\"$\":\"module-path\",\"path\":'+convertToBytecode(this.path)+',\"base\":'+convertToBytecode(this.base)+'}';\n\t      };\n\t    };\n\t    modulePath.prototype = heir(Bytecode.prototype);\n\t \n\t    // freeVariables : [listof symbols] env -> [list of symbols]\n\t    Program.prototype.freeVariables   = function(acc, env){ return acc; }\n\t    ifExpr.prototype.freeVariables    = function(acc, env){\n\t      return this.alternative.freeVariables(this.consequence.freeVariables(this.predicate.freeVariables(acc, env), env), env);\n\t    };\n\t    beginExpr.prototype.freeVariables = function(acc, env){\n\t      return this.exprs.reduceRight(function(acc, expr){return expr.freeVariables(acc, env);}, acc);\n\t    };\n\t    // if it's an unbound variable that we haven't seen before, add it to acc\n\t    symbolExpr.prototype.freeVariables= function(acc, env){\n\t      return ((env.lookup(this.val, 0) instanceof unboundStackReference)\n\t              && (acc.indexOf(this) == -1))? acc.concat([this]) : acc;\n\t    };\n\t    localExpr.prototype.freeVariables = function(acc, env){\n\t      // helper functions\n\t      var pushLocalBoxedFromSym = function(env, sym) { return new plt.compiler.localEnv(sym.val, true, env); },\n\t          pushLocalFromSym      = function(env, sym) { return new plt.compiler.localEnv(sym.val, false, env); };\n\t \n\t          // collect all the defined names in the local\n\t      var definedNames = this.defs.reduce(function(names, d){\n\t                                            return ((d instanceof defVars)? d.names : [d.name]).concat(names); }\n\t                                           , []),\n\t          // make an environment with those names added to the stack\n\t          updatedEnv = definedNames.reduce(pushLocalBoxedFromSym, env),\n\t          // use that env to find all free variables in the body\n\t          freeVarsInBody = this.body.freeVariables(acc, updatedEnv),\n\t \n\t          // given free variables and a definition, add the free variables from that definition...\n\t          // while *also* updating the stack to reflect defined names\n\t          addFreeVarsInDef = function(acc, d){\n\t             if(d instanceof defFunc){\n\t                var envWithArgs = d.args.reduce(function(env, arg){return pushLocalFromSym(env, arg);}, updatedEnv);\n\t                return d.body.freeVariables(acc, envWithArgs);\n\t             }\n\t             if(d instanceof defStruct){ return acc; }\n\t             else{ return d.expr.freeVariables(acc, updatedEnv); }\n\t          }\n\t \n\t      // collect free variables from all the definitions and the body, while simultaneously\n\t      // updating the environment to reflect defined names\n\t      return this.defs.reduce(addFreeVarsInDef, freeVarsInBody);\n\t    };\n\t    andExpr.prototype.freeVariables   = function(acc, env){\n\t       return this.exprs.reduceRight(function(acc, expr){ return expr.freeVariables(acc, env);} , acc);\n\t    };\n\t    orExpr.prototype.freeVariables    = function(acc, env){\n\t       return this.exprs.reduceRight(function(acc, expr){ return expr.freeVariables(acc, env);} , acc);\n\t    }\n\t    // be careful to make a copy of the array before reversing!\n\t    lambdaExpr.prototype.freeVariables= function(acc, env){\n\t      var pushLocalFromSym  = function(env, sym) { return new plt.compiler.localEnv(sym.val, false, env); },\n\t          envWithArgs       = this.args.slice(0).reverse().reduce(pushLocalFromSym, env);\n\t      return this.body.freeVariables(acc, envWithArgs);\n\t \n\t    };\n\t    quotedExpr.prototype.freeVariables= function(acc, env){ return acc; };\n\t    callExpr.prototype.freeVariables  = function(acc, env){\n\t      return this.func.freeVariables(acc, env).concat(this.args).reduceRight(function(acc, expr){\n\t                                                                                return expr.freeVariables(acc, env);\n\t                                                                              } , acc);\n\t    };\n\t \n\t  /**************************************************************************\n\t   *\n\t   *    COMPILATION -\n\t   *    (see https://github.com/bootstrapworld/wescheme-compiler2012/blob/master/js-runtime/src/mzscheme-vm.ss)\n\t   *\n\t   **************************************************************************/\n\t \n\t   // sort-and-unique: (listof X) (X X -> boolean) (X X -> boolean) -> (listof X)\n\t   function sortAndUnique(elts, lessThan, equalTo) {\n\t      function unique(elts){\n\t        return (elts.length <= 1)? elts\n\t               :  equalTo(elts[0], elts[1])? unique(elts.slice(1))\n\t               :  [elts[0]].concat(unique(elts.slice(1)));\n\t      }\n\t      // convert lessThan fn into a fn that returns -1 for less, 1 for greater, 0 for equal\n\t      var convertedSortFn = function(x,y){ return lessThan(x,y)? -1 : lessThan(y,x);}\n\t      return unique(elts.sort(convertedSortFn));\n\t   }\n\t \n\t \n\t   // [bytecodes, pinfo, env], Program -> [bytecodes, pinfo, env]\n\t   // compile the program, then add the bytecodes and pinfo information to the acc\n\t   function compilePrograms(acc, p){\n\t    var bytecodes = acc[0], pinfo = acc[1], env = acc[2],\n\t        compiledProgramAndPinfo = p.compile(env, pinfo),\n\t        compiledProgram = compiledProgramAndPinfo[0],\n\t        pinfo     = compiledProgramAndPinfo[1];\n\t    return [[compiledProgram].concat(bytecodes), pinfo, env];\n\t   }\n\t \n\t   // extend the Program class to include compilation\n\t   // compile: pinfo -> [bytecode, pinfo]\n\t \n\t   // literals evaluate to themselves\n\t   Program.prototype.compile = function(env, pinfo){\n\t      return [this, pinfo];\n\t   };\n\t   \n\t   defFunc.prototype.compile = function(env, pinfo){\n\t      var compiledFunNameAndPinfo = this.name.compile(env, pinfo),\n\t          compiledFunName = compiledFunNameAndPinfo[0],\n\t          pinfo = compiledFunNameAndPinfo[1];\n\t      var lambda = new lambdaExpr(this.args, this.body),\n\t          compiledLambdaAndPinfo = lambda.compile(env, pinfo, false, this.name),\n\t          compiledLambda = compiledLambdaAndPinfo[0],\n\t          pinfo = compiledLambdaAndPinfo[1];\n\t      var bytecode = new defValues([compiledFunName], compiledLambda);\n\t      return [bytecode, pinfo];\n\t   };\n\t\n\t   defVar.prototype.compile = function(env, pinfo){\n\t      var compiledIdAndPinfo = this.name.compile(env, pinfo),\n\t          compiledId = compiledIdAndPinfo[0],\n\t          pinfo = compiledIdAndPinfo[1];\n\t      var compiledExprAndPinfo = this.expr.compile(env, pinfo),\n\t          compiledExpr = compiledExprAndPinfo[0],\n\t          pinfo = compiledExprAndPinfo[1];\n\t      var bytecode = new defValues([compiledId], compiledExpr);\n\t      return [bytecode, pinfo];\n\t   };\n\t\n\t   defVars.prototype.compile = function(env, pinfo){\n\t        var compiledIdsAndPinfo = this.names.reduceRight(compilePrograms, [[], pinfo, env]),\n\t            compiledIds = compiledIdsAndPinfo[0],\n\t            pinfo = compiledIdsAndPinfo[1];\n\t        var compiledBodyAndPinfo = this.expr.compile(env, pinfo),\n\t            compiledBody = compiledBodyAndPinfo[0],\n\t            pinfo = compiledBodyAndPinfo[1];\n\t        var bytecode = new defValues(compiledIds, compiledBody);\n\t        return [bytecode, pinfo];\n\t   };\n\t   \n\t   beginExpr.prototype.compile = function(env, pinfo){\n\t      var compiledExpressionsAndPinfo = this.exprs.reduceRight(compilePrograms, [[], pinfo, env]),\n\t          compiledExpressions = compiledExpressionsAndPinfo[0],\n\t          pinfo1 = compiledExpressionsAndPinfo[1];\n\t      var bytecode = new seq(compiledExpressions);\n\t      return [bytecode, pinfo1];\n\t   };\n\t\n\t   // Compile a lambda expression.  The lambda must close its free variables over the\n\t   // environment.\n\t   lambdaExpr.prototype.compile = function(env, pinfo, isUnnamedLambda, name){\n\t      if(isUnnamedLambda===undefined) isUnnamedLambda = true;\n\t \n\t      // maskUnusedGlobals : (listof symbol?) (listof symbol?) -> (listof symbol or false)\n\t      function maskUnusedGlobals(listOfNames, namesToKeep){\n\t        return listOfNames.map(function(n){ return (namesToKeep.indexOf(n)>-1)? n : false; });\n\t      }\n\t\n\t      function pushLocal(env, n)      { return new plt.compiler.localEnv(n, false, env); }\n\t      function pushLocalBoxed(env, n) { return new plt.compiler.localEnv(n, true, env); }\n\t      function pushGlobals(names, env){ return new plt.compiler.globalEnv(names, false, env); }\n\t \n\t      // getClosureVectorAndEnv : (list of Symbols) (list of Symbols) env -> [(Vector of number), env]\n\t      // take in a list of args, a list of freevars, and an empty env that ONLY includes the arguments\n\t      function getClosureVectorAndEnv(args, freeVariables, originalEnv){\n\t        // pull out the stack references for all variables that are free in this environment\n\t        var freeVariableRefs = freeVariables.map(function(v){return originalEnv.lookup(v.val, 0);}),\n\t            // some utility functions\n\t            ormap = function(f, l){return (l.length===0)? false : f(l[0])? l[0] : ormap(f, l.slice(1));},\n\t            isLocalStackRef   = function(r){return r instanceof localStackReference;},\n\t            isGlobalStackRef  = function(r){return r instanceof globalStackReference;},\n\t            isUnboundStackRef = function(r){return r instanceof unboundStackReference;},\n\t            getDepthFromRef   = function(r){return r.depth;},\n\t            // this will either be #f, or the first unboundStackRef\n\t            anyUnboundStackRefs = ormap(isUnboundStackRef, freeVariableRefs);\n\t        // if any of the references are unbound, freak out!\n\t        if(anyUnboundStackRefs){\n\t          throw \"Can't produce closure; I don't know where \" + anyUnboundStackRefs.name + \" is bound.\";\n\t        // otherwise, compute the depths of all local and global free variables\n\t        } else {\n\t          var lexicalFreeRefs   = sortAndUnique(freeVariableRefs.filter(isLocalStackRef),\n\t                                                function(x,y){return x.depth < y.depth;},\n\t                                                function(x,y){return x.depth === y.depth;}),\n\t              lexicalFreeDepths = lexicalFreeRefs.map(getDepthFromRef),\n\t              globalRefs        = freeVariableRefs.filter(isGlobalStackRef),\n\t              globalDepths      = sortAndUnique(globalRefs.map(getDepthFromRef),\n\t                                                function(x,y){return x<y;},\n\t                                                function(x,y){return x===y;});\n\t          // Add Function Arguments (in reverse order) to the environment\n\t          var env1 = args.reverse().map(function(s){return s.val;}).reduce(pushLocal, originalEnv);\n\t\n\t          // Add the lexical free variables (in reverse order)\n\t          var env2 = lexicalFreeRefs.reverse().reduce(function(env, ref){\n\t                      return ref.isBoxed? pushLocalBoxed(env, ref.name) : pushLocal(env, ref.name);\n\t                    }, env1);\n\t\n\t          // Add the global free variables (in reverse order)\n\t          var env3 = globalDepths.reverse().reduce(function(env, depth){\n\t                       var refsAtDepth = globalRefs.filter(function(ref){return ref.depth===depth;}),\n\t                           usedGlobals = refsAtDepth.map(function(ref){return ref.name}),\n\t                           newGlobals  = maskUnusedGlobals(originalEnv.peek(depth).names, usedGlobals);\n\t                       return pushGlobals(newGlobals, env);\n\t                     }, env2);\n\t\n\t          // return a vector of depths (global, then local), along with the environment\n\t          return [globalDepths.concat(lexicalFreeDepths), env3];\n\t        }\n\t      }\n\t      // push each arg onto an empty Env, the compute the free variables in the function body with that Env\n\t      var envWithArgs = this.args.map(function(s){return s.val;}).reduce(pushLocal, new plt.compiler.emptyEnv());\n\t          freeVarsInBody = this.body.freeVariables([], envWithArgs);\n\t      // compute the closure information using a COPY of the args array (protect against in-place reversal)\n\t      var closureVectorAndEnv = getClosureVectorAndEnv(this.args.slice(0), freeVarsInBody, env),\n\t          closureVector = closureVectorAndEnv[0],\n\t          extendedEnv = closureVectorAndEnv[1];\n\t      // compile the body using the closure's environent\n\t      var compiledBodyAndPinfo = this.body.compile(extendedEnv, pinfo),\n\t          compiledBody = compiledBodyAndPinfo[0],\n\t          pinfo1 = compiledBodyAndPinfo[1];\n\t      // emit the bytecode\n\t      var getLocs = function(id){return id.location.toVector();},\n\t          bytecode = new lam(isUnnamedLambda? [] : new symbolExpr(name),\n\t                             [isUnnamedLambda? this.stx:name].concat(this.args).map(getLocs),\n\t                             [],                                                          // flags\n\t                             this.args.length,                                            // numParams\n\t                             this.args.map( function(){ return new symbolExpr(\"val\");}  ),  // paramTypes\n\t                             false,                                                       // rest\n\t                             closureVector,                                               // closureMap\n\t                             closureVector.map(function(){ return new symbolExpr(\"val/ref\"); }  ), // closureTypes\n\t                             0,                                                           // maxLetDepth\n\t                             compiledBody);                                               // body\n\t      return [bytecode, pinfo1];\n\t   };\n\t\n\t   localExpr.prototype.compile = function(env, pinfo){\n\t     // if there are no definitions, just pull the body out and compile it.\n\t     if(this.defs.length === 0) return this.body.compile(env, pinfo);\n\t\n\t     // Otherwise...\n\t     // (1) create an environment where all defined names are given local, boxed stackrefs\n\t     var that = this,\n\t         definedNames = this.defs.reduce(getDefinedNames, []),\n\t         pushLocalBoxedFromSym = function(env, sym) { return new plt.compiler.localEnv(sym.val, true, env); },\n\t         envWithBoxedNames = definedNames.reverse().reduce(pushLocalBoxedFromSym, env);\n\t \n\t     // (2) process the definitions, starting with pinfo and our new environment as the base\n\t     var letVoidBodyAndPinfo = processDefns(this.defs, pinfo, envWithBoxedNames, 0),\n\t         letVoidBody = letVoidBodyAndPinfo[0],\n\t         pinfo = letVoidBodyAndPinfo[1];\n\t \n\t     // (3) return a new letVoid for the stack depth we require, then use the bytecode as the body\n\t     return [new letVoid(definedNames.length, true, letVoidBody), pinfo]\n\t\n\t     // getDefinedNames : [names], def -> names\n\t     // given a list of names and a defn, add defined name(s) to the list\n\t     function getDefinedNames(names, def){\n\t        return names.concat((def instanceof defVars)? def.names : def.name);\n\t     }\n\t \n\t     // processDefns : [defs], pinfo, numInstalled -> [bytecode, pinfo]\n\t     // fold-like function that will generate bytecode to install each defn at the\n\t     // correct stack location , then move on to the rest of the definitions\n\t     function processDefns(defs, pinfo, env, numInstalled){\n\t        if(defs.length===0){ return that.body.compile(envWithBoxedNames, pinfo); }\n\t \n\t        // compile the first definition in the current environment\n\t        var compiledDefAndPInfo = defs[0].compile(env, pinfo),\n\t            compiledRhs         = compiledDefAndPInfo[0].rhs, // important: all we need is the rhs!!\n\t            pinfo               = compiledDefAndPInfo[1];\n\t\n\t        // figure out how much room we'll need on the stack for this defn\n\t        // compile the rest of the definitions, using the new pinfo and stack size\n\t        var numToInstall    = (defs[0] instanceof defVars)? defs[0].names.length : 1,\n\t            newBodyAndPinfo = processDefns(defs.slice(1), pinfo, env, numInstalled+numToInstall)\n\t            newBody         = newBodyAndPinfo[0],\n\t            pinfo           = newBodyAndPinfo[1];\n\t \n\t       // generate bytecode to install new values for the remaining body\n\t        var bytecode = new installValue(numToInstall, numInstalled, true, compiledRhs, newBody);\n\t        return [bytecode, pinfo];\n\t     }\n\t   };\n\t   \n\t   callExpr.prototype.compile = function(env, pinfo){\n\t      // add space to the stack for each argument, then build the bytecode for the application itself\n\t      var makeSpace = function(env, operand){return new plt.compiler.unnamedEnv(env);},\n\t          extendedEnv = this.args.reduce(makeSpace, env);\n\t      var compiledOperatorAndPinfo = this.func.compile(extendedEnv, pinfo),\n\t          compiledOperator = compiledOperatorAndPinfo[0],\n\t          pinfo1 = compiledOperatorAndPinfo[1];\n\t      var compiledOperandsAndPinfo = this.args.reduceRight(compilePrograms, [[], pinfo, extendedEnv]),\n\t          compiledOperands = compiledOperandsAndPinfo[0],\n\t          pinfo2 = compiledOperatorAndPinfo[1],\n\t          app = new application(compiledOperator, compiledOperands);\n\t      // extract the relevant locations for error reporting, then wrap the application in continuation marks\n\t      var extractLoc= function(e){return e.location;},\n\t          locs      = [this.func.location].concat(this.args.map(extractLoc)),\n\t          locVectors= locs.concat(this.location).map(function(loc){return loc.toVector();}),\n\t          appWithcontMark=new withContMark(new symbolExpr(\"moby-application-position-key\"), locVectors,\n\t                                           new withContMark(new symbolExpr(\"moby-stack-record-continuation-mark-key\"),\n\t                                                            this.location.toVector(), app));\n\t          return [appWithcontMark, pinfo2];\n\t   };\n\t   \n\t   ifExpr.prototype.compile = function(env, pinfo){\n\t      var compiledPredicateAndPinfo = this.predicate.compile(env, pinfo),\n\t          compiledPredicate = compiledPredicateAndPinfo[0],\n\t          pinfo1 = compiledPredicateAndPinfo[1];\n\t      var compiledConsequenceAndPinfo = this.consequence.compile(env, pinfo),\n\t          compiledConsequence = compiledConsequenceAndPinfo[0],\n\t          pinfo2 = compiledConsequenceAndPinfo[1];\n\t      var compiledAlternateAndPinfo = this.alternative.compile(env, pinfo),\n\t          compiledAlternate = compiledAlternateAndPinfo[0],\n\t          pinfo3 = compiledAlternateAndPinfo[1];\n\t      var bytecode = new branch(compiledPredicate, compiledConsequence, compiledAlternate);\n\t      return [bytecode, pinfo3];\n\t   };\n\t   \n\t   symbolExpr.prototype.compile = function(env, pinfo){\n\t     var stackReference = env.lookup(this.val, 0), bytecode;\n\t      if(stackReference instanceof localStackReference){\n\t        bytecode = new localRef(stackReference.isBoxed, stackReference.depth, false, false, false);\n\t      } else if(stackReference instanceof globalStackReference){\n\t        bytecode = new topLevel(stackReference.depth, stackReference.pos, false, false, this.location);\n\t      } else if(stackReference instanceof unboundStackReference){\n\t        throw \"Couldn't find '\"+this.val+\"' in the environment\";\n\t      } else {\n\t        throw \"IMPOSSIBLE: env.lookup failed for '\"+this.val+\"'! A reference should be added to the environment!\";\n\t      }\n\t      return [bytecode, pinfo];\n\t   };\n\t \n\t   // a quotedExpr is a literal version of the raw stx object\n\t   quotedExpr.prototype.compile = function(env, pinfo){\n\t      function unwrapLiterals(v){\n\t        return (v instanceof literal)? unwrapLiterals(v.val) : (v instanceof Array)? v.map(unwrapLiterals) : v;\n\t      }\n\t      result = new literal(unwrapLiterals(this.val));\n\t      return [result, pinfo];\n\t   };\n\t \n\t   provideStatement.prototype.compile = function(env, pinfo){};\n\t   requireExpr.prototype.compile = function(env, pinfo){\n\t     return [new req(this.spec, new topLevel(0, 0, false, false, false)), pinfo];\n\t   };\n\t\n\t   // compile-compilation-top: program pinfo -> bytecode\n\t   function compileCompilationTop(program, pinfo){\n\t      // makeModulePrefixAndEnv : pinfo -> [prefix, env]\n\t      // collect all the free names being defined and used at toplevel\n\t      // Create a prefix that refers to those values\n\t      // Create an environment that maps to the prefix\n\t      function makeModulePrefixAndEnv(pinfo){\n\t        var requiredModuleBindings = pinfo.modules.reduce(function(acc, m){return acc.concat(m.bindings);}, []),\n\t            isNotRequiredModuleBinding = function(b){ return b.moduleSource && (requiredModuleBindings.indexOf(b) === -1)},\n\t            moduleOrTopLevelDefinedBindings = pinfo.usedBindingsHash.values().filter(isNotRequiredModuleBinding),\n\t \n\t            allModuleBindings = requiredModuleBindings.concat(moduleOrTopLevelDefinedBindings),\n\t\n\t            // utility functions for making globalBuckets and moduleVariables\n\t            makeGlobalBucket = function(name){ return new globalBucket(name);},\n\t            modulePathIndexJoin = function(path, base){return new modulePath(path, base);},\n\t            // Match Moby: if it's a module that was imported via 'require', we treat it differently for some reason (WTF)\n\t            makeModuleVariablefromBinding = function(b){\n\t              return new moduleVariable(modulePathIndexJoin(b.moduleSource,\n\t                                                            (b.imported)? false : modulePathIndexJoin(false, false))\n\t                                      , new symbolExpr(b.name), -1, 0);\n\t            };\n\t        var globalNames = pinfo.freeVariables.concat(pinfo.definedNames.keys()),\n\t        // FIXME: we have to make uniqueGlobalNames because a function name can also be a free variable,\n\t        // due to a bug in analyze-lambda-expression in which the base pinfo is used for the function body.\n\t            uniqueGlobalNames = sortAndUnique(globalNames, function(a,b){return a<b;}, function(a,b){return a==b;}),\n\t            topLevels         = [false].concat(uniqueGlobalNames.map(makeGlobalBucket)\n\t                                               ,allModuleBindings.map(makeModuleVariablefromBinding)),\n\t            globals           = [false].concat(uniqueGlobalNames\n\t                                               ,allModuleBindings.map(function(b){return b.name;}));\n\t        return [new prefix(0, topLevels ,[])\n\t               , new plt.compiler.globalEnv(globals, false, new plt.compiler.emptyEnv())];\n\t      };\n\t      // The toplevel is going to include all of the defined identifiers in the pinfo\n\t      // The environment will refer to elements in the toplevel.\n\t      var toplevelPrefixAndEnv = makeModulePrefixAndEnv(pinfo),\n\t          toplevelPrefix = toplevelPrefixAndEnv[0],\n\t          env = toplevelPrefixAndEnv[1];\n\t      // pull out separate program components for ordered compilation\n\t      var defns    = program.filter(plt.compiler.isDefinition),\n\t          requires = program.filter((function(p){return (p instanceof requireExpr);})),\n\t          exprs    = program.filter(plt.compiler.isExpression);\n\t      var compiledRequiresAndPinfo = requires.reduceRight(compilePrograms, [[], pinfo, env]),\n\t          compiledRequires = compiledRequiresAndPinfo[0],\n\t          pinfo = compiledRequiresAndPinfo[1];\n\t      var compiledDefinitionsAndPinfo = defns.reduceRight(compilePrograms, [[], pinfo, env]),\n\t          compiledDefinitions = compiledDefinitionsAndPinfo[0],\n\t          pinfo = compiledDefinitionsAndPinfo[1];\n\t      var compiledExpressionsAndPinfo = exprs.reduceRight(compilePrograms, [[], pinfo, env]),\n\t          compiledExpressions = compiledExpressionsAndPinfo[0],\n\t          pinfo = compiledExpressionsAndPinfo[1];\n\t      // generate the bytecode for the program and return it, along with the program info\n\t      var forms = new seq([].concat(compiledRequires, compiledDefinitions, compiledExpressions)),\n\t          zo_bytecode = new compilationTop(0, toplevelPrefix, forms),\n\t          response = {\"bytecode\" : \"/* runtime-version: local-compiler-summer2014 */\\n\" + zo_bytecode.toBytecode(),\n\t                      \"permissions\" : pinfo.permissions(),\n\t                      \"provides\" : pinfo.providedNames.keys()};\n\t          return response;\n\t   }\n\t \n\t \n\t  /////////////////////\n\t  /* Export Bindings */\n\t  /////////////////////\n\t  plt.compiler.localStackReference  = localStackReference;\n\t  plt.compiler.globalStackReference = globalStackReference;\n\t  plt.compiler.unboundStackReference= unboundStackReference;\n\t  plt.compiler.compile              = function(program, pinfo, debug){\n\t      var start = new Date().getTime();\n\t      try { var response = compileCompilationTop(program, pinfo); }  // do the actual work\n\t      catch (e) { console.log(\"COMPILATION ERROR\"); throw e; }\n\t      var end = new Date().getTime();\n\t      if(debug){\n\t        console.log(\"Compiled in \"+(Math.floor(end-start))+\"ms\");\n\t        console.log(JSON.stringify(response));\n\t      }\n\t      return response;\n\t   };\n\t })();\n\t\n\tmodule.exports = plt.compiler;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** wescheme-js.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d9783c8208cd40031085\n **/","var lex = require('./lex')\nvar parser = require('./parser')\nvar analyzer = require('./analyzer')\nvar compiler = require('./compiler')\n\nexport var compile = function compile(code, debug=false) {\n  var lexemes = lex.lex(code, 'foo', debug)\n  var AST = parser.parse(lexemes)\n  var desugared = analyzer.desugar(AST)[0]  // includes [AST, pinfo]\n  var pinfo = analyzer.analyze(desugared)\n  var local_bytecode = compiler.compile(desugared, pinfo)\n  return local_bytecode.bytecode\n}\n\nexport default compile\n\n\n/** WEBPACK FOOTER **\n ** ./src/wescheme.js\n **/","\n\n// if not defined, declare the compiler object as part of plt\nwindow.plt   = window.plt || {};\nplt.compiler = require('./structures');\nvar types = require('./runtime/types');\nvar jsnums = require('./runtime/js-numbers');\n\n/*\n \n Follows WeScheme's current implementation of Advanced Student\n http://docs.racket-lang.org/htdp-langs/advanced.html\n\n NOT SUPPORTED BY MOBY, WESCHEME, OR THIS COMPILER: define-datatype, begin0, set!, time, delay, shared, recur,\n    match, check-member-of, check-range, (require planet), byetstrings (#\"Apple\"),\n    regexps (#rx or #px), hashtables (#hash), graphs (#1=100 #1# #1#), #reader and #lang\n \n \n TODO\n - JSLint\n - convert Location structs to use those from the Pyret lexer\n */\n\n//////////////////////////////////////////////////////////////////////////////\n////////////////////////////////// LEXER OBJECT //////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n\n// Parse a program into SExps\n//\n// A SExp is either:\n// - Literal x Location\n// - symbolExpr x Location\n// - [ListOf SExp] x Location\n//\n// A Literal is either:\n// - types.<number>\n// - types.string\n// - types.char\n// - types.vector\n\n    /////////////////////\n    /*      Data       */\n    /////////////////////\n\n(function () {\n    'use strict';\n\n    // import frequently-used bindings\n    var literal         = plt.compiler.literal;\n    var symbolExpr      = plt.compiler.symbolExpr;\n    var unsupportedExpr = plt.compiler.unsupportedExpr;\n    var throwError      = plt.compiler.throwError;\n\n    // a collection of common RegExps\n    var leftListDelims  = /[(\\u005B\\u007B]/,\n        rightListDelims = /[)\\u005D\\u007D]/,\n        matchUntilDelim = /^[^(\\u005B\\u007B)\\u005D\\u007D\\s]+/,\n        quotes          = /[\\'`,]/,\n        hex2            = new RegExp(\"^([0-9a-f]{1,2})\", \"i\"),\n        hex4            = new RegExp(\"^([0-9a-f]{1,4})\", \"i\"),\n        hex6            = new RegExp(\"^([0-9a-f]{1,6})\", \"i\"),\n        hex8            = new RegExp(\"^([0-9a-f]{1,8})\", \"i\"),\n        oct3            = new RegExp(\"^([0-7]{1,3})\", \"i\");\n\n    // the delimiters encountered so far, line and column, and case-sensitivity\n    var delims, line, column, startCol, startRow, source, caseSensitiveSymbols, i;\n    // UGLY HACK to track index if an error occurs. We should remove this if we can make i entirely stateful\n    var endOfError;\n                            \n    // the location struct\n    // endCol and endRow are included for pyret error location\n    var Location = function(startCol, startRow, startChar, span, theSource){\n      this.startCol   = startCol;   // starting index into the line\n      this.startRow   = startRow;   // starting line # (1-index)\n      this.startChar  = startChar;  // ch index of lexeme start, from beginning\n      this.span       = span;       // num chrs between lexeme start and end\n      this.source     = theSource || source; // [OPTIONAL] id of the containing DOM element\n                            \n      this.endCol     = column;     // ending index into the line\n      this.endRow     = line;       // ending index into the line\n      this.endChar    = startChar+span;      // ch index of lexeme end, from beginning\n                            \n      this.start      = function(){ return new Location(\"\", \"\", this.startChar, 1); };\n      this.end        = function(){ return new Location(\"\", \"\", this.startChar+this.span-1, 1); };\n      this.toString   = function(){\n        return \"Loc(\"+this.startCol+\", \"+this.startRow+\", \"+(this.startChar+1)+\",\"+this.span+\")\";\n      };\n      this.toVector = function(){\n        return new types.vector(['\"'+this.source+'\"' // add quotes to the source, since it's a str (not a symbol)\n                                ,this.startChar+1\n                                ,this.startRow\n                                ,this.startCol\n                                ,this.span]);\n      };\n      this.toString = function(){\n        return {line: this.startRow.toString(), id: this.source, span: this.span.toString(),\n               offset: (this.startChar+1).toString(), column: this.startCol.toString()};\n      };\n    };\n\n    /////////////////////\n    /* Utility Methods */\n    /////////////////////\n                   \n    // some important string methods\n    function isWhiteSpace(str) {\n      return (/\\s/).test(str);\n    }\n\n    // determines if a character string is in one of the three sets of delimiters\n    function isDelim(x) {\n      return x === '(' || x === ')'\n        ||   x === '[' || x === ']'\n        ||   x === '{' || x === '}';\n    }\n\n    // this is returned when a comment is read\n    function Comment(txt) {this.txt = txt;}\n\n    // determines if the character is valid as a part of a symbol\n    function isValidSymbolCharP(x) {\n      return !isDelim(x) && !isWhiteSpace(x)\n            && x !== '\"' && x !== ',' && x !== \"'\"\n                        && x !== '`' && x !== ';';\n    }\n\n    // determines if they are matching delimiter pairs\n    // ie ( and ) [ and ] { and }\n    function matchingDelims(x, y) {\n      return (x === '(' && y === ')')\n        ||   (x === '[' && y === ']')\n        ||   (x === '{' && y === '}');\n    }\n\n    // gets the matching delim given the other delim in a pair\n    function otherDelim(x) {\n      return  x === '(' ? ')' :\n              x === '[' ? ']' :\n              x === '{' ? '}' :\n              x === ')' ? '(' :\n              x === ']' ? '[' :\n              x === '}' ? '{' :\n    /* else */ throwError(new types.Message([\"otherDelim: Unknown delimiter: \", x]));\n    }\n\n    // reads through whitespace\n    function chewWhiteSpace(str, i) {\n      var p;\n      if(i < str.length) {\n        p = str.charAt(i);\n        while (isWhiteSpace(p) && i < str.length) {\n          // increment column/line counters\n          if(p===\"\\n\"){ line++; column = 0;}\n          else { column++; }\n          p = str.charAt(++i);\n        }\n      }\n      return i;\n    }\n\n    Array.prototype.toString = function () {return this.join(\" \"); };\n    function sexpToString(sexp) {\n      return (sexp instanceof Array)? \"(\" + sexp.map(sexpToString).toString() + \")\"\n                                    : sexp.toString();\n    }\n\n                   \n    /////////////////////\n    /* Primary Methods */\n    /////////////////////\n\n    // readProg : String String -> SExp\n    // reads multiple sexps encoded into this string and converts them to a SExp\n    // datum\n    function readProg(str, strSource) {\n      var i = 0; startCol = column = 0; startRow = line = 1, // initialize all position indices\n          caseSensitiveSymbols = true;                // initialize case sensitivity\n      source = strSource || \"<definitions>\";\n      var sexp, sexps = [];\n      delims = [];\n      // get rid of any whitespace at the start of the string\n      i = chewWhiteSpace(str, 0);\n      while(i < str.length) {\n        sexp = readSExpByIndex(str, i);\n        if(!(sexp instanceof Comment)) { sexps.push(sexp); }\n        i = chewWhiteSpace(str, sexp.location.startChar+sexp.location.span);\n      }\n      sexps.location = new Location(startCol, startRow, 0, i, source);\n      return sexps;\n    }\n\n    // readSSFile : String String -> SExp\n    // removes the first three lines of the string that contain DrScheme meta data\n    function readSSFile(str, strSource) {\n      var i = 0; startCol = column = 0; startRow = line = 1, // initialize all position indices\n          caseSensitiveSymbols = true;                // initialize case sensitivity\n      source = strSource || \"<definitions>\";\n      var crs = 0;\n\n      while(i < str.length && crs < 3) {\n        if(str.charAt(i++) === \"\\n\") { crs++; }\n      }\n\n      var sexp, sexps = [];\n      delims = [];\n      while(i < str.length) {\n        sexp = readSExpByIndex(str, i);\n        if(!(sexp instanceof Comment)) { sexps.push(sexp); }\n        i = chewWhiteSpace(str, sexp.location.startChar+sexp.location.span);\n      }\n      return sexps;\n    }\n\n    // readSExp : String String -> SExp\n    // reads the first sexp encoded in this string and converts it to a SExp datum\n    function readSExp(str, source) {\n      delims = [];\n      var sexp = readSExpByIndex(str, 0);\n      return sexp instanceof Comment ? null : sexp;\n    }\n\n    // readSExpByIndex : String Number -> SExp\n    // reads a sexp encoded as a string starting at the i'th character and converts\n    // it to a SExp datum\n    function readSExpByIndex(str, i) {\n      startCol = column; startRow = line; var iStart = i;\n      i = chewWhiteSpace(str, i);\n      var p = str.charAt(i);\n      if(i >= str.length) {\n        endOfError = i; // remember where we are, so readList can pick up reading\n        throwError(new types.Message([source , \":\"\n                                      , startRow.toString(), \":\"\n                                      , (startCol-1).toString()\n                                      , \": read: (found end-of-file)\"])\n                   ,new Location(startCol-1, startRow, i-2, 2) // back up the startChar before #;, make the span include only those 2\n                   ,\"Error-GenericReadError\");\n      }\n      var sexp = rightListDelims.test(p) ?\n                   throwError(new types.Message([\"read: expected a \", otherDelim(p), \" to open \"\n                                                , new types.ColoredPart(p, new Location(column, startRow, iStart, 1))])\n                              ,new Location(column, startRow, iStart, 1)) :\n                 leftListDelims.test(p) ? readList(str, i) :\n                 p === '\"'                  ? readString(str, i) :\n                 p === '#'                  ? readPoundSExp(str, i) :\n                 p === ';'                  ? readLineComment(str, i) :\n                 quotes.test(p)             ? readQuote(str, i) :\n                  /* else */                   readSymbolOrNumber(str, i);\n       return sexp;\n    }\n                            \n    // readList : String Number -> SExp\n    // reads a list encoded in this string with the left delimiter at index i\n    function readList(str, i) {\n      var startCol=column, startRow=line, iStart=i, innerError=false,\n          errorLocation = new Location(startCol, startRow, iStart, 1),\n          openingDelim = str.charAt(i++),\n          dot1Idx=false, dot2Idx = false; // indices of the dot operator\n      column++; // move forward to count the closing delimeter\n      var sexp, list = [];\n      delims.push(openingDelim);\n      i = chewWhiteSpace(str, i);\n         \n      // read a single list item\n      // To allow optimization in v8, this function is broken out into its own (named) function\n      // see http://www.html5rocks.com/en/tutorials/speed/v8/#toc-topic-compilation\n      function readListItem(str, i, list){\n        var sexp = readSExpByIndex(str, i);       // read the next s-exp\n        i = sexp.location.end().startChar+1;         // move i to the character at the end of the sexp\n        // if it's a dot, treat it as a cons\n        if(sexp instanceof symbolExpr && sexp.val == '.'){\n          if(dot2Idx){\n            var msg = new types.Message([\"A syntax list may have only 2 `.'s\"]);\n            throwError(msg, list[dot1Idx].location);\n          }\n          dot2Idx = dot1Idx? list.length : false; // if we've seen dot1, save this idx to dot2Idx\n          dot1Idx = dot1Idx || list.length;       // if we haven't seen dot1, save this idx to dot1Idx\n        }\n        if(!(sexp instanceof Comment)){            // if it's not a comment, add it to the list\n          sexp.parent = list;                     // set this list as it's parent\n          list.push(sexp);                        // and add the sexp to the list\n        }\n        return i;\n      }\n                            \n      // if we have one dot, splice the element at that idx into the list\n      // if we have two dots, move the element they surround to the front\n      // throw errors for everything else\n      function processDots(list, dot1Idx, dot2Idx){\n        // if the dot is the first element in the list, throw an error\n        if(dot1Idx === 0){\n          var msg = new types.Message([\"A `.' cannot be the first element in a syntax list\"]);\n          throwError(msg, list[dot1Idx].location);\n        }\n        // if a dot is the last element in the list, throw an error\n        if(dot1Idx===(list.length-1) || dot2Idx===(list.length-1)){\n          var msg = new types.Message([\"A `.' cannot be the last element in a syntax list\"]);\n          throwError(msg, list[dot2Idx||dot1Idx].location);\n        }\n\n        // assuming they are legal, if there are two dots in legal places...\n        if(dot2Idx){\n          // if they are not surrounding a single element, throw an error\n          if(dot2Idx - dot1Idx !== 2){\n            var msg = new types.Message([\"Two `.'s may only surround one syntax item\"]);\n            throwError(msg, list[dot2Idx].location);\n          // if they are, move that element to the front of the list and remove the dots\n          } else {\n            return list.slice(dot1Idx+1,dot1Idx+2).concat(list.slice(0, dot1Idx), list.slice(dot2Idx+1));\n          }\n        }\n        // okay, we know there's just one dot, so the next element had better be a list AND the last element of the outer list\n        if(!(list[dot1Idx+1] instanceof Array)){\n           var msg = new types.Message([\"A `.' must be followed by a syntax list, but found \"\n                                        , new types.ColoredPart(\"something else\", list[dot1Idx+1].location)])\n           throwError(msg, list[dot1Idx+1].location);\n        }\n        if(list.length > dot1Idx+2){\n           var msg = new types.Message([\"A `.' followed by a syntax list must be followed by a closing delimeter, but found \"\n                                        , new types.ColoredPart(\"something else\", list[dot1Idx+2].location)])\n           throwError(msg, list[dot1Idx+1].location);\n         // splice that element into the list, removing the dots\n         } else {\n           return list.slice(0,dot1Idx).concat(list[dot1Idx+1],list.slice(dot1Idx+2));\n         }\n      }\n                            \n      // if we see an error while reading a listItem\n      function handleError(e){\n        // Some errors we throw immediately, without reading the rest of the list...\n        if(/expected a .+ to (close|open)/.exec(e)   // brace or dot errors\n           || /unexpected/.exec(e)                   // unexpected delimiter\n           || /syntax list/.exec(e)                  // improper use of .\n           || /bad syntax/.exec(e)                   // bad syntax\n           || /bad character constant/.exec(e)       // bad character constant\n           ){\n          throw e;\n        } else {\n          // when we reconstruct the location from an error, we use Racket-style fieldnames, for historical reasons\n          var eLoc = JSON.parse(JSON.parse(e)[\"structured-error\"]).location;\n          errorLocation = new Location(Number(eLoc.column), Number(eLoc.line),\n                                       Number(eLoc.offset)-1, Number(eLoc.span));\n          i = endOfError;// keep reading from the last error location\n          innerError = e;\n        }\n        return i;\n      }\n                            \n      // read forward until we see a closing delim, saving the last known-good location\n      while (i < str.length && !rightListDelims.test(str.charAt(i))) {\n        // check for newlines\n        if(str.charAt(i) === \"\\n\"){ line++; column = 0;}\n        try  { i = readListItem(str, i, list); }  // read a list item, hopefully without error\n        catch (e){ var i = handleError(e);   }        // try to keep reading from endOfError...\n        // move reader to the next token\n        i = chewWhiteSpace(str, i);\n      }\n      // if we reached the end of an otherwise-successful list but there's no closing delim...\n      if(i >= str.length) {\n         var msg = new types.Message([\"read: expected a \", otherDelim(openingDelim),\n                                      \" to close \",\n                                      new types.ColoredPart(openingDelim.toString(),\n                                                            new Location(startCol, startRow, iStart, 1))\n                                      ]);\n         // throw an error\n         throwError(msg, errorLocation);\n      }\n      // if we reached the end of an otherwise-successful list and it's the wrong closing delim...\n      if(!matchingDelims(openingDelim, str.charAt(i))) {\n         var msg = new types.Message([\"read: expected a \", otherDelim(openingDelim),\n                                      \" to close \",\n                                      new types.ColoredPart(openingDelim.toString(),\n                                                            new Location(startCol, startRow, iStart, 1)),\n                                      \" but found a \",\n                                      new types.ColoredPart(str.charAt(i).toString(),\n                                                            new Location(column, line, i, 1))\n                                      ]);\n         throwError(msg, new Location(column, line, i, 1));\n      }\n      \n      column++; i++;  // move forward to count the closing delimeter\n      // if an error occured within the list, set endOfError to the end, and throw it\n      if(innerError){ endOfError = i; throw innerError; }\n                            \n      // deal with dots, if they exist\n      if(dot1Idx || dot2Idx) list = processDots(list, dot1Idx, dot2Idx);\n      list.location = new Location(startCol, startRow, iStart, i-iStart);\n      return list;\n    }\n\n    // readString : String Number -> SExp\n    // reads a string encoded in this string with the leftmost quotation mark\n    // at index i\n    function readString(str, i) {\n      var startCol = column, startRow = line, iStart = i;\n      // greedily match to the end of the string, before examining escape sequences\n      var closedString = /^\\\"[^\\\"]*(\\\\\\\"[^\\\"]*)*[^\\\\]\\\"|\\\"\\\"/.test(str.slice(i)),\n          greedy = /^\\\"[^\\\"]*(\\\\\"[^\\\"]*)*/.exec(str.slice(iStart))[0];\n      i++; column++; // skip over the opening quotation mark char\n      // it's a valid string, so let's make sure it's got proper escape sequences\n      var chr, datum = \"\";\n      while(i < str.length && str.charAt(i) !== '\"') {\n        chr = str.charAt(i++);\n        // track line/char values while we scan\n        if(chr === \"\\n\"){ line++; column = 0;}\n        else { column++; }\n        if(chr === '\\\\') {\n          column++; // move the column forward to skip over the escape character\n          chr = str.charAt(i++);\n          if(i >= str.length) break; // if there's nothing there, break out\n          switch(true){\n             case /a/.test(chr)  : chr = '\\u0007'; break;\n             case /b/.test(chr)  : chr = '\\b'; break;\n             case /t/.test(chr)  : chr = '\\t'; break;\n             case /n/.test(chr)  : chr = '\\n'; break;\n             case /v/.test(chr)  : chr = '\\v'; break;\n             case /f/.test(chr)  : chr = '\\f'; break;\n             case /r/.test(chr)  : chr = '\\r'; break;\n             case /e/.test(chr)  : chr = '\\u0027'; break;\n             case /\\n/.test(chr) : chr = '';   break; // newlines disappear\n             case /[\\\"\\'\\\\]/.test(chr)  : break;\n             // if it's a charCode symbol, match with a regexp and move i forward\n             case /[xuU]/.test(chr):\n                var regexp = chr === \"x\"? hex2\n                            :chr === \"u\"? hex4\n                            /* else */   : hex8;\n                if(!regexp.test(str.slice(i))){\n                  // remember where we are, so readList can pick up reading\n                  endOfError = iStart+greedy.length+1;\n                  throwError(new types.Message([source, \":\" , startRow.toString(), \":\", startCol.toString()\n                                              , \": read: no hex digit following \\\\\"+chr+\" in string\"])\n                           , new Location(startCol, startRow, iStart, i-iStart+1)\n                           , \"Error-GenericReadError\");\n                }\n                var match = regexp.exec(str.slice(i))[1];\n                chr = String.fromCharCode(parseInt(match, 16));\n                i += match.length; column += match.length;\n                break;\n             case oct3.test(str.slice(i-1)) :\n                var match = oct3.exec(str.slice(i-1))[1];\n                chr = String.fromCharCode(parseInt(match, 8));\n                i += match.length-1; column += match.length-1;\n                break;\n             default   :\n                // remember where we are, so readList can pick up reading\n                endOfError = iStart+greedy.length+1;\n                throwError(new types.Message([source, \":\"\n                                              , startRow.toString(), \":\"\n                                              , startCol.toString()\n                                              , \": read: unknown escape sequence \\\\\" +chr+\" in string\"])\n                           , new Location(startCol, startRow, iStart, i-iStart)\n                           , \"Error-GenericReadError\");\n                  }\n        }\n        datum += chr;\n      }\n\n      // if the next char after iStart+openquote+greedy isn't a closing quote, it's an unclosed string\n      if(!closedString) {\n        endOfError = iStart+greedy.length; // remember where we are, so readList can pick up reading\n        throwError(new types.Message([source, \":\"\n                                      , startRow.toString(), \":\"\n                                      , startCol.toString()\n                                      , \": read: expected a closing \\'\\\"\\'\"])\n                   , new Location(startCol, startRow, iStart, 1)\n                   , \"Error-GenericReadError\");\n      }\n      var strng = new literal(new types.string(datum));\n      i++; column++; // move forward to include the ending quote\n      strng.location = new Location(startCol, startRow, iStart, i-iStart);\n      return strng;\n    }\n\n    // readPoundSExp : String Number -> SExp\n    // based on http://docs.racket-lang.org/reference/reader.html#%28part._default-readtable-dispatch%29\n    // NOTE: bytestrings, regexps, hashtables, graphs, reader and lang extensions are not supported\n    function readPoundSExp(str, i) {\n      var startCol = column, startRow = line, iStart = i, datum;\n      i++; column++; // skip over the pound sign\n      // construct an unsupported error string\n      var unsupportedError;\n                            \n      // throwUnsupportedError : ErrorString token -> Error\n      function throwUnsupportedError(errorStr, token){\n        var msg = new types.Message([source, \":\", line.toString()\n                                     , \":\", (column-1).toString()\n                                     , errorStr]);\n        throwError(msg\n                   , new Location(startCol, startRow, iStart, token.length+1)\n                   , \"Error-GenericReadError\");\n      }\n               \n      if(i < str.length) {\n        var p = str.charAt(i).toLowerCase();\n        // fl and fx Vectors, structs, and hashtables are not supported\n        var unsupportedMatch = new RegExp(\"^(((fl|fx|s|hash|hasheq)[\\[\\(\\{])|((rx|px)\\#{0,1}\\\"))\", 'g'),\n            unsupportedTest = unsupportedMatch.exec(str.slice(i));\n        // Reader or Language Extensions are not allowed\n        var badExtensionMatch = /^(!(?!\\/)|reader|lang[\\s]{0,1})/,\n            badExtensionTest = badExtensionMatch.exec(str.slice(i));\n        // Case sensitivity flags ARE allowed\n        var caseSensitiveMatch = new RegExp(\"^(c|C)(i|I|s|S)\"),\n            caseSensitiveTest = caseSensitiveMatch.exec(str.slice(i));\n        // Vector literals ARE allowed\n        var vectorMatch = new RegExp(\"^([0-9]*)[\\[\\(\\{]\", 'g'),\n            vectorTest = vectorMatch.exec(str.slice(i));\n        if(unsupportedTest && unsupportedTest[0].length > 0){\n            var sexp = readSExpByIndex(str, i+unsupportedTest[0].length-1),\n                kind, span = unsupportedTest[0].length, // save different error strings and spans\n                base = unsupportedTest[0].replace(/[\\(\\[\\{\\\"|#\\\"]/g, '');\n            switch(base){\n              case \"fl\":    kind = \"flvectors\"; break;\n              case \"fx\":    kind = \"fxvectors\"; break;\n              case \"s\":     kind = \"structs\";   break;\n              case \"hash\":\n              case \"hasheq\":kind = \"hashtables\"; break;\n              case \"px\":\n              case \"rx\":    kind = \"regular expressions\"; break;\n              default: throw \"IMPOSSIBLE: unsupportedMatch captured something it shouldn't: \"+base;\n            }\n            var error = new types.Message([source, \":\", line.toString(), \":\", \"0\"\n                                           , \": read-syntax: literal \"+ kind + \" not allowed\"]);\n            datum = new unsupportedExpr(sexp, error, span);\n            datum.location = new Location(startCol, startRow, iStart, unsupportedTest[0].length+sexp.location.span);\n            return datum;\n        } else if(badExtensionTest && badExtensionTest[0].length > 0){\n            throwUnsupportedError(\": read: #\" + badExtensionTest[0].trim()\n                              + \" not enabled in the current context\"\n                                  , badExtensionTest[0]);\n        } else if(caseSensitiveTest && caseSensitiveTest[0].length > 0){\n            caseSensitiveSymbols = (caseSensitiveTest[0].toLowerCase() === \"cs\");\n            i+=2; column+=2;\n            return readSExpByIndex(str, i);\n        } else if(vectorTest && vectorTest[0].length > 0){\n          var size = (vectorTest[1])? parseInt(vectorTest[1]) : \"\",    // do we have a size string?\n              sizeChars = size.toString().length;                     // how long is the size string?\n          i+=sizeChars; column+=sizeChars           // start reading after the vectorsize was specified\n          var elts = readList(str, i),\n              len = size===\"\"? elts.length : parseInt(vectorTest[1]);  // set the size to a number\n          // test vector size\n          if(elts.length > len){\n             var msg = new types.Message([\"read: vector length \"+len+\" is too small, \",\n                                          elts.length+\" value\" + ((elts.length>1)? \"s\" : \"\"),\n                                          \" provided\"]);\n             throwError(msg, new Location(startCol, startRow, iStart, vectorTest[0].length));\n          }\n\n          i+=elts.location.span;\n          datum = new literal(new Vector(len, elts));\n          datum.location = new Location(startCol, startRow, iStart, i-iStart);\n          return datum;\n        } else {\n          // match every valid (or *almost-valid*) sequence of characters, or the empty string\n          var poundChunk = new RegExp(\"^(hasheq|hash|fl|fx|\\\\d+|true|false|[tfeibdox]|\\\\<\\\\<|[\\\\\\\\\\\\\\\"\\\\%\\\\:\\\\&\\\\|\\\\;\\\\!\\\\`\\\\,\\\\']|)\", 'i'),\n              chunk = poundChunk.exec(str.slice(i))[0],\n              // match the next character\n              nextChar = str.charAt(i+chunk.length);\n          // grab the first non-whitespace character\n          var p = chunk.charAt(0).toLowerCase();\n          switch(p){\n            // CHARACTERS\n            case '\\\\': datum = readChar(str, i-1);\n                       i+= datum.location.span-1; break;\n            // BYTE-STRINGS (unsupported)\n            case '\"': throwUnsupportedError(\": byte strings are not supported in WeScheme\", \"#\\\"\");\n            // SYMBOLS\n            case '%': datum = readSymbolOrNumber(str, i);\n                      datum.val = '#'+datum.val;\n                      i+= datum.location.span; break;\n            // KEYWORDS (lex to a symbol, then strip out the contents)\n            case ':': datum = readSymbolOrNumber(str, i-1);\n                      var error = new types.Message([source, \":\", line.toString(), \":\", \"0\"\n                                                   , \": read-syntax: Keyword internment is not supported in WeScheme\"]);\n                      datum = new unsupportedExpr(datum.val, error, datum.location.span);\n                      i+= datum.val.length-1;\n                      break;\n            // BOXES\n            case '&': column++;\n                      sexp = readSExpByIndex(str, i+1);\n                      var boxCall = new symbolExpr(\"box\"),\n                          datum = [boxCall, sexp];\n                      i+= sexp.location.span+1;\n                      boxCall.location = new Location(startCol, startRow, iStart, i-iStart);\n                      break;\n            // BLOCK COMMENTS\n            case '|': i--;\n                      datum = readBlockComment(str, i);\n                      i+= datum.location.span+1; break;\n            // SEXP COMMENTS\n            case ';': datum = readSExpComment(str, i+1);\n                      i+= datum.location.span+1; break;\n            // LINE COMMENTS\n            case '!': datum = readLineComment(str, i-1);\n                      i+= datum.location.span; break;\n            // SYNTAX QUOTES, UNQUOTES, AND QUASIQUOTES\n            case '`':\n            case ',':\n            case '\\'': datum = readQuote(str, i);\n                      datum.location.startChar--; datum.location.span++; // expand the datum to include leading '#'\n                      endOfError = i+datum.location.span;\n                      var msg = new types.Message([source, \":\", startRow.toString()\n                                                   , \":\", (column-1).toString()\n                                                   , \" read: WeScheme does not support the '#\"+p+\"' notation for \"\n                                                   , (p===\",\"? \"unsyntax\" : p===\"'\"? \"syntax\" : \"quasisyntax\")]);\n                      throwError(msg, datum.location);\n                      break;\n            // STRINGS\n            case '<<': datum = readString(str, i-1);\n                       i+= datum.location.span; break;\n            // NUMBERS\n            case 'e':  // exact\n            case 'i':  // inexact\n            case 'b':  // binary\n            case 'o':  // octal\n            case 'd':  // decimal\n            case 'x':  // hexadecimal\n                column--; //  back up the column one char\n                datum = readSymbolOrNumber(str, i-1);\n                i+= datum.location.span-1; break;\n            // BOOLEANS\n            case 'true':\n            case 'false':\n            case 't':  // true\n            case 'f':  // false\n                if(!matchUntilDelim.exec(nextChar)){             // if there's no other chars aside from space or delims...\n                  datum = new literal(p==='t' || chunk==='true'); // create a Boolean literal\n                  i+=chunk.length; column+=chunk.length;         // move i/col ahead by the char\n                  break;\n                }\n            default:\n              endOfError = i; // remember where we are, so readList can pick up reading\n              var msg = new types.Message([source, \":\", line.toString()\n                                           , \":\", (column-1).toString()\n                                           , \": read: bad syntax `#\", (chunk+nextChar),\"'\"]);\n              throwError(msg\n                        , new Location(startCol, startRow, iStart, (chunk+nextChar).length+1)\n                        , \"Error-GenericReadError\");\n           }\n        }\n      // only reached if # is the end of the string...\n      } else {\n        endOfError = i; // remember where we are, so readList can pick up reading\n        throwError(new types.Message([source, \":\", line.toString()\n                                     , \":\" , (column-1).toString()\n                                     , \": read: bad syntax `#'\"])\n                  , new Location(startCol, startRow, iStart, i-iStart)\n                  , \"Error-GenericReadError\");\n      }\n      datum.location = new Location(startCol, startRow, iStart, i-iStart);\n      return datum;\n    }\n\n    // readChar : String Number -> types.char\n    // reads a character encoded in the string and returns a representative datum\n    // see http://docs.racket-lang.org/reference/reader.html#%28part._parse-character%29\n    function readChar(str, i) {\n      var startCol = column, startRow = line, iStart = i;\n      i+=2;  column++; // skip over the #\\\\\n      var datum = \"\", isFirstChar=true, regexp;\n                                                        \n      // read until we hit the end of the string, another char, or whitespace when it's not the first char\n      while(i < str.length && (str.slice(i,i+2) !== \"#\\\\\")\n             && !(!isFirstChar && (isWhiteSpace(str.charAt(i)) || isDelim(str.charAt(i))) )) {\n        isFirstChar = false;\n        column++;\n        datum += str.charAt(i++);\n      }\n                                                        \n      // a special char is one of the following, as long as the next char is not alphabetic\n      // unlike DrRacket, there is no JS equivalent for nul, null, page and rubout\n      var special = new RegExp(\"(backspace|tab|newline|space|vtab)[^a-zA-Z]*\", \"i\"),\n          match = special.exec(datum);\n      // check for special chars\n      if(special.test(datum)){\n          datum = datum === 'backspace'? '\\b' :\n                  datum === 'tab' ?     '\\t' :\n                  datum === 'newline' ? '\\n' :\n                  datum === 'space' ?   ' ' :\n                  datum === 'vtab' ?    '\\v' :\n                    \"Impossible: unknown special char was matched by special char!\";\n          i = iStart + 2 + match[1].length; // set the reader to the end of the char\n                                                        \n       // octal charCodes\n       } else if(/^[0-9].*/.test(datum)                       // if it starts with a number...\n                 && oct3.test(datum)                         // it had better have some octal digits..\n                 && (oct3.exec(datum)[0]===datum)            // in fact, all of them should be octal..\n                 && (parseInt(oct3.exec(datum)[0], 8) < 256) // and less than 256...\n                 && (parseInt(oct3.exec(datum)[0], 8) > 31)  // and greater than 31,\n                 ) {\n          var match = /[0-7]+/.exec(datum)[0];\n          datum = String.fromCharCode(parseInt(match, 8));\n          i = iStart + 2 + match.length; // set the reader to the end of the char\n                                                        \n       // check for hex4 or hex6\n      } else if( /[uU]/.test(datum)                          // if it declares itself to be hexidecimal...\n                && (regexp=datum.charAt(0)===\"u\"? hex4:hex6) // and we have a regexp for it...\n                && regexp.test(datum.slice(1))               // and it's a valid hex code for that regexp...\n              ){\n          var match = regexp.exec(datum.slice(1))[0];\n          column += (match.length-datum.length)+1; // adjust column if only a subset of the datum matched\n          datum = String.fromCharCode(parseInt(match, 16));\n          i = iStart + 3 + match.length; // fast-forward past (1) hash, (2) backslash, (3) u and (4) number\n       // check for a single character, or a character that is NOT followed by a unicode-alphabetic character\n      } else if (datum.length===1 || /[^\\u00C0-\\u1FFF\\u2C00-\\uD7FF\\w]$/.test(datum.charAt(1))) {\n          datum = datum.charAt(0);\n          i = iStart + 3; // fast-forward past (1) hash, (2) backslash and (3) single char\n      } else {\n          throwError(new types.Message([source , \":\" , startRow.toString(), \":\", (startCol-1).toString(),\n                                        \": read: bad character constant: #\\\\\",datum]),\n                     new Location(startCol-1, startRow, iStart, i-iStart),\n                     \"Error-GenericReadError\");\n      }\n      var chr = new literal(new types['char'](datum));\n      chr.location = new Location(startCol, startRow, iStart, i-iStart);\n      return chr;\n    }\n\n    // readBlockComment : String Number -> Atom\n    // reads a multiline comment\n    function readBlockComment(str, i) {\n      var startCol = column, startRow = line, iStart = i;\n      i+=2; column+=2; // skip over the #|\n      var txt = \"\";\n      while(i+1 < str.length && !(str.charAt(i) === '|' && str.charAt(i+1) === '#')) {\n        // check for newlines\n        if(str.charAt(i) === \"\\n\"){ line++; column = 0;}\n        txt+=str.charAt(i);\n        i++; column++;  // move ahead\n      }\n      if(i+1 >= str.length) {\n        throwError(new types.Message([\"read: Unexpected EOF when reading a multiline comment\"])\n                   ,new Location(startCol, startRow, iStart, i-iStart));\n      }\n      i++; column++; // hop over '|#'\n      var comment = new Comment(txt);\n      comment.location = new Location(startCol, startRow, iStart, i-iStart);\n      return comment;\n    }\n\n    // readSExpComment : String Number -> Atom\n    // reads exactly one SExp and ignores it entirely\n    function readSExpComment(str, i) {\n      var startCol = column++, startRow = line, iStart = i, nextSExp;\n      // keep reading s-exprs while...\n      while((i = chewWhiteSpace(str, i)) &&           // there's whitespace to chew\n            (i+1<str.length) &&                         // we're not out of string\n            (nextSExp = readSExpByIndex(str, i)) &&   // there's an s-expr to be read\n            (nextSExp instanceof Comment)){            // and it's not a comment\n        i = nextSExp.location.endChar;\n      }\n                                                        \n      // if we're done reading, make sure we didn't read past the end of the file\n      if(i+1 >= str.length) {\n        endOfError = i; // remember where we are, so readList can pick up reading\n        throwError(new types.Message([source , \":\" , startRow.toString(), \":\", (startCol-1).toString()\n                                      , \": read: expected a commented-out element for `#;' (found end-of-file)\"])\n                   ,new Location(startCol-1, startRow, i-2, 2) // back up the startChar before #;, make the span include only those 2\n                   ,\"Error-GenericReadError\");\n      }\n      // if we're here, then we read a proper s-expr\n      var atom = new Comment(\"(\"+nextSExp.toString()+\")\");\n      i = nextSExp.location.endChar;\n      atom.location = new Location(startCol, startRow, iStart, i-iStart);\n      return atom;\n    }\n\n    // readLineComment : String Number -> Atom\n    // reads a single line comment\n    function readLineComment(str, i) {\n      var startCol = column, startRow = line, iStart = i;\n      i++; column++; // skip over the ;\n      var txt = \"\";\n      while(i < str.length && str.charAt(i) !== '\\n') {\n        // track column values while we scan\n        txt+=str.charAt(i); column++; i++;\n      }\n      if(i > str.length) {\n        endOfError = i; // remember where we are, so readList can pick up reading\n        throwError(new types.Message([\"read: Unexpected EOF when reading a line comment\"]),\n                   new Location(startCol, startRow, iStart, i-iStart));\n      }\n      var atom = new Comment(txt);\n      atom.location = new Location(startCol, startRow, iStart, i+1-iStart);\n      // at the end of the line, reset line/col values\n      line++; column = 0;\n      return atom;\n    }\n\n    // readQuote : String Number -> SExp\n    // reads a quote, quasiquote, or unquote encoded as a string\n    // NOT OPTIMIZED BY V8, due to presence of try/catch\n    function readQuote(str, i) {\n      var startCol = column, startRow = line, iStart = i, nextSExp;\n      var p = str.charAt(i);\n      var symbol = p == \"'\" ? new symbolExpr(\"quote\") :\n                   p == \"`\" ? new symbolExpr(\"quasiquote\") :\n                   /* else */  \"\";\n      function eofError(i){\n        endOfError = i+1; // remember where we are, so readList can pick up reading\n        var action = p == \"'\" ? \" quoting \" :\n                     p == \"`\" ? \" quasiquoting \" :\n                     p == \",\" ? \" unquoting \" :\n                     p == \",@\" ? \" unquoting \" :                                 \n                     /* else */  \"\";\n        throwError(new types.Message([source, \":\", startRow.toString(), \":\", startCol.toString()\n                                      , \": read: expected an element for\" + action, p\n                                      , \" (found end-of-file)\"])\n                   , new Location(startCol, startRow, iStart, p.length)\n                   , \"Error-GenericReadError\");\n      }\n      if(i+1 >= str.length) { eofError(i); }\n      i++; column++; // read forward one char\n      if(p == ',') {\n        if(str.charAt(i) == '@') {\n          i++; column++; p+='@'; // read forward one char, and add @ to the option\n          symbol = new symbolExpr(\"unquote-splicing\");\n        } else {\n          symbol = new symbolExpr(\"unquote\");\n        }\n      }\n\n      symbol.location = new Location(column-1, startRow, iStart, i - iStart);\n\n      // read the next non-comment sexp\n      while(!nextSExp || (nextSExp instanceof Comment)){\n        i = chewWhiteSpace(str, i);\n        try{nextSExp = readSExpByIndex(str, i);}\n        catch(e){\n          // if it's the end of file, throw a special EOF for quoting\n          if(/read\\: \\(found end-of-file\\)/.test(e)) eofError(i);\n          var unexpected = /expected a .* to open \\\",\\\"(.)\\\"/.exec(e);\n          if(unexpected){\n            endOfError = i+1; // remember where we are, so readList can pick up reading\n            throwError(new types.Message([source, \":\", line.toString(), \":\", column.toString()\n                                          , \": read: unexpected `\" + unexpected[1] + \"'\"])\n                       , new Location(column, line, i, 1)\n                       , \"Error-GenericReadError\");\n          }\n          throw e;\n        }\n        i = nextSExp.location.end().startChar+1;\n      }\n      var quotedSexp = [symbol, nextSExp],\n          quotedSpan = (nextSExp.location.end().startChar+1) - iStart;\n      \n      quotedSexp.location = new Location(startCol, startRow, iStart, quotedSpan);\n      return quotedSexp;\n    }\n                   \n                                                                \n    // readSymbolOrNumber : String Number -> symbolExpr | types.Number\n    // NOT OPTIMIZED BY V8, due to presence of try/catch\n    function readSymbolOrNumber(str, i){\n      var startCol = column, startRow = line, iStart = i;\n      // match anything consisting of stuff between two |bars|, **OR**\n      // non-whitespace characters that do not include:  ( ) { } [ ] , ' ` | \\\\ \" ;\n      var symOrNum = new RegExp(\"(\\\\|(.|\\\\n)*\\\\||\\\\\\\\(.|\\\\n)|[^\\\\(\\\\)\\\\{\\\\}\\\\[\\\\]\\\\,\\\\'\\\\`\\\\s\\\\\\\"\\\\;])+\", 'mg');\n      var chunk = symOrNum.exec(str.slice(i))[0];\n      // if there's an unescaped backslash at the end, throw an error\n      var trailingEscs = /\\.*\\\\+$/.exec(chunk);\n      if(trailingEscs && (trailingEscs[0].length%2 > 0)){\n            i = str.length; // jump to the end of the string\n            endOfError = i; // remember where we are, so readList can pick up reading\n            throwError(new types.Message([source, \":\", line.toString(), \":\", startCol.toString(),\n                                          \": read: EOF following `\\\\' in symbol\"])\n                       ,new Location(startCol, startRow, iStart, i-iStart)\n                       ,\"Error-GenericReadError\");\n      }\n      // move the read head and column tracker forward\n      i+=chunk.length; column+=chunk.length;\n                                                        \n      // remove escapes\n      var unescaped = \"\";\n      for(var j=0; j < chunk.length; j++){\n        if(chunk.charAt(j) == \"\\\\\") { j++; }  // if it's an escape char, skip over it and add the next one\n        unescaped += chunk.charAt(j);\n      }\n      // split the chunk at each |\n      var chunks = unescaped.split(\"|\");\n      // check for unbalanced |'s, and generate an error that begins at the last one\n      // and extends for the remainder of the string\n      if(((chunks.length%2) === 0)){\n          endOfError = str.length;\n          var sizeOfLastChunk = chunks[chunks.length-1].length+1, // add 1 for the starting '|'\n              strBeforeLastChunk = chunk.slice(0, chunk.length-sizeOfLastChunk),\n              lastVerbatimMarkerIndex = iStart+strBeforeLastChunk.length;\n          // We need to go back and get more precise location information\n          column = startCol;\n          for(var j=0; j<strBeforeLastChunk.length; j++){\n            if(str.charAt(i) === \"\\n\"){line++; column = 0;}\n            else { column++; }\n          }\n          throwError(new types.Message([source, \":\", line.toString(), \":\", column.toString(),\n                                        \": read: unbalanced `|'\"])\n                      ,new Location(column, line, lastVerbatimMarkerIndex, str.length-lastVerbatimMarkerIndex)\n                      ,\"Error-GenericReadError\");\n      }\n                                                        \n      // enforce case-sensitivity for non-verbatim sections.\n      var filtered = chunks.reduce(function(acc, str, i){\n            // if we're inside a verbatim portion (i is even) *or* we're case sensitive, preserve case\n            return acc+= (i%2 || caseSensitiveSymbols)? str : str.toLowerCase();\n          }, \"\");\n\n      // if it's a newline, adjust line and column trackers\n      if(filtered===\"\\n\"){line++; column=0;}\n\n      // add bars if it's a symbol that needs those escape characters, or if the original string used an escaped number\n      var special_chars = new RegExp(\"^$|[\\\\(\\\\)\\\\{\\\\}\\\\[\\\\]\\\\,\\\\'\\\\`\\\\s\\\\\\\"\\\\\\\\]\", 'g');\n      var escaped_nums = new RegExp(\"^.*\\\\\\\\[\\\\d]*.*|\\\\|[\\\\d]*\\\\|\");\n      filtered = (escaped_nums.test(chunk) || special_chars.test(filtered)? \"|\"+filtered+\"|\" : filtered);\n                                                        \n      // PERF: start out assuming it's a symbol...\n      var node = new symbolExpr(filtered);\n      // PERF: if it's not trivially a symbol, we take the hit of jsnums.fromString()\n      if((chunks.length === 1) && !/^[a-zA-Z\\-\\?]+$/.test(filtered)){\n        // attempt to parse using jsnums.fromString(), assign to sexp and add location\n        // if it's a bad number, throw an error\n        try{\n           var numValue = jsnums.fromString(filtered, true);\n           // If it's a number (don't interpret zero as 'false'), that's our node\n           if(numValue || numValue === 0){\n             if(numValue instanceof Object){\n               numValue.stx = filtered;\n               numValue.location = new Location(startCol, startRow, iStart, i-iStart);\n             }\n             node = new literal(numValue);\n           }\n        // if it's not a number OR a symbol\n        } catch(e) {\n            endOfError = i; // remember where we are, so readList can pick up reading\n            var msg = new types.Message([source, \":\", startRow.toString()\n                                         , \":\" , startCol.toString()\n                                         , \": read: \"+e.message]);\n            throwError(msg\n                       , new Location(startCol, startRow, iStart, i-iStart)\n                       , \"Error-GenericReadError\");\n        }\n      }\n      node.stx = filtered; // save the string that generated the symbol/number to begin with\n      node.location = new Location(startCol, startRow, iStart, i-iStart);\n      return node;\n    }\n    /////////////////////\n    /* Export Bindings */\n    /////////////////////\n    plt.compiler.lex = function(str, strSource, debug){\n        var start = new Date().getTime();\n        try { var sexp      = readProg(str, strSource); }  // do the actual work\n        catch(e) { console.log(\"LEXING ERROR\"); throw e; }\n        var end = new Date().getTime();\n        if(debug){\n          console.log(\"Lexed in \"+(Math.floor(end-start))+\"ms\");\n          console.log(sexp);\n          console.log(sexpToString(sexp));\n        }\n        return sexp;\n    };\n    plt.compiler.sexpToString = sexpToString;\n})();\n\nmodule.exports = plt.compiler;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/lex.js\n ** module id = 1\n ** module chunks = 0\n **/","var types = require('./runtime/types');\nvar Vector = types.Vector;\n\n// if not defined, declare the compiler object as part of plt\nwindow.plt   = window.plt   || {};\nplt.compiler = plt.compiler || {};\n//plt.compiler = require('./modules');\n\n/*\n TODO\n - have modulePathResolver return the proper name!\n */\n\n//////////////////////////////////////////////////////////////////////////////\n/////////////////// COMMON FUNCTIONS AND STRUCTURES //////////////////////////\n//////////////// used by multiple phases of the compiler/////////////////////\n\n(function () {\n 'use strict';\n \n  var unimplementedException = function(str){\n    this.str = str;\n  }\n\n  /**************************************************************************\n   *\n   *    CONVERT LOCAL COMPILER ERRORS INTO WESCHEME ERRORS\n   *\n   **************************************************************************/\n  // encode the msg and location as a JSON error\n  function throwError(msg, loc, errorClass) {\n    loc.source = loc.source || \"<unknown>\"; // FIXME -- we should have the source populated\n    // rewrite a ColoredPart to match the format expected by the runtime\n    function rewritePart(part){\n      if(typeof(part) === 'string'){\n        return part;\n      } else if(part instanceof symbolExpr){\n        return '[\"span\", [[\"class\", \"SchemeValue-Symbol\"]], '+part.val+']';\n        return part.val;\n      } else if(part.location !== undefined){\n        return {text: part.text, type: 'ColoredPart', loc: part.location.toString()\n              , toString: function(){return part.text;}};\n      } else if(part.locations !== undefined){\n        return {text: part.text, type: 'MultiPart', solid: part.solid\n              , locs: part.locations.map(function(l){return l.toString()})\n              , toString: function(){return part.text;}};\n      }\n    }\n    \n    msg.args = msg.args.map(rewritePart);\n    \n    var json = {type: \"moby-failure\"\n      , \"dom-message\": [\"span\"\n                        ,[[\"class\", \"Error\"]]\n                        ,[\"span\"\n                          , [[\"class\", (errorClass || \"Message\")]]].concat(\n                           (errorClass? [[\"span\"\n                                          , [[\"class\", \"Error.reason\"]]\n                                          , msg.toString()]\n                                        , [\"span\", [[\"class\", ((errorClass || \"message\")\n                                                              +((errorClass === \"Error-GenericReadError\")?\n                                                                \".locations\"\n                                                                :\".otherLocations\"))]]]]\n                                        : msg.args.map(function(x){return x.toString();})))\n                        ,[\"br\", [], \"\"]\n                        ,[\"span\"\n                          , [[\"class\", \"Error.location\"]]\n                          , [\"span\"\n                             , [[\"class\", \"location-reference\"]\n                                , [\"style\", \"display:none\"]]\n                             , [\"span\", [[\"class\", \"location-offset\"]], (loc.startChar+1).toString()]\n                             , [\"span\", [[\"class\", \"location-line\"]]  , loc.startRow.toString()]\n                             , [\"span\", [[\"class\", \"location-column\"]], loc.startCol.toString()]\n                             , [\"span\", [[\"class\", \"location-span\"]]  , loc.span.toString()]\n                             , [\"span\", [[\"class\", \"location-id\"]]    , loc.source.toString()]\n                             ]\n                          ]\n                        ]\n      , \"structured-error\": JSON.stringify({message: (errorClass? false : msg.args), location: loc.toString() })\n    };\n    throw JSON.stringify(json);\n  }\n\n  // couple = pair\n  function couple(first, second) {\n    this.first = first;\n    this.second = second;\n    this.toString = function(){\n      return \"(\"+this.first.toString() +\" \"+this.second.toString()+\")\";\n    };\n  };\n\n  /**************************************************************************\n   *\n   *    AST Nodes\n   *\n   **************************************************************************/\n\n  // Inheritance from pg 168: Javascript, the Definitive Guide.\n  var heir = function(p) {\n    var f = function() {};\n    f.prototype = p;\n    return new f();\n  };\n\n  // all Programs, by default, print out their values\n  // anything that behaves differently must provide their own toString() function\n  var Program = function() {\n    // -> String\n    this.toString = function(){ return this.val.toString(); };\n    // every Program has a location, but it's initialized to null\n    this.location = null;\n  };\n\n  // Function definition\n  function defFunc(name, args, body, stx) {\n    Program.call(this);\n    this.name = name;\n    this.args = args;\n    this.body = body;\n    this.stx  = stx;\n    this.toString = function(){\n      return \"(define (\"+this.name.toString()+\" \"+this.args.join(\" \")+\")\\n    \"+this.body.toString()+\")\";\n    };\n  };\n  defFunc.prototype = heir(Program.prototype);\n\n\n  // Variable definition\n  function defVar(name, expr, stx) {\n    Program.call(this);\n    this.name = name;\n    this.expr = expr;\n    this.stx  = stx;\n    this.toString = function(){\n      return \"(define \"+this.name.toString()+\" \"+this.expr.toString()+\")\";\n    };\n  };\n  defVar.prototype = heir(Program.prototype);\n\n  // Multi-Variable definition\n  function defVars(names, expr, stx) {\n    Program.call(this);\n    this.names  = names;\n    this.expr   = expr;\n    this.stx    = stx;\n    this.toString = function(){\n      return \"(define-values (\"+this.names.join(\" \")+\") \"+this.expr.toString()+\")\";\n    };\n  };\n  defVars.prototype = heir(Program.prototype);\n\n  // Structure definition\n  function defStruct(name, fields, stx) {\n    Program.call(this);\n    this.name   = name;\n    this.fields = fields;\n    this.stx    = stx;\n    this.toString = function(){\n      return \"(define-struct \"+this.name.toString()+\" (\"+this.fields.toString()+\"))\";\n    };\n  };\n  defStruct.prototype = heir(Program.prototype);\n\n  // Begin expression\n  function beginExpr(exprs, stx) {\n    Program.call(this);\n    this.exprs  = exprs;\n    this.stx    = stx;\n    this.toString = function(){\n      return \"(begin \"+this.exprs.join(\" \")+\")\";\n    };\n  };\n  beginExpr.prototype = heir(Program.prototype);\n\n  // Lambda expression\n  function lambdaExpr(args, body, stx) {\n    Program.call(this);\n    this.args = args;\n    this.body = body;\n    this.stx  = stx;\n    this.toString = function(){\n      return \"(lambda (\"+this.args.join(\" \")+\") \"+this.body.toString()+\")\";\n    };\n  };\n  lambdaExpr.prototype = heir(Program.prototype);\n\n  // Local expression\n  function localExpr(defs, body, stx) {\n    Program.call(this);\n    this.defs = defs;\n    this.body = body;\n    this.stx  = stx;\n    this.toString = function(){\n      return \"(local (\"+this.defs.toString()+\") \"+this.body.toString()+\")\";\n    };\n  };\n  localExpr.prototype = heir(Program.prototype);\n\n  // Letrec expression\n  function letrecExpr(bindings, body, stx) {\n    this.bindings = bindings;\n    this.body     = body;\n    this.stx      = stx;\n    this.toString = function(){\n      return \"(letrec (\"+this.bindings.toString()+\") (\"+this.body.toString()+\"))\";\n    };\n  };\n\n  // Let expression\n  function letExpr(bindings, body, stx) {\n    this.bindings = bindings;\n    this.body     = body;\n    this.stx      = stx;\n    this.toString = function(){\n      return \"(let (\"+this.bindings.toString()+\") (\"+this.body.toString()+\"))\";\n    };\n  };\n\n  // Let* expressions\n  function letStarExpr(bindings, body, stx) {\n    this.bindings = bindings;\n    this.body     = body;\n    this.stx      = stx;\n    this.toString = function(){\n      return \"(let* (\"+this.bindings.toString()+\") (\"+this.body.toString()+\"))\";\n    };\n  };\n\n  // cond expression\n  function condExpr(clauses, stx) {\n    this.clauses  = clauses;\n    this.stx      = stx;\n    this.toString = function(){\n      return \"(cond\\n    \"+this.clauses.join(\"\\n    \")+\")\";\n    };\n  };\n\n  // Case expression\n  function caseExpr(expr, clauses, stx) {\n    Program.call(this);\n    this.expr     = expr;\n    this.clauses  = clauses;\n    this.stx      = stx;\n    this.toString = function(){\n      return \"(case \"+this.expr.toString()+\"\\n    \"+this.clauses.join(\"\\n    \")+\")\";\n    };\n  };\n  caseExpr.prototype = heir(Program.prototype);\n\n  // and expression\n  function andExpr(exprs, stx) {\n    this.exprs  = exprs;\n    this.stx    = stx;\n    this.toString = function(){ return \"(and \"+this.exprs.join(\" \")+\")\"; };\n  };\n\n  // or expression\n  function orExpr(exprs, stx) {\n    this.exprs  = exprs;\n    this.stx    = stx;\n    this.toString = function(){ return \"(or \"+this.exprs.toString()+\")\"; };\n  };\n\n  // application expression\n  function callExpr(func, args, stx) {\n    Program.call(this);\n    this.func   = func;\n    this.args   = args;\n    this.stx    = stx;\n    this.toString = function(){\n      return \"(\"+[this.func].concat(this.args).join(\" \")+\")\";\n    };\n  };\n  callExpr.prototype = heir(Program.prototype);\n\n  // if expression\n  function ifExpr(predicate, consequence, alternative, stx) {\n    Program.call(this);\n    this.predicate = predicate;\n    this.consequence = consequence;\n    this.alternative = alternative;\n    this.stx = stx;\n    this.toString = function(){\n      return \"(if \"+this.predicate.toString()+\" \"+this.consequence.toString()+\" \"+this.alternative.toString()+\")\";\n    };\n  };\n  ifExpr.prototype = heir(Program.prototype);\n\n  // when/unless expression\n  function whenUnlessExpr(predicate, exprs, stx) {\n    Program.call(this);\n    this.predicate = predicate;\n    this.exprs = exprs;\n    this.stx = stx;\n    this.toString = function(){\n      return \"(\"+this.stx[0]+\" \"+this.predicate.toString()+\" \"+this.exprs.toString()+\")\";\n    };\n  };\n  whenUnlessExpr.prototype = heir(Program.prototype);\n\n  // symbol expression (ID)\n  function symbolExpr(val, stx) {\n    Program.call(this);\n    this.val = val;\n    this.stx = stx;\n  };\n  symbolExpr.prototype = heir(Program.prototype);\n\n  // Literal values (String, Char, Number, Vector)\n  function literal(val) {\n    Program.call(this);\n    this.val = val;\n    this.toString = function(){\n      // racket prints booleans using #t and #f\n      if(this.val===true) return \"#t\";\n      if(this.val===false) return \"#f\";\n      // racket prints special chars using their names\n      if(this.val instanceof Char){\n        var c = this.val.val;\n        return c === '\\b' ? '#\\\\backspace' :\n              c === '\\t' ? '#\\\\tab' :\n              c === '\\n' ? '#\\\\newline' :\n              c === ' '  ? '#\\\\space' :\n              c === '\\v' ? '#\\\\vtab' :\n              /* else */  this.val.toWrittenString();\n      }\n      return types.toWrittenString(this.val);\n    }\n  };\n  literal.prototype = heir(Program.prototype);\n\n  Vector.prototype.toString = Vector.prototype.toWrittenString = function(){\n    var filtered = this.elts.filter(function(e){return e!==undefined;}),\n        last = filtered[filtered.length-1];\n    return \"#(\"+this.elts.map(function(elt){return elt===undefined? last : elt;})+\")\";\n  }\n\n  // quoted expression\n  function quotedExpr(val) {\n    Program.call(this);\n    this.val = val;\n    this.toString = function() {\n      function quoteLikePairP(v) {\n        return v instanceof Array\n          && v.length === 2\n          && v[0] instanceof symbolExpr\n          && (    v[0].val === 'quasiquote'\n                  || v[0].val === 'quote'\n                  || v[0].val === 'unquote'\n                  || v[0].val === 'unquote-splicing'\n             ) }\n      function shortName(lexeme) {\n        var s = lexeme.val\n        return s === 'quasiquote' ? \"`\" :\n          s === 'quote' ? \"'\" :\n          s === 'unquote' ? \",\" :\n          s === 'unquote-splicing' ? \",@\" :\n          (function () { throw \"impossible quote-like string\" })()\n      }\n      function elementToString(v) {\n        if (quoteLikePairP(v)) {\n          return shortName(v[0]).concat(elementToString(v[1]))\n        } else if (v instanceof Array) {\n          return v.reduce(function (acc, x) { return acc.concat(elementToString(x)) }, \"(\").concat(\")\")\n        } else {\n          return v.toString()\n        }\n      }\n\n      return \"'\"+elementToString(this.val)\n    }\n  };\n  quotedExpr.prototype = heir(Program.prototype);\n\n  // unquoted expression\n  function unquotedExpr(val) {\n    Program.call(this);\n    this.val = val;\n    this.toString = function(){ return \",\"+this.val.toString(); };\n  };\n  unquotedExpr.prototype = heir(Program.prototype);\n\n  // quasiquoted expression\n  function quasiquotedExpr(val) {\n    Program.call(this);\n    this.val = val;\n    this.toString = function(){\n      if(this.val instanceof Array) return \"`(\"+this.val.toString()+\")\";\n      else return \"`\"+this.val.toString();\n    };\n  };\n  quasiquotedExpr.prototype = heir(Program.prototype);\n\n  // unquote-splicing\n  function unquoteSplice(val) {\n    Program.call(this);\n    this.val = val;\n    this.toString = function(){ return \",@\"+this.val.toString();};\n  };\n  unquoteSplice.prototype = heir(Program.prototype);\n\n  // require expression\n  function requireExpr(spec, stx) {\n    Program.call(this);\n    this.spec = spec;\n    this.stx  = stx;\n    this.toString = function(){ return \"(require \"+this.spec.toString()+\")\"; };\n  };\n  requireExpr.prototype = heir(Program.prototype);\n\n  // provide expression\n  function provideStatement(clauses, stx) {\n    Program.call(this);\n    this.clauses  = clauses;\n    this.stx      = stx;\n    this.toString = function(){ return \"(provide \"+this.clauses.toString()+\")\" };\n  };\n  provideStatement.prototype = heir(Program.prototype);\n\n  // Unsupported structure (allows us to generate parser errors ahead of \"unsupported\" errors)\n  function unsupportedExpr(val, errorMsg, errorSpan) {\n    Program.call(this);\n    this.val = val;\n    this.errorMsg = errorMsg;\n    this.errorSpan = errorSpan; // when throwing an error, we use a different span from the actual sexp span\n    this.toString = function(){ return this.val.toString() };\n  };\n  unsupportedExpr.prototype = heir(Program.prototype);\n\n\n  function isExpression(node){\n    return !(   (node instanceof defVar)\n             || (node instanceof defVars)\n             || (node instanceof defStruct)\n             || (node instanceof defFunc)\n             || (node instanceof provideStatement)\n             || (node instanceof unsupportedExpr)\n             || (node instanceof requireExpr));\n  }\n\n  function isDefinition(node){\n    return (node instanceof defVar)\n        || (node instanceof defVars)\n        || (node instanceof defStruct)\n        || (node instanceof defFunc);\n  }\n\n  /**************************************************************************\n   *\n   *    STRUCTURES NEEDED BY THE COMPILER\n   *\n   **************************************************************************/\n\n  // moduleBinding: records an id and its associated JS implementation.\n  function moduleBinding(name, bindings){\n    this.name     = name;\n    this.bindings = bindings;\n  }\n\n  // constantBinding: records an id and its associated JS implementation.\n  function constantBinding(name, moduleSource, permissions, loc){\n    this.name = name;\n    this.moduleSource = moduleSource;\n    this.permissions = permissions;\n    this.loc = loc;\n    this.toString = function(){return this.name;};\n    return this;\n  }\n\n  // functionBinding: try to record more information about the toplevel-bound function\n  function functionBinding(name, moduleSource, minArity, isVarArity, permissions, isCps, loc){\n    this.name = name;\n    this.moduleSource = moduleSource;\n    this.minArity = minArity;\n    this.isVarArity = isVarArity;\n    this.permissions = permissions;\n    this.isCps = isCps;\n    this.loc = loc;\n    this.toString = function(){return this.name;};\n    return this;\n  }\n\n  // structBinding: A binding to a structure.\n  // structBinding : symbol, ?, (listof symbol), symbol, symbol, (listof symbol) (listof symbol) (listof permission), location -> Binding\n  function structBinding(name, moduleSource, fields, constructor,\n                        predicate, accessors, mutators, permissions, loc){\n    this.name = name;\n    this.moduleSource = moduleSource;\n    this.fields = fields;\n    this.constructor = constructor;\n    this.predicate = predicate;\n    this.accessors = accessors;\n    this.mutators = mutators;\n    this.permissions = permissions;\n    this.loc = loc;\n    this.toString = function(){return this.name;};\n    return this;\n  }\n\n  var makeHash = types.makeLowLevelEqHash;\n  plt.compiler.keywords = [\"cond\", \"else\", \"let\", \"case\", \"let*\", \"letrec\", \"quote\",\n                              \"quasiquote\", \"unquote\",\"unquote-splicing\",\"local\",\"begin\",\n                              \"if\",\"or\",\"and\",\"when\",\"unless\",\"lambda\",\"λ\",\"define\",\n                              \"define-struct\", \"define-values\"];\n\n  // ENVIRONMENT STRUCTS ////////////////////////////////////////////////////////////////\n  // Representation of the stack environment of the mzscheme vm, so we know where\n  // things live.\n  function env(bindings){\n    var that = this;\n    this.bindings = bindings || makeHash();\n \n    // lookup : Symbol -> (or/c binding false)\n    this.lookup = function(id){\n      return (this.bindings.containsKey(id))? this.bindings.get(id) : false;\n    };\n \n    // peek: Number -> env\n    this.peek = function(depth){\n      return (depth==0)?                  this\n          :  (this instanceof emptyEnv)?  \"IMPOSSIBLE - peeked at an emptyEnv!\"\n           /* else */                   : this.parent.peek(depth-1);\n    };\n \n    // contains?: symbol -> boolean\n    this.contains = function(name){\n      return this.lookup(name) !== false;\n    };\n \n    // keys : -> (listof symbol)\n    this.keys = this.bindings.keys;\n \n    // extend: binding -> env\n    this.extend = function(binding){\n      this.bindings.put(binding.name, binding);\n      return new plt.compiler.env(this.bindings);\n    };\n \n    // extendFunction : symbol (or/c string false) number boolean? Loc -> env\n    // Extends the environment with a new function binding\n    this.extendFunction = function(id, moduleSource, minArity, isVarArity, loc){\n      return this.extend(new functionBinding(id, moduleSource, minArity, isVarArity, [], false, loc));\n    };\n \n    // extendConstant : string (modulePath || false) Loc -> env\n    this.extendConstant = function(id, moduleSource, loc){\n      return this.extend(new constantBinding(id, moduleSource, [], loc));\n    };\n \n    // lookup_context: identifier -> (binding | false)\n    // Lookup an identifier, taking into account the context of the identifier.  If it has no existing\n    // context, look at the given env. In either case, either return a binding, or false.\n    this.lookup_context = function(id){\n      if(id.context instanceof env){\n        return id.context.contains(id)? id.context.lookup(id) : false;\n      } else {\n        return that.contains(id)? that.lookup(id) : false;\n      }\n    };\n \n    // traverse rthe bindings of the module\n    this.extendEnv_moduleBinding = function(module){\n      return module.bindings.reduceRight(function(env, binding){ return env.extend(binding);}, this);\n    };\n \n    this.toString = function(){\n      return this.bindings.values().reduce(function(s, b){\n        return s+\"\\n  |---\"+b.name;}, \"\");\n    };\n  }\n \n  // sub-classes of env\n  function emptyEnv(){\n    env.call(this);\n    this.lookup = function(name, depth){ return new plt.compiler.unboundStackReference(name); };\n  }\n  emptyEnv.prototype = heir(env.prototype);\n \n  function unnamedEnv(parent){\n    env.call(this);\n    this.parent = parent;\n    this.lookup = function(name, depth){ return this.parent.lookup(name, depth+1); };\n  }\n  unnamedEnv.prototype = heir(env.prototype);\n \n  function localEnv(name, boxed, parent){\n    env.call(this);\n    this.name   = name;\n    this.boxed  = boxed;\n    this.parent = parent;\n    this.lookup = function(name, depth){\n      return (name===this.name)? new plt.compiler.localStackReference(name, this.boxed, depth)\n                              : this.parent.lookup(name, depth+1);\n    };\n  }\n  localEnv.prototype = heir(env.prototype);\n \n  function globalEnv(names, boxed, parent){\n    env.call(this);\n    this.names  = names;\n    this.boxed  = boxed;\n    this.parent = parent;\n    var that = this;\n    this.lookup = function(name, depth){\n      var pos = this.names.indexOf(name);\n      return (pos > -1)? new plt.compiler.globalStackReference(name, depth, pos)\n                  : this.parent.lookup(name, depth+1);\n    };\n  }\n  globalEnv.prototype = heir(env.prototype);\n \n  // PINFO STRUCTS ////////////////////////////////////////////////////////////////\n  var defaultCurrentModulePath = \"\";\n \n  // default-module-resolver: symbol -> (module-binding | false)\n  // loop through known modules and see if we know this name\n  plt.compiler.defaultModuleResolver = function(name){\n    for(var i=0; i<plt.compiler.knownModules.length; i++){\n      if(plt.compiler.knownModules[i].name === name) return plt.compiler.knownModules[i];\n    }\n    return false;\n  }\n \n  // Compute the edit distance between the two given strings\n  // from http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance\n  function levenshteinDistance(a, b) {\n    if(a.length === 0) return b.length; \n    if(b.length === 0) return a.length; \n   \n    var matrix = [];\n   \n    // increment along the first column of each row\n    for(var i = 0; i <= b.length; i++){ matrix[i] = [i]; }\n   \n    // increment each column in the first row\n    for(var j = 0; j <= a.length; j++){ matrix[0][j] = j; }\n   \n    // Fill in the rest of the matrix\n    for(i = 1; i <= b.length; i++){\n      for(j = 1; j <= a.length; j++){\n        if(b.charAt(i-1) == a.charAt(j-1)){\n          matrix[i][j] = matrix[i-1][j-1];\n        } else {\n          matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, // substitution\n                                  Math.min(matrix[i][j-1] + 1, // insertion\n                                           matrix[i-1][j] + 1)); // deletion\n        }\n      }\n    }\n    return matrix[b.length][a.length];\n  };\n \n  // moduleGuess: symbol -> symbol\n  // loop through known modules and make best suggestion for a given name\n  plt.compiler.moduleGuess = function(wrongName){\n    return plt.compiler.knownModules.reduce(function(best, module){\n                                            var dist = levenshteinDistance(module.name, wrongName);\n                                            return (dist < best.distance)? {name: module.name, distance: dist} : best;\n      }, {name: wrongName, distance: 5});\n  }\n \n  // default-module-path-resolver: module-path module-path -> module-name\n  // Provides a default module resolver.\n  plt.compiler.defaultModulePathResolver = function(path, parentPath){\n/*    var name = (path instanceof symbolExpr)? path : modulePathJoin(parentPath, path)),\n        moduleName = knownModules.reduceRight(function(name, km){\n              return (km.source === modulePathJoin(parentPath, path))? km.name : name;}\n                                              , name);\n*/ \n    // anything of the form wescheme/w+, or that has a known collection AND module\n    var parts = path.toString().split(\"/\"),\n        collectionName = parts[0],\n        moduleName = parts.slice(1).join();\n    return ((plt.compiler.knownCollections.indexOf(collectionName) > -1)\n            && plt.compiler.defaultModuleResolver(path.toString()))\n          || /^wescheme\\/\\w+$/.exec(path);\n  }\n \n\n  // pinfo (program-info) is the \"world\" structure for the compilers;\n  // it captures the information we get from analyzing and compiling\n  // the program, and also maintains some auxillary structures.\n  function pinfo(env, modules, usedBindingsHash, freeVariables, gensymCounter,\n                 providedNames,definedNames, sharedExpressions,\n                 withLocationEmits, allowRedefinition,\n                 moduleResolver, modulePathResolver, currentModulePath,\n                 declaredPermissions){\n    this.env = env || new emptyEnv();                       // env\n    this.modules = modules || [];                           // (listof module-binding)\n    this.usedBindingsHash = usedBindingsHash || makeHash(); // (hashof symbol binding)\n    this.freeVariables = freeVariables || [];               // (listof symbol)\n    this.gensymCounter = gensymCounter || 0;                // number\n    this.providedNames = providedNames || makeHash();       // (hashof symbol provide-binding)\n    this.definedNames  = definedNames  || makeHash();       // (hashof symbol binding)\n \n    this.sharedExpressions = sharedExpressions || makeHash();// (hashof expression labeled-translation)\n    // Maintains a mapping between expressions and a labeled translation.  Acts\n    // as a symbol table to avoid duplicate construction of common literal values.\n\n    this.withLocationEmits = withLocationEmits || true;     // boolean\n    // If true, the compiler emits calls to plt.Kernel.setLastLoc to maintain\n    // source position during evaluation.\n\n    this.allowRedefinition = allowRedefinition || false;     // boolean\n    // If true, redefinition of a value that's already defined will not raise an error.\n \n    // For the module system.\n    // (module-name -> (module-binding | false))\n    this.moduleResolver = moduleResolver || plt.compiler.defaultModuleResolver;\n    // (string module-path -> module-name)\n    this.modulePathResolver = modulePathResolver || plt.compiler.defaultModulePathResolver;\n    // module-path\n    this.currentModulePath = currentModulePath || defaultCurrentModulePath;\n \n    this.declaredPermissions = declaredPermissions || [];   // (listof (listof symbol any/c))\n \n    /////////////////////////////////////////////////\n    // functions for manipulating pinfo objects\n    this.isRedefinition = function(name){ return this.env.lookup(name); };\n \n    // usedBindings: -> (listof binding)\n    // Returns the list of used bindings computed from the program analysis.\n    this.usedBindings =  this.usedBindingsHash.values;\n \n    this.accumulateDeclaredPermission = function(name, permission){\n      this.declaredPermissions = [[name, permission]].concat(this.declaredPermissions);\n      return this;\n    };\n \n    this.accumulateSharedExpression = function(expression, translation){\n      var labeledTranslation = makeLabeledTranslation(this.gensymCounter, translation);\n      this.sharedExpressions.put(labeledTranslation, expression);\n      return this;\n    };\n \n    // accumulateDefinedBinding: binding loc -> pinfo\n    // Adds a new defined binding to a pinfo's set.\n    this.accumulateDefinedBinding = function(binding, loc){\n      if(plt.compiler.keywords.indexOf(binding.name) > -1){\n        throwError(new types.Message([new types.ColoredPart(binding.name, binding.loc),\n                                  \": this is a reserved keyword and cannot be used\"+\n                                  \" as a variable or function name\"])\n                   ,binding.loc);\n      } else if(!this.allowRedefinition && this.isRedefinition(binding.name)){\n        var prevBinding = this.env.lookup(binding.name);\n        if(prevBinding.loc){\n          throwError(new types.Message([new types.ColoredPart(binding.name, binding.loc),\n                                    \": this name has a \",\n                                    new types.ColoredPart(\"previous definition\", prevBinding.loc),\n                                    \" and cannot be re-defined\"])\n                     ,binding.loc);\n \n        } else {\n          throwError(new types.Message([new types.ColoredPart(binding.name, binding.loc),\n                                    \": this name has a \",\n                                    \"previous definition\",\n                                    \" and cannot be re-defined\"])\n                     ,binding.loc);\n\n        }\n      } else {\n        this.env.extend(binding);\n        this.definedNames.put(binding.name, binding);\n        return this;\n      }\n    };\n \n    // accumulateBindings: (listof binding) Loc -> pinfo\n    // Adds a list of defined bindings to the pinfo's set.\n    this.accumulateDefinedBindings = function(bindings, loc){\n      var that = this;\n      bindings.forEach(function(b){that.accumulateDefinedBinding(b, loc);});\n      return this;\n    };\n \n \n    // accumuldateModuleBindings: (listof binding) -> pinfo\n    // Adds a list of module-imported bindings to the pinfo's known set of bindings, without\n    // including them within the set of defined names.\n    this.accumulateModuleBindings = function(bindings){\n      var that = this;\n      bindings.forEach(function(b){that.env.extend(b);});\n      return this;\n    };\n   \n    // accumulateModule: module-binding -> pinfo\n    // Adds a module to the pinfo's set.\n    this.accumulateModule = function(module){\n      this.modules = [module].concat(this.modules);\n      return this;\n    };\n\n    // accumulateBindingUse: binding -> pinfo\n    // Adds a binding's use to a pinfo's set, if it has not already been used as a global\n    // This qualifier allows a fn argument to shadow a global, without removing it from the environment\n    this.accumulateBindingUse = function(binding){\n      var alreadyExists = this.usedBindingsHash.get(binding.name);\n      // if it's a module binding, don't replace it with a different kind of binding\n      if(!(alreadyExists && alreadyExists.moduleSource)) this.usedBindingsHash.put(binding.name, binding);\n      return this;\n    };\n   \n    // accumulateFreeVariableUse: symbol -> pinfo\n    // Mark a free variable usage.\n    this.accumulateFreeVariableUse = function(sym){\n      this.freeVariables = ((this.freeVariables.indexOf(sym) > -1)?\n                            this.freeVariables : [sym].concat(this.freeVariables));\n      return this;\n    };\n   \n    // gensym: symbol -> [pinfo, symbol]\n    // Generates a unique symbol\n    this.gensym = function(label){\n      return [this, new symbolExpr(label+this.gensymCounter++)];\n    };\n \n    // permissions: -> (listof permission)\n    // Given a pinfo, collect the list of permissions.\n    this.permissions = function(){\n      // onlyUnique : v, idx, arr -> arr with unique elts\n      // from http://stackoverflow.com/questions/1960473/unique-values-in-an-array\n      function onlyUnique(value, index, self) { return self.indexOf(value) === index; }\n      // if it's a function or constant binding, add its permissions to the list\n      function reducePermissions(permissions, b){\n        return (((b instanceof functionBinding) || (b instanceof constantBinding))\n                && (b.permissions.length > 0))?\n              permissions.concat(b.permissions) : permissions;\n      }\n      return this.usedBindings().reduce(reducePermissions, []).filter(onlyUnique);\n    }\n\n    // getExposedBindings:  -> (listof binding)\n    // Extract the list of the defined bindings that are exposed by provide.\n    this.getExposedBindings = function(){\n      var that = this;\n      // lookupProvideBindingInDefinitionBindings: provide-binding compiled-program -> (listof binding)\n      // Lookup the provided bindings.\n      function lookupProvideBindingInDefinitionBindings(provideBinding){\n        // if it's not defined, throw an error\n        if(!that.definedNames.containsKey(provideBinding.symbl)){\n          throwError(new types.Message([\"provided-name-not-defined: \", provideBinding.symbl]));\n        }\n        // if it IS defined, let's examine it and make sure it is what it claims to be\n        var binding = checkBindingCompatibility(binding, that.definedNames.get(provideBinding.symbl));\n\n        // ref: symbol -> binding\n        // Lookup the binding, given the symbolic identifier.\n        function ref(id){ return that.definedNames.get(id); }\n\n        // if it's a struct provide, return a list containing the constructor and predicate,\n        // along with all the accessor and mutator functions\n        if(provideBinding instanceof plt.compiler.provideBindingStructId){\n          return [ref(binding.constructor), ref(binding.predicate)].concat(\n              binding.accessors.map(ref), binding.mutators.map(ref));\n        } else {\n          return [binding];\n        }\n      }\n \n      // decorateWithPermissions: binding -> binding\n      // THIS IS A HACK according to Danny's original sources...not sure why\n      function decorateWithPermissions(binding){\n        var bindingEntry = function(entry){return entry[0]===binding.name;},\n            filteredPermissions = that.declaredPermissions.filter(bindingEntry);\n        binding.permissions = filteredPermissions.map(function(p){return p[1];});\n        return binding;\n      }\n\n      // Make sure that if the provide says \"struct-out ...\", that the exported binding\n      // is really a structure.\n      function checkBindingCompatibility(binding, exportedBinding){\n        if(  (binding instanceof plt.compiler.provideBindingStructId)\n          && (!(exportedBinding instanceof structBinding))){\n            throwError(new types.Message([\"provided-structure-not-structure: \", exportedBinding.symbl]));\n        } else {\n          return exportedBinding;\n        }\n      }\n \n      // for each provide binding, ensure it's defined and then decorate with permissions\n      // concat all the permissions and bindings together, and return\n      bindings = bindings.reduce(function(acc, b){ return acc.concat(lookupProvideBindingInDefinitionBindings(b)); }, []);\n      return bindings.map(decorateWithPermissions);\n    };\n \n    this.toString = function(){\n       var s = \"pinfo-------------\";\n       s+= \"\\n**env****: \"+this.env.toString();\n       s+= \"\\n**modules**: \"+this.modules.join(\",\");\n       s+= \"\\n**used bindings**: \"+this.usedBindings();\n       s+= \"\\n**free variables**: \"+this.freeVariables.join(\",\");\n       s+= \"\\n**gensym counter**: \"+this.gensymCounter;\n       s+= \"\\n**provided names**: \"+this.providedNames.values();\n       s+= \"\\n**defined names**: \"+this.definedNames.values();\n       s+= \"\\n**permissions**: \"+this.permissions();\n       return s;\n    };\n }\n \n // getBasePinfo: symbol -> pinfo\n // Returns a pinfo that knows the base definitions. Language can be one of the following:\n // 'base\n // 'moby\n function getBasePinfo(language){\n    // fixme: use the language to limit what symbols get in the toplevel.\n    var baseConstantsEnv = [\"null\", \"empty\", \"true\"//effect:do-nothing\n                           , \"false\", \"eof\", \"pi\", \"e\",\"js-undefined\"\n                           , \"js-null\"].reduce(function(env, id){\n                                               return env.extendConstant(id.toString(), '\"moby/toplevel\"', false)\n                                               }, new emptyEnv());\n\n    var pinfo = new plt.compiler.pinfo(),\n        topLevelEnv = plt.compiler.topLevelModules.reduceRight(function(env, mod){\n                                                               return env.extendEnv_moduleBinding(mod);\n                                                               }, baseConstantsEnv);\n    if(language === \"moby\"){\n      pinfo.env = topLevelEnv.extendEnv_moduleBinding(mobyModuleBinding);\n    } else if(language === \"base\"){\n      pinfo.env = topLevelEnv;\n    }\n    return pinfo;\n }\n \n plt.compiler.throwError    = throwError;\n \n plt.compiler.Program       = Program;\n plt.compiler.couple        = couple;\n plt.compiler.defFunc       = defFunc;\n plt.compiler.defVar        = defVar;\n plt.compiler.defVars       = defVars;\n plt.compiler.defStruct     = defStruct;\n plt.compiler.beginExpr     = beginExpr;\n plt.compiler.lambdaExpr    = lambdaExpr;\n plt.compiler.localExpr     = localExpr;\n plt.compiler.letrecExpr    = letrecExpr;\n plt.compiler.letExpr       = letExpr;\n plt.compiler.letStarExpr   = letStarExpr;\n plt.compiler.condExpr      = condExpr;\n plt.compiler.caseExpr      = caseExpr;\n plt.compiler.andExpr       = andExpr;\n plt.compiler.orExpr        = orExpr;\n plt.compiler.callExpr      = callExpr;\n plt.compiler.ifExpr        = ifExpr;\n plt.compiler.whenUnlessExpr= whenUnlessExpr;\n plt.compiler.symbolExpr    = symbolExpr;\n plt.compiler.literal       = literal;\n plt.compiler.quotedExpr    = quotedExpr;\n plt.compiler.unquotedExpr  = unquotedExpr;\n plt.compiler.quasiquotedExpr=quasiquotedExpr;\n plt.compiler.unquoteSplice = unquoteSplice;\n plt.compiler.requireExpr   = requireExpr;\n plt.compiler.provideStatement = provideStatement;\n plt.compiler.unsupportedExpr= unsupportedExpr;\n\n plt.compiler.pinfo       = pinfo;\n plt.compiler.getBasePinfo= getBasePinfo;\n plt.compiler.isExpression= isExpression;\n plt.compiler.isDefinition= isDefinition;\n plt.compiler.env         = env;\n plt.compiler.emptyEnv    = emptyEnv;\n plt.compiler.localEnv    = localEnv;\n plt.compiler.globalEnv   = globalEnv;\n plt.compiler.moduleBinding  = moduleBinding;\n plt.compiler.functionBinding  = functionBinding;\n plt.compiler.constantBinding  = constantBinding;\n plt.compiler.structBinding  = structBinding;\n plt.compiler.unnamedEnv  = unnamedEnv;\n})();\n\nmodule.exports = plt.compiler;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/structures.js\n ** module id = 2\n ** module chunks = 0\n **/","//////////////////////////////////////////////////////////////////////\n// helper functions\n\nvar jsnums = require('./js-numbers');\nvar _Hashtable = require('./jshashtable');\n\nvar types = {};\n\n\n(function () {\n\n//////////////////////////////////////////////////////////////////////\n\n\nvar appendChild = function(parent, child) {\n    parent.appendChild(child);\n};\n\n\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\n//////////////////////////////////////////////////////////////////////\n\n\n\nvar _eqHashCodeCounter = 0;\nvar makeEqHashCode = function() {\n    _eqHashCodeCounter++;\n    return _eqHashCodeCounter;\n};\n\n    \n// getHashCode: any -> (or fixnum string)\n// Produces a hashcode appropriate for eq.\nvar getEqHashCode = function(x) {\n    if (x && !x._eqHashCode) {\n\tx._eqHashCode = makeEqHashCode();\n    }\n    if (x && x._eqHashCode) {\n\treturn x._eqHashCode;\n    }\n    if (typeof(x) == 'string') {\n\treturn x;\n    }\n    return 0;\n};\n\n\n// Union/find for circular equality testing.\n\nvar UnionFind = function() {\n\t// this.parenMap holds the arrows from an arbitrary pointer\n\t// to its parent.\n\tthis.parentMap = makeLowLevelEqHash();\n}\n\n// find: ptr -> UnionFindNode\n// Returns the representative for this ptr.\nUnionFind.prototype.find = function(ptr) {\n\tvar parent = (this.parentMap.containsKey(ptr) ? \n\t\t      this.parentMap.get(ptr) : ptr);\n\tif (parent === ptr) {\n\t    return parent;\n\t} else {\n\t    var rep = this.find(parent);\n\t    // Path compression:\n\t    this.parentMap.put(ptr, rep);\n\t    return rep;\n\t}\n};\n\n// merge: ptr ptr -> void\n// Merge the representative nodes for ptr1 and ptr2.\nUnionFind.prototype.merge = function(ptr1, ptr2) {\n\tthis.parentMap.put(this.find(ptr1), this.find(ptr2));\n};\n\n\n\n//////////////////////////////////////////////////////////////////////\n\n// Class inheritance infrastructure\n\n// This code copied directly from http://ejohn.org/blog/simple-javascript-inheritance/\nvar Class = (function(){\n\tvar initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\\b_super\\b/ : /.*/;\n\t// The base Class implementation (does nothing)\n\tvar innerClass = function(){};\n\t\n\t// Create a new Class that inherits from this class\n\tinnerClass.extend = function(prop) {\n\t\tvar _super = this.prototype;\n\t\t\n\t\t// Instantiate a base class (but only create the instance,\n\t\t// don't run the init constructor)\n\t\tinitializing = true;\n\t\tvar prototype = new this();\n\t\tinitializing = false;\n\t\t\n\t\t// Copy the properties over onto the new prototype\n\t\tfor (var name in prop) {\n\t\t\t// Check if we're overwriting an existing function\n\t\t\tprototype[name] = typeof prop[name] == \"function\" && \n\t\t\t\ttypeof _super[name] == \"function\" && fnTest.test(prop[name]) ?\n\t\t\t\t(function(name, fn){\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tvar tmp = this._super;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Add a new ._super() method that is the same method\n\t\t\t\t\t\t// but on the super-class\n\t\t\t\t\t\tthis._super = _super[name];\n\t\t\t\t\t\t\n\t\t\t\t\t\t// The method only need to be bound temporarily, so we\n\t\t\t\t\t\t// remove it when we're done executing\n\t\t\t\t\t\tvar ret = fn.apply(this, arguments);\t\t\t\t\n\t\t\t\t\t\tthis._super = tmp;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t};\n\t\t\t\t})(name, prop[name]) :\n\t\t\t\tprop[name];\n\t\t}\n\t\t\n\t\t// The dummy class constructor\n\t\tvar Dummy = function() {\n\t\t\t// All construction is actually done in the init method\n\t\t\tif ( !initializing && this.init )\n\t\t\t\tthis.init.apply(this, arguments);\n\t\t}\n\t\t\n\t\t// Populate our constructed prototype object\n\t\tDummy.prototype = prototype;\n\t\t\n\t\t// Enforce the constructor to be what we expect\n\t\tDummy.constructor = Dummy;\n\n\t\t// And make this class extendable\n\t\tDummy.extend = arguments.callee;\n\t\t\n\t\treturn Dummy;\n\t};\n\treturn innerClass;\n})();\n \nfunction makeLParen(){\n   var node = document.createElement('span');\n   node.appendChild(document.createTextNode(\"(\"));\n   node.className = \"lParen\";\n   return node;\n}\n\nfunction makeRParen(){\n   var node = document.createElement('span');\n   node.appendChild(document.createTextNode(\")\"));\n   node.className = \"rParen\";\n   return node;\n}\n\n//////////////////////////////////////////////////////////////////////\n\n\nvar StructType = function(name, type, numberOfArgs, numberOfFields, firstField,\n\t\t      constructor, predicate, accessor, mutator) {\n\tthis.name = name;\n\tthis.type = type;\n\tthis.numberOfArgs = numberOfArgs;\n\tthis.numberOfFields = numberOfFields;\n\tthis.firstField = firstField;\n\n\tthis.constructor = constructor;\n\tthis.predicate = predicate;\n\tthis.accessor = accessor;\n\tthis.mutator = mutator;\n};\n\nStructType.prototype.toString = function() {\n\treturn '#<struct-type:' + this.name + '>';\n};\n\nStructType.prototype.isEqual = function(other, aUnionFind) {\n\treturn this === other;\n};\n\n\nvar makeStructureType = function(theName, parentType, initFieldCnt, autoFieldCnt, autoV, guard) {\n    // If no parent type given, then the parent type is Struct\n    if ( !parentType ) {\n\tparentType = ({type: Struct,\n\t\t       numberOfArgs: 0,\n\t\t       numberOfFields: 0,\n\t\t       firstField: 0});\n    }\n    var numParentArgs = parentType.numberOfArgs;\n\n    // Create a new struct type inheriting from the parent\n    var aStruct = parentType.type.extend({\n\tinit: function(name, initArgs) {\n\t\t// if there's no guard, construct a default one\n\n\t\tif (!guard) {\n\t\t\tguard = function(k) {\n\t\t\t\tif (arguments.length == 3) {\n\t\t\t\t\tk(arguments[1]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar args = [];\n\t\t\t\t\tvar i;\n\t\t\t\t\tfor(i = 1; i < arguments.length-1; i++) {\n\t\t\t\t\t\targs.push(arguments[i]);\n\t\t\t\t\t}\n\t\t\t\t\tk(new ValuesWrapper(args));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar that = this;\n\t\tvar cont = function(guardRes) {\n\t\t\tvar guardedArgs;\n\t\t\tif ( guardRes instanceof ValuesWrapper ) {\n\t\t\t\tguardedArgs = guardRes.elts;\n\t\t\t} else {\n\t\t\t\tguardedArgs = [guardRes];\n\t\t\t}\n\t\t\t\n\t\t\tvar parentArgs = guardedArgs.slice(0, numParentArgs);\n\t\t\tthat._super(name, parentArgs);\n\n\t\t\tfor (var i = 0; i < initFieldCnt; i++) {\n\t\t\t\tthat._fields.push(guardedArgs[i+numParentArgs]);\n\t\t\t}\n\t\t\tfor (var i = 0; i < autoFieldCnt; i++) {\n\t\t\t\tthat._fields.push(autoV);\n\t\t\t}\n\t\t};\n\t\tinitArgs.unshift(cont);\n\t\tinitArgs.push(Symbol.makeInstance(name));\n\t\tguard.apply(null, initArgs);\n\t}\n    });\n    // Set type, necessary for equality checking\n    aStruct.prototype.type = aStruct;\n\n    // construct and return the new type\n    return new StructType(theName,\n\t\t\t  aStruct,\n\t\t\t  initFieldCnt + numParentArgs,\n\t\t\t  initFieldCnt + autoFieldCnt,\n\t\t\t  parentType.firstField + parentType.numberOfFields,\n\t\t\t  function() {\n\t\t\t  \tvar args = [];\n\t\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\t\targs.push(arguments[i]);\n\t\t\t\t}\n\t\t\t\treturn new aStruct(theName, args);\n\t\t\t  },\n\t\t\t  function(x) { return x instanceof aStruct; },\n\t\t\t  function(x, i) { return x._fields[i + this.firstField]; },\n\t\t\t  function(x, i, v) { x._fields[i + this.firstField] = v; });\n};\n\n// Structures.\nvar Struct = Class.extend({\n\tinit: function (constructorName, fields) {\n\t    this._constructorName = constructorName; \n\t    this._fields = [];\n\t},\n\n\ttoWrittenString: function(cache) { \n\t    //    cache.put(this, true);\n\t    var buffer = [];\n\t    var i;\n\t    buffer.push(\"(\");\n\t    buffer.push(this._constructorName);\n\t    for(i = 0; i < this._fields.length; i++) {\n\t\tbuffer.push(\" \");\n\t\tbuffer.push(toWrittenString(this._fields[i], cache));\n\t    }\n\t    buffer.push(\")\");\n\t    return buffer.join(\"\");\n\t},\n\n\ttoDisplayedString: function(cache) { return this.toWrittenString(cache); },\n\n\ttoDomNode: function(cache) {\n\t    //    cache.put(this, true);\n\t    var node = document.createElement(\"div\"),\n            constructor= document.createElement(\"span\");\n            constructor.appendChild(document.createTextNode(this._constructorName));\n\t    var i;\n\t    node.appendChild(makeLParen());\n\t    node.appendChild(constructor);\n\t    for(i = 0; i < this._fields.length; i++) {\n                appendChild(node, toDomNode(this._fields[i], cache));\n\t    }\n\t    node.appendChild(makeRParen());\n\t    return node;\n\t},\n\n\n\tisEqual: function(other, aUnionFind) {\n\t    if ( other.type == undefined ||\n\t\t this.type !== other.type ||\n\t\t !(other instanceof this.type) ) {\n\t\t    return false;\n\t    }\n\n\t    for (var i = 0; i < this._fields.length; i++) {\n\t\tif (! isEqual(this._fields[i],\n\t\t\t      other._fields[i],\n\t\t\t      aUnionFind)) {\n\t\t\treturn false;\n\t\t}\n\t    }\n\t    return true;\n\t}\n});\nStruct.prototype.type = Struct;\n\n\n\n//////////////////////////////////////////////////////////////////////\n\n// Regular expressions.\n\nvar RegularExpression = function(pattern) {\n    this.pattern = pattern;\n};\n\n\nvar ByteRegularExpression = function(pattern) {\n    this.pattern = pattern;\n};\n\n\n\n\n//////////////////////////////////////////////////////////////////////\n\n// Paths\n\nvar Path = function(p) {\n    this.path = p;\n};\n\n\n//////////////////////////////////////////////////////////////////////\n\n// Bytes\n\nvar Bytes = function(bts, mutable) {\n    this.bytes = bts;\n    this.mutable = (mutable === undefined) ? false : mutable;\n};\n\nBytes.prototype.get = function(i) {\n\treturn this.bytes[i];\n};\n\nBytes.prototype.set = function(i, b) {\n\tif (this.mutable) {\n\t\tthis.bytes[i] = b;\n\t}\n};\n\nBytes.prototype.length = function() {\n\treturn this.bytes.length;\n};\n\nBytes.prototype.copy = function(mutable) {\n\treturn new Bytes(this.bytes.slice(0), mutable);\n};\n\nBytes.prototype.subbytes = function(start, end) {\n\tif (end == null || end == undefined) {\n\t\tend = this.bytes.length;\n\t}\n\t\n\treturn new Bytes( this.bytes.slice(start, end), true );\n};\n\n\nBytes.prototype.toString = function() {\n\tvar ret = '';\n\tfor (var i = 0; i < this.bytes.length; i++) {\n\t\tret += String.fromCharCode(this.bytes[i]);\n\t}\n\n\treturn ret;\n};\n\nBytes.prototype.toDisplayedString = Bytes.prototype.toString;\n\nBytes.prototype.toWrittenString = function() {\n\tvar ret = ['#\"'];\n\tfor (var i = 0; i < this.bytes.length; i++) {\n\t\tret.push( escapeByte(this.bytes[i]) );\n\t}\n\tret.push('\"');\n\treturn ret.join('');\n};\n\nvar escapeByte = function(aByte) {\n\tvar ret = [];\n\tvar returnVal;\n\tswitch(aByte) {\n\t\tcase 7: returnVal = '\\\\a'; break;\n\t\tcase 8: returnVal = '\\\\b'; break;\n\t\tcase 9: returnVal = '\\\\t'; break;\n\t\tcase 10: returnVal = '\\\\n'; break;\n\t\tcase 11: returnVal = '\\\\v'; break;\n\t\tcase 12: returnVal = '\\\\f'; break;\n\t\tcase 13: returnVal = '\\\\r'; break;\n\t\tcase 34: returnVal = '\\\\\"'; break;\n\t\tcase 92: returnVal = '\\\\\\\\'; break;\n\t\tdefault: if (val >= 32 && val <= 126) {\n\t\t\t\t returnVal = String.fromCharCode(val);\n\t\t\t }\n\t\t\t else {\n\t\t\t\t ret.push( '\\\\' + val.toString(8) );\n\t\t\t }\n\t\t\t break;\n\t}\n\treturn returnVal;\n};\n\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Boxes\n    \nvar Box = function(x, mutable) {\n\tthis.val = x;\n\tthis.mutable = mutable;\n};\n\nBox.prototype.unbox = function() {\n    return this.val;\n};\n\nBox.prototype.set = function(newVal) {\n    if (this.mutable) {\n\t    this.val = newVal;\n    }\n};\n\nBox.prototype.toString = function() {\n    return \"#&\" + this.val.toString();\n};\n\nBox.prototype.toWrittenString = function(cache) {\n    return \"#&\" + toWrittenString(this.val, cache);\n};\n\nBox.prototype.toDisplayedString = function(cache) {\n    return \"#&\" + toDisplayedString(this.val, cache);\n};\n\nBox.prototype.toDomNode = function(cache) {\n    var parent = document.createElement(\"span\"),\n    boxSymbol = document.createElement(\"span\");\n    boxSymbol.appendChild(document.createTextNode(\"#&\"));\n    parent.className = \"wescheme-box\";\n    parent.appendChild(boxSymbol);\n    parent.appendChild(toDomNode(this.val, cache));\n    return parent;\n};\n\n//////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n// We are reusing the built-in Javascript boolean class here.\nLogic = {\n    TRUE : true,\n    FALSE : false\n};\n\n// WARNING\n// WARNING: we are extending the built-in Javascript boolean class here!\n// WARNING\nBoolean.prototype.toWrittenString = function(cache) {\n    if (this.valueOf()) { return \"true\"; }\n    return \"false\";\n};\nBoolean.prototype.toDisplayedString = Boolean.prototype.toWrittenString;\n\nBoolean.prototype.toString = function() { return this.valueOf() ? \"true\" : \"false\"; };\n\nBoolean.prototype.isEqual = function(other, aUnionFind){\n    return this == other;\n};\n\n\n\n\n// Chars\n// Char: string -> Char\nChar = function(val){\n    this.val = val;\n};\n    \nChar.makeInstance = function(val){\n    return new Char(val);\n};\n\nChar.prototype.toString = function() {\n\tvar code = this.val.charCodeAt(0);\n\tvar returnVal;\n\tswitch (code) {\n\t\tcase 0: returnVal = '#\\\\nul'; break;\n\t\tcase 8: returnVal = '#\\\\backspace'; break;\n\t\tcase 9: returnVal = '#\\\\tab'; break;\n\t\tcase 10: returnVal = '#\\\\newline'; break;\n\t\tcase 11: returnVal = '#\\\\vtab'; break;\n\t\tcase 12: returnVal = '#\\\\page'; break;\n\t\tcase 13: returnVal = '#\\\\return'; break;\n\t\tcase 20: returnVal = '#\\\\space'; break;\n\t\tcase 127: returnVal = '#\\\\rubout'; break;\n\t\tdefault: if (code >= 32 && code <= 126) {\n\t\t\t\t returnVal = (\"#\\\\\" + this.val);\n\t\t\t }\n\t\t\t else {\n\t\t\t\t var numStr = code.toString(16).toUpperCase();\n\t\t\t\t while (numStr.length < 4) {\n\t\t\t\t\t numStr = '0' + numStr;\n\t\t\t\t }\n\t\t\t\t returnVal = ('#\\\\u' + numStr);\n\t\t\t }\n\t\t\t break;\n\t}\n\treturn returnVal;\n};\n\nChar.prototype.toWrittenString = Char.prototype.toString;\n\nChar.prototype.toDisplayedString = function (cache) {\n    return this.val;\n};\n\nChar.prototype.getValue = function() {\n    return this.val;\n};\n\nChar.prototype.isEqual = function(other, aUnionFind){\n    return other instanceof Char && this.val == other.val;\n};\n\n//////////////////////////////////////////////////////////////////////\n    \n// Symbols\n\n//////////////////////////////////////////////////////////////////////\nvar Symbol = function(val) {\n    this.val = val;\n};\n\nvar symbolCache = {};\n    \n// makeInstance: string -> Symbol.\nSymbol.makeInstance = function(val) {\n    // To ensure that we can eq? symbols with equal values.\n    if (!(hasOwnProperty.call(symbolCache, val))) {\n\tsymbolCache[val] = new Symbol(val);\n    }\n    return symbolCache[val];\n};\n    \nSymbol.prototype.isEqual = function(other, aUnionFind) {\n    return other instanceof Symbol &&\n    this.val == other.val;\n};\n    \n\nSymbol.prototype.toString = function() {\n    return this.val;\n};\n\nSymbol.prototype.toWrittenString = function(cache) {\n    return this.val;\n};\n\nSymbol.prototype.toDisplayedString = function(cache) {\n    return this.val;\n};\n\nSymbol.prototype.toDomNode = function(cache) {\n    var wrapper = document.createElement(\"span\");\n    wrapper.className = \"wescheme-symbol\";\n    wrapper.style.fontFamily = 'monospace';\n    wrapper.style.whiteSpace = \"pre\";\n    wrapper.appendChild(document.createTextNode(\"'\" + this.val));\n    return wrapper;\n};\n\n\n\n//////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n// Keywords\n\nvar Keyword = function(val) {\n    this.val = val;\n};\n\nvar keywordCache = {};\n    \n\n// makeInstance: string -> Keyword.\nKeyword.makeInstance = function(val) {\n    // To ensure that we can eq? symbols with equal values.\n    if (!(hasOwnProperty.call(keywordCache, val))) {\n\tkeywordCache[val] = new Keyword(val);\n    }\n    return keywordCache[val];\n};\n    \nKeyword.prototype.isEqual = function(other, aUnionFind) {\n    return other instanceof Keyword &&\n    this.val == other.val;\n};\n    \n\nKeyword.prototype.toString = function() {\n    return this.val;\n};\n\nKeyword.prototype.toWrittenString = function(cache) {\n    return this.val;\n};\n\nKeyword.prototype.toDisplayedString = function(cache) {\n    return this.val;\n};\n\n\n//////////////////////////////////////////////////////////////////////\n\n\n    \n    \n    \nEmpty = function() {\n};\nEmpty.EMPTY = new Empty();\n\n\nEmpty.prototype.isEqual = function(other, aUnionFind) {\n    return other instanceof Empty;\n};\n\nEmpty.prototype.reverse = function() {\n    return this;\n};\n\nEmpty.prototype.first = function() {\n    throw new Error(\"first can't be applied on empty.\");\n};\nEmpty.prototype.rest = function() {\n    throw new Error(\"rest can't be applied on empty.\");\n};\nEmpty.prototype.isEmpty = function() {\n    return true;\n};\nEmpty.prototype.toWrittenString = function(cache) { return \"empty\"; };\nEmpty.prototype.toDisplayedString = function(cache) { return \"empty\"; };\nEmpty.prototype.toString = function(cache) { return \"()\"; };\n\n\n    \n// Empty.append: (listof X) -> (listof X)\nEmpty.prototype.append = function(b){\n    return b;\n};\n    \nCons = function(f, r) {\n    this.f = f;\n    this.r = r;\n};\n\nCons.prototype.reverse = function() {\n    var lst = this;\n    var ret = Empty.EMPTY;\n    while (!lst.isEmpty()){\n\tret = Cons.makeInstance(lst.first(), ret);\n\tlst = lst.rest();\n    }\n    return ret;\n};\n    \nCons.makeInstance = function(f, r) {\n    return new Cons(f, r);\n};\n\n\n// FIXME: can we reduce the recursion on this?\nCons.prototype.isEqual = function(other, aUnionFind) {\n    if (! (other instanceof Cons)) {\n\treturn Logic.FALSE;\n    }\n    return (isEqual(this.first(), other.first(), aUnionFind) &&\n\t    isEqual(this.rest(), other.rest(), aUnionFind));\n};\n    \nCons.prototype.first = function() {\n    return this.f;\n};\n    \nCons.prototype.rest = function() {\n    return this.r;\n};\n    \nCons.prototype.isEmpty = function() {\n    return false;\n};\n    \n// Cons.append: (listof X) -> (listof X)\nCons.prototype.append = function(b){\n    if (b === Empty.EMPTY)\n\treturn this;\n    var ret = b;\n    var lst = this.reverse();\n    while ( !lst.isEmpty() ) {\n\tret = Cons.makeInstance(lst.first(), ret);\n\tlst = lst.rest();\n    }\n\t\n    return ret;\n};\n    \n\nCons.prototype.toWrittenString = function(cache) {\n    //    cache.put(this, true);\n    var texts = [\"list\"];\n    var p = this;\n    while ( p instanceof Cons ) {\n\ttexts.push(toWrittenString(p.first(), cache));\n\tp = p.rest();\n    }\n    if ( p !== Empty.EMPTY ) {\n\t// If not a list, we've got to switch over to cons pair\n\t// representation.\n\treturn explicitConsString(this, cache, toWrittenString);\n    }\n    return \"(\" + texts.join(\" \") + \")\";\n};\n\nvar explicitConsString = function(p, cache, f) {\n    var texts = [];\n    var tails = []\n    while ( p instanceof Cons ) {\n\ttexts.push(\"(cons \");\n\ttexts.push(f(p.first(), cache));\n\ttexts.push(\" \");\n\n\ttails.push(\")\");\n\tp = p.rest();\n    }\n    texts.push(f(p, cache));\n    return (texts.join(\"\") + tails.join(\"\"));\n};\n\n\nCons.prototype.toString = Cons.prototype.toWrittenString;\n\nCons.prototype.toDisplayedString = function(cache) {\n    //    cache.put(this, true);\n    var texts = [\"list\"];\n    var p = this;\n    while ( p instanceof Cons ) {\n\ttexts.push(toDisplayedString(p.first(), cache));\n\tp = p.rest();\n    }\n    if ( p !== Empty.EMPTY ) {\n\treturn explicitConsString(this, cache, toDisplayedString);\n    }\n//    while (true) {\n//\tif ((!(p instanceof Cons)) && (!(p instanceof Empty))) {\n//\t    texts.push(\".\");\n//\t    texts.push(toDisplayedString(p, cache));\n//\t    break;\n//\t}\n//\tif (p.isEmpty()) \n//\t    break;\n//\ttexts.push(toDisplayedString(p.first(), cache));\n//\tp = p.rest();\n//    }\n    return \"(\" + texts.join(\" \") + \")\";\n};\n\n\n\nCons.prototype.toDomNode = function(cache) {\n    //    cache.put(this, true);\n    var node = document.createElement(\"span\"),\n        abbr = document.createElement(\"span\");\n    node.className = \"wescheme-cons\";\n    abbr.appendChild(document.createTextNode(\"list\"));\n \n     node.appendChild(makeLParen());\n     node.appendChild(abbr);\n    var p = this;\n    while ( p instanceof Cons ) {\n      appendChild(node, toDomNode(p.first(), cache));\n      p = p.rest();\n    }\n    if ( p !== Empty.EMPTY ) {\n\treturn explicitConsDomNode(this, cache);\n    }\n node.appendChild(makeRParen());\n    return node;\n};\n\nvar explicitConsDomNode = function(p, cache) {\n    var topNode = document.createElement(\"span\");\n    var node = topNode, constructor = document.createElement(\"span\");\n       constructor.appendChild(document.createTextNode(\"cons\"));\n\n    node.className = \"wescheme-cons\";\n    while ( p instanceof Cons ) {\n      node.appendChild(makeLParen());\n      node.appendChild(constructor);\n      appendChild(node, toDomNode(p.first(), cache));\n\n      var restSpan = document.createElement(\"span\");\n      node.appendChild(restSpan);\n      node.appendChild(makeRParen());\n      node = restSpan;\n      p = p.rest();\n    }\n    appendChild(node, toDomNode(p, cache));\n    return topNode;\n};\n\n\n\n//////////////////////////////////////////////////////////////////////\n\nVector = function(n, initialElements) {\n    this.elts = new Array(n);\n    if (initialElements) {\n\tfor (var i = 0; i < n; i++) {\n\t    this.elts[i] = initialElements[i];\n\t}\n    } else {\n\tfor (var i = 0; i < n; i++) {\n\t    this.elts[i] = undefined;\n\t}\n    }\n    this.mutable = true;\n};\nVector.makeInstance = function(n, elts) {\n    return new Vector(n, elts);\n}\n    Vector.prototype.length = function() {\n\treturn this.elts.length;\n    };\nVector.prototype.ref = function(k) {\n    return this.elts[k];\n};\nVector.prototype.set = function(k, v) {\n    this.elts[k] = v;\n};\n\nVector.prototype.isEqual = function(other, aUnionFind) {\n    if (other != null && other != undefined && other instanceof Vector) {\n\tif (other.length() != this.length()) {\n\t    return false\n\t}\n\tfor (var i = 0; i <  this.length(); i++) {\n\t    if (! isEqual(this.elts[i], other.elts[i], aUnionFind)) {\n\t\treturn false;\n\t    }\n\t}\n\treturn true;\n    } else {\n\treturn false;\n    }\n};\n\nVector.prototype.toList = function() {\n    var ret = Empty.EMPTY;\n    for (var i = this.length() - 1; i >= 0; i--) {\n\tret = Cons.makeInstance(this.elts[i], ret);\t    \n    }\t\n    return ret;\n};\n\nVector.prototype.toWrittenString = function(cache) {\n    //    cache.put(this, true);\n    var texts = [];\n    for (var i = 0; i < this.length(); i++) {\n\ttexts.push(toWrittenString(this.ref(i), cache));\n    }\n    return \"#(\" + texts.join(\" \") + \")\";\n};\n\nVector.prototype.toDisplayedString = function(cache) {\n    //    cache.put(this, true);\n    var texts = [];\n    for (var i = 0; i < this.length(); i++) {\n\ttexts.push(toDisplayedString(this.ref(i), cache));\n    }\n    return \"#(\" + texts.join(\" \") + \")\";\n};\n\nVector.prototype.toDomNode = function(cache) {\n    //    cache.put(this, true);\n    var node = document.createElement(\"span\"),\n        lVect = document.createElement(\"span\"),\n        rVect = document.createElement(\"span\");\n    lVect.appendChild(document.createTextNode(\"#(\"));\n    lVect.className = \"lParen\";\n    rVect.appendChild(document.createTextNode(\")\"));\n    rVect.className = \"rParen\";\n    node.className = \"wescheme-vector\";\n    node.appendChild(lVect);\n    for (var i = 0; i < this.length(); i++) {\n      appendChild(node, toDomNode(this.ref(i), cache));\n    }\n    node.appendChild(rVect);\n    return node;\n};\n\n\n//////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n// Now using mutable strings\nvar Str = function(chars) {\n\tthis.chars = chars;\n\tthis.length = chars.length;\n\tthis.mutable = true;\n}\n\nStr.makeInstance = function(chars) {\n\treturn new Str(chars);\n}\n\nStr.fromString = function(s) {\n\treturn Str.makeInstance(s.split(\"\"));\n}\n\nStr.prototype.toString = function() {\n\treturn this.chars.join(\"\");\n}\n\nStr.prototype.toWrittenString = function(cache) {\n    return escapeString(this.toString());\n}\n\nStr.prototype.toDisplayedString = Str.prototype.toString;\n\nStr.prototype.copy = function() {\n\treturn Str.makeInstance(this.chars.slice(0));\n}\n\nStr.prototype.substring = function(start, end) {\n\tif (end == null || end == undefined) {\n\t\tend = this.length;\n\t}\n\t\n\treturn Str.makeInstance( this.chars.slice(start, end) );\n}\n\nStr.prototype.charAt = function(index) {\n\treturn this.chars[index];\n}\n\nStr.prototype.charCodeAt = function(index) {\n\treturn this.chars[index].charCodeAt(0);\n}\n\nStr.prototype.replace = function(expr, newStr) {\n\treturn Str.fromString( this.toString().replace(expr, newStr) );\n}\n\n\nStr.prototype.isEqual = function(other, aUnionFind) {\n\tif ( !(other instanceof Str || typeof(other) == 'string') ) {\n\t\treturn false;\n\t}\n\treturn this.toString() === other.toString();\n}\n\n\nStr.prototype.set = function(i, c) {\n\tthis.chars[i] = c;\n}\n\nStr.prototype.toUpperCase = function() {\n\treturn Str.fromString( this.chars.join(\"\").toUpperCase() );\n}\n\nStr.prototype.toLowerCase = function() {\n\treturn Str.fromString( this.chars.join(\"\").toLowerCase() );\n}\n\nStr.prototype.match = function(regexpr) {\n\treturn this.toString().match(regexpr);\n}\n\n\n//var _quoteReplacingRegexp = new RegExp(\"[\\\"\\\\\\\\]\", \"g\");\nvar escapeString = function(s) {\n    return '\"' + replaceUnprintableStringChars(s) + '\"';\n//    return '\"' + s.replace(_quoteReplacingRegexp,\n//\t\t\t      function(match, submatch, index) {\n//\t\t\t\t  return \"\\\\\" + match;\n//\t\t\t      }) + '\"';\n};\n\nvar replaceUnprintableStringChars = function(s) {\n\tvar ret = [];\n\tfor (var i = 0; i < s.length; i++) {\n\t\tvar val = s.charCodeAt(i);\n\t\tswitch(val) {\n\t\t\tcase 7: ret.push('\\\\a'); break;\n\t\t\tcase 8: ret.push('\\\\b'); break;\n\t\t\tcase 9: ret.push('\\\\t'); break;\n\t\t\tcase 10: ret.push('\\\\n'); break;\n\t\t\tcase 11: ret.push('\\\\v'); break;\n\t\t\tcase 12: ret.push('\\\\f'); break;\n\t\t\tcase 13: ret.push('\\\\r'); break;\n\t\t\tcase 34: ret.push('\\\\\"'); break;\n\t\t\tcase 92: ret.push('\\\\\\\\'); break;\n\t\t\tdefault: if (val >= 32 && val <= 126) {\n\t\t\t\t\t ret.push( s.charAt(i) );\n\t\t\t\t }\n\t\t\t\t else {\n\t\t\t\t\t var numStr = val.toString(16).toUpperCase();\n\t\t\t\t\t while (numStr.length < 4) {\n\t\t\t\t\t\t numStr = '0' + numStr;\n\t\t\t\t\t }\n\t\t\t\t\t ret.push('\\\\u' + numStr);\n\t\t\t\t }\n\t\t\t\t break;\n\t\t}\n\t}\n\treturn ret.join('');\n};\n\n\n/*\n// Strings\n// For the moment, we just reuse Javascript strings.\nString = String;\nString.makeInstance = function(s) {\n    return s.valueOf();\n};\n    \n    \n// WARNING\n// WARNING: we are extending the built-in Javascript string class here!\n// WARNING\nString.prototype.isEqual = function(other, aUnionFind){\n    return this == other;\n};\n    \nvar _quoteReplacingRegexp = new RegExp(\"[\\\"\\\\\\\\]\", \"g\");\nString.prototype.toWrittenString = function(cache) {\n    return '\"' + this.replace(_quoteReplacingRegexp,\n\t\t\t      function(match, submatch, index) {\n\t\t\t\t  return \"\\\\\" + match;\n\t\t\t      }) + '\"';\n};\n\nString.prototype.toDisplayedString = function(cache) {\n    return this;\n};\n*/\n\n\n//////////////////////////////////////////////////////////////////////\n\n// makeLowLevelEqHash: -> hashtable\n// Constructs an eq hashtable that uses Moby's getEqHashCode function.\nvar makeLowLevelEqHash = function() {\n    return new _Hashtable(function(x) { return getEqHashCode(x); },\n\t\t\t  function(x, y) { return x === y; });\n};\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Hashtables\nvar EqHashTable = function(inputHash) {\n    this.hash = makeLowLevelEqHash();\n    this.mutable = true;\n\n};\nEqHashTable = EqHashTable;\n\nEqHashTable.prototype.toWrittenString = function(cache) {\n    var keys = this.hash.keys();\n    var ret = [];\n    for (var i = 0; i < keys.length; i++) {\n\t    var keyStr = types.toWrittenString(keys[i], cache);\n\t    var valStr = types.toWrittenString(this.hash.get(keys[i]), cache);\n\t    ret.push('(' + keyStr + ' . ' + valStr + ')');\n    }\n    return ('#hasheq(' + ret.join(' ') + ')');\n};\n\nEqHashTable.prototype.toDisplayedString = function(cache) {\n    var keys = this.hash.keys();\n    var ret = [];\n    for (var i = 0; i < keys.length; i++) {\n\t    var keyStr = types.toDisplayedString(keys[i], cache);\n\t    var valStr = types.toDisplayedString(this.hash.get(keys[i]), cache);\n\t    ret.push('(' + keyStr + ' . ' + valStr + ')');\n    }\n    return ('#hasheq(' + ret.join(' ') + ')');\n};\n\nEqHashTable.prototype.isEqual = function(other, aUnionFind) {\n    if ( !(other instanceof EqHashTable) ) {\n\treturn false; \n    }\n\n    if (this.hash.keys().length != other.hash.keys().length) { \n\treturn false;\n    }\n\n    var keys = this.hash.keys();\n    for (var i = 0; i < keys.length; i++){\n\tif ( !(other.hash.containsKey(keys[i]) &&\n\t       isEqual(this.hash.get(keys[i]),\n\t\t       other.hash.get(keys[i]),\n\t\t       aUnionFind)) ) {\n\t\treturn false;\n\t}\n    }\n    return true;\n};\n\n\n\nvar EqualHashTable = function(inputHash) {\n\tthis.hash = new _Hashtable(function(x) {\n\t\t\treturn toWrittenString(x); \n\t\t},\n\t\tfunction(x, y) {\n\t\t\treturn isEqual(x, y, new UnionFind()); \n\t\t});\n\tthis.mutable = true;\n};\n\nEqualHashTable = EqualHashTable;\n\nEqualHashTable.prototype.toWrittenString = function(cache) {\n    var keys = this.hash.keys();\n    var ret = [];\n    for (var i = 0; i < keys.length; i++) {\n\t    var keyStr = types.toWrittenString(keys[i], cache);\n\t    var valStr = types.toWrittenString(this.hash.get(keys[i]), cache);\n\t    ret.push('(' + keyStr + ' . ' + valStr + ')');\n    }\n    return ('#hash(' + ret.join(' ') + ')');\n};\nEqualHashTable.prototype.toDisplayedString = function(cache) {\n    var keys = this.hash.keys();\n    var ret = [];\n    for (var i = 0; i < keys.length; i++) {\n\t    var keyStr = types.toDisplayedString(keys[i], cache);\n\t    var valStr = types.toDisplayedString(this.hash.get(keys[i]), cache);\n\t    ret.push('(' + keyStr + ' . ' + valStr + ')');\n    }\n    return ('#hash(' + ret.join(' ') + ')');\n};\n\nEqualHashTable.prototype.isEqual = function(other, aUnionFind) {\n    if ( !(other instanceof EqualHashTable) ) {\n\treturn false; \n    }\n\n    if (this.hash.keys().length != other.hash.keys().length) { \n\treturn false;\n    }\n\n    var keys = this.hash.keys();\n    for (var i = 0; i < keys.length; i++){\n\tif (! (other.hash.containsKey(keys[i]) &&\n\t       isEqual(this.hash.get(keys[i]),\n\t\t       other.hash.get(keys[i]),\n\t\t       aUnionFind))) {\n\t    return false;\n\t}\n    }\n    return true;\n};\n\n\n//////////////////////////////////////////////////////////////////////\n\nvar JsObject = function(name, obj) {\n\tthis.name = name;\n\tthis.obj = obj;\n};\n\nJsObject.prototype.toString = function() {\n\treturn '#<js-object:' + typeof(this.obj) + ':' + this.name + '>';\n};\n\nJsObject.prototype.isEqual = function(other, aUnionFind) {\n\treturn (this.obj === other.obj);\n};\n\n//////////////////////////////////////////////////////////////////////\n\nvar WorldConfig = function(startup, shutdown, args) {\n\tthis.startup = startup;\n\tthis.shutdown = shutdown;\n\tthis.startupArgs = args;\n\tthis.shutdownArg = undefined;\n};\n\nWorldConfig.prototype.toString = function() {\n\treturn '#<world-config>';\n};\n\nWorldConfig.prototype.isEqual = function(other, aUnionFind) {\n\tif ( ! isEqual(this.startup, other.startup, aUnionFind) ||\n\t     ! isEqual(this.shutdown, other.shutdown, aUnionFind) ||\n\t     this.startupArgs.length != other.startupArgs.length || \n\t     ! isEqual(this.shutdownArg, other.shutdownArg, aUnionFind) ) {\n\t\treturn false;\n\t}\n\n\tfor (var i = 0; i < args.length; i++) {\n\t\tif ( !isEqual(this.startupArgs[i], other.startupArgs[i], aUnionFind) )\n\t\t\treturn false;\n\t}\n\treturn true;\n};\n\n\nvar Effect = makeStructureType('effect', false, 0, 0, false, false);\nEffect.type.prototype.invokeEffect = function(k) {\n\thelpers.raise(types.incompleteExn(\n\t\t\ttypes.exnFail,\n\t\t\t'effect type created without using make-effect-type',\n\t\t\t[]));\n};\n//Effect.handlerIndices = [];\n\n\n//var wrapHandler = function(handler, caller, changeWorld) {\n//\treturn types.jsObject('function', function() {\n//\t\tvar externalArgs = arguments;\n//\t\tchangeWorld(function(w, k) {\n//\t\t\tvar args = helpers.map(helpers.wrapJsObject, externalArgs);\n//\t\t\targs.unshift(w);\n//\t\t\tcaller(handler, args, k);\n//\t\t});\n//\t});\n//};\n\n\nvar makeEffectType = function(name, superType, initFieldCnt, impl, guard, caller) {\n\tif ( !superType ) {\n\t\tsuperType = Effect;\n\t}\n\t\n\tvar newType = makeStructureType(name, superType, initFieldCnt, 0, false, guard);\n\tvar lastFieldIndex = newType.firstField + newType.numberOfFields;\n\n\tnewType.type.prototype.invokeEffect = function(changeWorld, k) {\n\t\tvar schemeChangeWorld = new PrimProc('update-world', 1, false, true,\n\t\t\tfunction(aState, worldUpdater) {\n\t\t\t\thelpers.check(aState, worldUpdater, helpers.procArityContains(1),\n\t\t\t\t\t      'update-world', 'procedure (arity 1)', 1);\n\t\t\t\t\n\t\t\t\tchangeWorld(function(w, k2) { interpret.call(aState,\n\t\t\t\t\t\t\t\t\t     worldUpdater, [w],\n\t\t\t\t\t\t\t\t\t     k2,\n\t\t\t\t\t\t\t\t\t     function(e) { throw e; }); },\n\t\t\t\t\t    function() { aState.v = VOID_VALUE; });\n\t\t\t});\n\n\t\tvar args = this._fields.slice(0, lastFieldIndex);\n\t\targs.unshift(schemeChangeWorld);\n\t\tcaller(impl, args, k);\n\t}\n\n\treturn newType;\n};\n\n\nvar RenderEffect = makeStructureType('render-effect', false, 0, 0, false, false);\nRenderEffect.type.prototype.callImplementation = function(caller, k) {\n\thelpers.raise(types.incompleteExn(\n\t\t\ttypes.exnFail,\n\t\t\t'render effect created without using make-render-effect-type',\n\t\t\t[]));\n};\n\nvar makeRenderEffectType = function(name, superType, initFieldCnt, impl, guard) {\n\tif ( !superType ) {\n\t\tsuperType = RenderEffect;\n\t}\n\t\n\tvar newType = makeStructureType(name, superType, initFieldCnt, 0, false, guard);\n\tvar lastFieldIndex = newType.firstField + newType.numberOfFields;\n\n\tnewType.type.prototype.callImplementation = function(caller, k) {\n\t\tvar args = this._fields.slice(0, lastFieldIndex);\n\t\tcaller(impl, args, k);\n\t}\n\n\treturn newType;\n};\n\n//////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\nvar toWrittenString = function(x, cache) {\n    if (! cache) { \n     \tcache = makeLowLevelEqHash();\n    }\n\n    if (typeof(x) == 'object') {\n\t    if (cache.containsKey(x)) {\n\t\t    return \"...\";\n\t    } else {\n\t        cache.put(x, true);\n            }\n    }\n\n    if (x == undefined || x == null) {\n\treturn \"#<undefined>\";\n    }\n    if (typeof(x) == 'string') {\n\treturn escapeString(x.toString());\n    }\n    if (typeof(x) != 'object' && typeof(x) != 'function') {\n\treturn x.toString();\n    }\n\n    var returnVal;\n    if (typeof(x.toWrittenString) !== 'undefined') {\n\treturnVal = x.toWrittenString(cache);\n    } else if (typeof(x.toDisplayedString) !== 'undefined') {\n\treturnVal = x.toDisplayedString(cache);\n    } else {\n\treturnVal = x.toString();\n    }\n    cache.remove(x);\n    return returnVal;\n};\n\n\n\nvar toDisplayedString = function(x, cache) {\n    if (! cache) {\n    \tcache = makeLowLevelEqHash();\n    }\n    if (typeof(x) == 'object') {\n\t    if (cache.containsKey(x)) {\n\t\t    return \"...\";\n\t    }\n\t    cache.put(x, true);\n    }\n\n    if (x == undefined || x == null) {\n\treturn \"#<undefined>\";\n    }\n    if (typeof(x) == 'string') {\n\treturn x;\n    }\n    if (typeof(x) != 'object' && typeof(x) != 'function') {\n\treturn x.toString();\n    }\n\n    var returnVal;\n    if (typeof(x.toDisplayedString) !== 'undefined') {\n\treturnVal = x.toDisplayedString(cache);\n    } else if (typeof(x.toWrittenString) !== 'undefined') {\n\treturnVal = x.toWrittenString(cache);\n    } else {\n\treturnVal = x.toString();\n    }\n    cache.remove(x);\n    return returnVal;\n};\n\n\n\n// toDomNode: scheme-value -> dom-node\nvar toDomNode = function(x, cache) {\n    if (! cache) {\n    \tcache = makeLowLevelEqHash();\n    }\n    \n    if (isNumber(x)) {\n\treturn numberToDomNode(x);\n    }\n\n    if (typeof(x) == 'object') {\n\t    if (cache.containsKey(x)) {\n        var node = document.createElement(\"span\");\n        node.style['font-family'] = 'monospace';\n        node.appendChild(document.createTextNode(\"...\"));\n        return node;\n\t    }\n\t    cache.put(x, true);\n    }\n\n    if (x == undefined || x == null) {\n      var node = document.createElement(\"span\");\n      node.style['font-family'] = 'monospace';\n      node.appendChild(document.createTextNode(\"#<undefined>\"));\n      return node;\n    }\n    if (typeof(x) == 'string') {\n        return textToDomNode(toWrittenString(x));\n    }\n    if (typeof(x) != 'object' && typeof(x) != 'function') {\n        return textToDomNode(x.toString());\n    }\n\n    var returnVal;\n    if (x.nodeType) {\n\treturnVal =  x;\n    } else if (typeof(x.toDomNode) !== 'undefined') {\n\treturnVal =  x.toDomNode(cache);\n    } else if (typeof(x.toWrittenString) !== 'undefined') {\t\n        returnVal = textToDomNode(x.toWrittenString(cache))\n    } else if (typeof(x.toDisplayedString) !== 'undefined') {\n        returnVal = textToDomNode(x.toDisplayedString(cache));\n    } else {\n        returnVal = textToDomNode(x.toString());\n    }\n    cache.remove(x);\n    return returnVal;\n};\n\n\nvar textToDomNode = function(text) {\n    var chunks = text.split(\"\\n\");\n    var i;\n    var wrapper = document.createElement(\"span\");\n    var newlineDiv;\n    wrapper.className = (text===\"true\" || text===\"false\")? \"wescheme-boolean\" : \"wescheme-string\";\n    wrapper.style.fontFamily = 'monospace';\n    wrapper.style.whiteSpace = \"pre\";\n    if (chunks.length > 0) {\n        wrapper.appendChild(document.createTextNode(chunks[0]));\n    }\n    for (i = 1; i < chunks.length; i++) {\n        newlineDiv = document.createElement(\"br\");\n        newlineDiv.style.clear = 'left';\n        wrapper.appendChild(newlineDiv);\n        wrapper.appendChild(document.createTextNode(chunks[i]));\n    }\n    return wrapper;\n};\n\n\n\n// numberToDomNode: jsnum -> dom\n// Given a jsnum, produces a dom-node representation.\nvar numberToDomNode = function(n) {\n    var node;\n    if (jsnums.isExact(n)) {\n      if (jsnums.isInteger(n)) {\n          node = document.createElement(\"span\");\n          node.className = \"wescheme-number Integer\";\n          node.appendChild(document.createTextNode(n.toString()));\n          return node;\n      } else if (jsnums.isRational(n)) {\n          return rationalToDomNode(n);\n      } else if (isComplex(n)) {\n          node = document.createElement(\"span\");\n          node.className = \"wescheme-number Complex\";\n          node.appendChild(document.createTextNode(n.toString()));\n          return node;\n      } else {\n          node = document.createElement(\"span\");\n          node.className = \"wescheme-number\";\n          node.appendChild(document.createTextNode(n.toString()));\n          return node;\n      }\n    } else {\n      node = document.createElement(\"span\");\n      node.className = \"wescheme-number\";\n      node.appendChild(document.createTextNode(n.toString()));\n      return node;\n    }\n};\n\n// rationalToDomNode: rational -> dom-node\nvar rationalToDomNode = function(n) {\n    var repeatingDecimalNode = document.createElement(\"span\");\n    var chunks = jsnums.toRepeatingDecimal(jsnums.numerator(n),\n\t\t\t\t\t   jsnums.denominator(n),\n\t\t\t\t\t   {limit: 25});\n    var firstPart = document.createElement(\"span\");\n    firstPart.appendChild(document.createTextNode(chunks[0] + '.' + chunks[1]));\n    repeatingDecimalNode.appendChild(firstPart);\n    if (chunks[2] === '...') {\n      firstPart.appendChild(document.createTextNode(chunks[2]));\n    } else if (chunks[2] !== '0') {\n      var overlineSpan = document.createElement(\"span\");\n      overlineSpan.style.textDecoration = 'overline';\n      overlineSpan.appendChild(document.createTextNode(chunks[2]));\n      repeatingDecimalNode.appendChild(overlineSpan);\n    }\n\n\n    var fractionalNode = document.createElement(\"span\");\n    var numeratorNode = document.createElement(\"sup\");\n    numeratorNode.appendChild(document.createTextNode(String(jsnums.numerator(n))));\n    var denominatorNode = document.createElement(\"sub\");\n    denominatorNode.appendChild(document.createTextNode(String(jsnums.denominator(n))));\n    var barNode = document.createElement(\"span\");\n    barNode.appendChild(document.createTextNode(\"/\"));\n\n    fractionalNode.appendChild(numeratorNode);\n    fractionalNode.appendChild(barNode);\n    fractionalNode.appendChild(denominatorNode);\n\n    \n    var numberNode = document.createElement(\"span\");\n    numberNode.appendChild(repeatingDecimalNode);\n    numberNode.appendChild(fractionalNode);\n    fractionalNode.style['display'] = 'none';\n\n    var showingRepeating = true;\n\n    numberNode.onclick = function(e) {\n\tshowingRepeating = !showingRepeating;\n\trepeatingDecimalNode.style['display'] = \n\t    (showingRepeating ? 'inline' : 'none')\n\tfractionalNode.style['display'] = \n\t    (!showingRepeating ? 'inline' : 'none')\n    };\n    numberNode.style['cursor'] = 'pointer';\n    numberNode.className = \"wescheme-number Rational\";\n    return numberNode;\n\n};\n\n    // Alternative: use <sup> and <sub> tags\n\n\n\n\n\nvar isNumber = jsnums.isSchemeNumber;\nvar isComplex = isNumber;\nvar isString = function(s) {\n\treturn (typeof s === 'string' || s instanceof Str);\n}\n\n\n// isEqual: X Y -> boolean\n// Returns true if the objects are equivalent; otherwise, returns false.\nvar isEqual = function(x, y, aUnionFind) {\n    if (x === y) { return true; }\n\n    if (isNumber(x) && isNumber(y)) {\n\treturn jsnums.equals(x, y);\n    }\n\n    if (isString(x) && isString(y)) {\n\treturn x.toString() === y.toString();\n    }\n\n    if (x == undefined || x == null) {\n\treturn (y == undefined || y == null);\n    }\n\n    if ( typeof(x) == 'object' &&\n\t typeof(y) == 'object' &&\n\t x.isEqual &&\n\t y.isEqual) {\n\tif (aUnionFind.find(x) === aUnionFind.find(y)) {\n\t    return true;\n\t}\n\telse {\n\t    aUnionFind.merge(x, y); \n\t    return x.isEqual(y, aUnionFind);\n\t}\n    }\n    return false;\n};\n\n\n\n\n\n// liftToplevelToFunctionValue: primitive-function string fixnum scheme-value -> scheme-value\n// Lifts a primitive toplevel or module-bound value to a scheme value.\nvar liftToplevelToFunctionValue = function(primitiveF,\n\t\t\t\t       name,\n\t\t\t\t       minArity, \n\t\t\t\t       procedureArityDescription) {\n    if (! primitiveF._mobyLiftedFunction) {\n\tvar lifted = function(args) {\n\t    return primitiveF.apply(null, args.slice(0, minArity).concat([args.slice(minArity)]));\n\t};\n\tlifted.isEqual = function(other, cache) { \n\t    return this === other; \n\t}\n\tlifted.toWrittenString = function(cache) { \n\t    return \"#<function:\" + name + \">\";\n\t};\n\tlifted.toDisplayedString = lifted.toWrittenString;\n\tlifted.procedureArity = procedureArityDescription;\n\tprimitiveF._mobyLiftedFunction = lifted;\n\t    \n    } \n    return primitiveF._mobyLiftedFunction;\n};\n\n\n\n//////////////////////////////////////////////////////////////////////\nvar ThreadCell = function(v, isPreserved) {\n    this.v = v;\n    this.isPreserved = isPreserved || false;\n};\n\n\n\n//////////////////////////////////////////////////////////////////////\n\n\n// Wrapper around functions that return multiple values.\nvar ValuesWrapper = function(elts) {\n    this.elts = elts;\n};\n\nValuesWrapper.prototype.toDomNode = function(cache) {\n    var parent = document.createElement(\"span\");\n    parent.style.whiteSpace = \"pre\";\n    if ( this.elts.length > 0 ) {\n\t    parent.appendChild( toDomNode(this.elts[0], cache) );\n\t    for (var i = 1; i < this.elts.length; i++) {\n\t\t    parent.appendChild( document.createTextNode('\\n') );\n\t\t    parent.appendChild( toDomNode(this.elts[i], cache) );\n\t    }\n    }\n    return parent;\n};\n\n\nvar UndefinedValue = function() {\n};\nUndefinedValue.prototype.toString = function() {\n    return \"#<undefined>\";\n};\nvar UNDEFINED_VALUE = new UndefinedValue();\n\nvar VoidValue = function() {};\nVoidValue.prototype.toString = function() {\n\treturn \"#<void>\";\n};\n\nvar VOID_VALUE = new VoidValue();\n\n\nvar EofValue = function() {};\nEofValue.prototype.toString = function() {\n\treturn \"#<eof>\";\n}\n\nvar EOF_VALUE = new EofValue();\n\n\nvar ClosureValue = function(name, locs, numParams, paramTypes, isRest, closureVals, body) {\n    this.name = name;\n    this.locs = locs;\n    this.numParams = numParams;\n    this.paramTypes = paramTypes;\n    this.isRest = isRest;\n    this.closureVals = closureVals;\n    this.body = body;\n};\n\n\n\n\nClosureValue.prototype.toString = function() {\n    if (this.name !== Empty.EMPTY) {\n\treturn helpers.format(\"#<function:~a>\", [this.name]);\n    } else {\n\treturn \"#<function>\";\n    }\n};\n\n\nvar CaseLambdaValue = function(name, closures) {\n    this.name = name;\n    this.closures = closures;\n};\n\nCaseLambdaValue.prototype.toString = function() {\n    if (this.name !== Empty.EMPTY) {\n\treturn helpers.format(\"#<case-lambda-procedure:~a>\", [this.name]);\n    } else {\n\treturn \"#<case-lambda-procedure>\";\n    }\n};\n\n\n\nvar ContinuationClosureValue = function(vstack, cstack) {\n    this.name = false;\n    this.vstack = vstack.slice(0);\n    this.cstack = cstack.slice(0);\n};\n\nContinuationClosureValue.prototype.toString = function() {\n    if (this.name !== Empty.EMPTY) {\n\treturn helpers.format(\"#<function:~a>\", [this.name]);\n    } else {\n\treturn \"#<function>\";\n    }\n};\n\n\n\n//////////////////////////////////////////////////////////////////////\n\n\n\nvar PrefixValue = function() {\n    this.slots = [];\n    this.definedMask = [];\n};\n\nPrefixValue.prototype.addSlot = function(v) {\n    if (v === undefined) { \n\tthis.slots.push(types.UNDEFINED);\n\tthis.definedMask.push(false);\n    } else {\n        this.slots.push(v);\n\tif (v instanceof GlobalBucket) {\n\t    if (v.value === types.UNDEFINED) {\n\t\tthis.definedMask.push(false);\n\t    } else {\n\t\tthis.definedMask.push(true);\n\t    }\n\t} else {\n\t    this.definedMask.push(true);\n\t}\n    }\n};\n\nPrefixValue.prototype.ref = function(n, srcloc) {\n    if (this.slots[n] instanceof GlobalBucket) {\n    \tif (this.definedMask[n]) {\n    \t    return this.slots[n].value;\n    \t} else {\n    \t    helpers.raise(types.incompleteExn(\n    \t\t\ttypes.exnFailContractVariable,\n    \t\t\tnew Message([new ColoredPart(this.slots[n].name, srcloc),\n                            \": this variable is not defined\"]),\n    \t\t\t[this.slots[n].name]));\n    \t}\n        } else {\n    \tif (this.definedMask[n]) {\n    \t    return this.slots[n];\n    \t} else {\n    \t    helpers.raise(types.incompleteExn(\n    \t\t\ttypes.exnFailContractVariable,\n    \t\t\t\"variable has not been defined\",\n    \t\t\t[false]));\n    \t}\n    }\n};\n\nPrefixValue.prototype.set = function(n, v) {\n    if (this.slots[n] instanceof GlobalBucket) {\n\tthis.slots[n].value = v;\n\tthis.definedMask[n] = true;\n    } else {\n\tthis.slots[n] = v;\n\tthis.definedMask[n] = true;\n    }\n};\n\n\nPrefixValue.prototype.length = function() { \n    return this.slots.length;\n};\n\n\nvar GlobalBucket = function(name, value) {\n    this.name = name;\n    this.value = value;\n};\n\n\n\nvar ModuleVariableRecord = function(resolvedModuleName,\n\t\t\t\t    variableName) {\n    this.resolvedModuleName = resolvedModuleName;\n    this.variableName = variableName;\n};\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////\n\n\nvar VariableReference = function(prefix, pos) {\n    this.prefix = prefix;\n    this.pos = pos;\n};\n\nVariableReference.prototype.ref = function() {\n    return this.prefix.ref(this.pos);\n};\n\nVariableReference.prototype.set = function(v) {\n    this.prefix.set(this.pos, v);\n}\n\n//////////////////////////////////////////////////////////////////////\n\n// Continuation Marks\n\nvar ContMarkRecordControl = function(dict) {\n    this.dict = dict || {};\n};\n\nContMarkRecordControl.prototype.invoke = function(state) {\n    // No-op: the record will simply pop off the control stack.\n};\n\nContMarkRecordControl.prototype.update = function(key, val) {\n /*\n    var newDict = makeLowLevelEqHash();\n    // FIXME: what's the javascript idiom for hash key copy?\n    // Maybe we should use a rbtree instead?\n    var oldKeys = this.dict.keys();\n    for (var i = 0; i < oldKeys.length; i++) {\n\t    newDict.put( oldKeys[i], this.dict.get(oldKeys[i]) );\n    }\n    newDict.put(key, val);\n    return new ContMarkRecordControl(newDict);\n  */\n  this.dict[key.val] = val;\n  return this;\n};\n\n\n\nvar ContinuationMarkSet = function(dict) {\n    this.dict = dict;\n}\n\nContinuationMarkSet.prototype.toDomNode = function(cache) {\n    var dom = document.createElement(\"span\");\n    dom.appendChild(document.createTextNode('#<continuation-mark-set>'));\n    return dom;\n};\n\nContinuationMarkSet.prototype.toWrittenString = function(cache) {\n    return '#<continuation-mark-set>';\n};\n\nContinuationMarkSet.prototype.toDisplayedString = function(cache) {\n    return '#<continuation-mark-set>';\n};\n\nContinuationMarkSet.prototype.ref = function(key) {\n    if ( this.dict.containsKey(key) ) {\n\t    return this.dict.get(key);\n    }\n    return [];\n};\n\n\n//////////////////////////////////////////////////////////////////////\n\nvar ContinuationPrompt = function() {\n};\n\nvar defaultContinuationPrompt = new ContinuationPrompt();\n\n\n\n//////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////\n\nvar PrimProc = function(name, numParams, isRest, assignsToValueRegister, impl) {\n    this.name = name;\n    this.numParams = numParams;\n    this.isRest = isRest;\n    this.assignsToValueRegister = assignsToValueRegister;\n    this.impl = impl;\n};\n\nPrimProc.prototype.toString = function() {\n    return (\"#<function:\" + this.name + \">\");\n};\n\nPrimProc.prototype.toWrittenString = function(cache) {\n    return (\"#<function:\" + this.name + \">\");\n};\n\nPrimProc.prototype.toDisplayedString = function(cache) {\n    return (\"#<function:\" + this.name + \">\");\n};\n\n\nPrimProc.prototype.toDomNode = function(cache) {\n    var node = document.createElement(\"span\");\n    node.className = \"wescheme-primproc\";\n    node.appendChild(document.createTextNode(\"#<function:\"+ this.name +\">\"));\n    return node;\n};\n\n\nvar CasePrimitive = function(name, cases) {\n    this.name = name;\n    this.cases = cases;\n};\n\n\nCasePrimitive.prototype.toDomNode = function(cache) {\n    var node = document.createElement(\"span\");\n    node.className = \"wescheme-caseprimitive\";\n    node.appendChild(document.createTextNode(\"#<function:\"+ this.name +\">\"));\n    return node;\n};\n\nCasePrimitive.prototype.toWrittenString = function(cache) {\n    return (\"#<function:\" + this.name + \">\");\n};\n\nCasePrimitive.prototype.toDisplayedString = function(cache) {\n    return (\"#<function:\" + this.name + \">\");\n};\n\n\n\n\n/////////////////////////////////////////////////////////////////////\n// Colored Error Message Support\n\nvar Message = function(args) {\n  this.args = args;\n};\n\nMessage.prototype.toString = function() {\n  var toReturn = [];\n  var i;\n  for(i = 0; i < this.args.length; i++) {\n      toReturn.push(''+this.args[i]);\n  }\n  \n  return toReturn.join(\"\");\n};\n\nvar isMessage = function(o) {\n  return o instanceof Message;\n};\n\nvar ColoredPart = function(text, location) {\n  this.text = text;\n  this.location = location;\n};\n\nvar isColoredPart = function(o) {\n  return o instanceof ColoredPart;\n};\n\nColoredPart.prototype.toString = function() {\n    return this.text+'';\n};\n\nvar GradientPart = function(coloredParts) {\n    this.coloredParts = coloredParts;\n};\n\nvar isGradientPart = function(o) {\n  return o instanceof GradientPart;\n};\n\nGradientPart.prototype.toString = function() {\n\tvar i;\n\tvar resultArray = [];\n\tfor(i = 0; i < this.coloredParts.length; i++){\n\t\tresultArray.push(this.coloredParts[i].text+'');\n\t}\n\treturn resultArray.join(\"\");\n\n};\n\nvar MultiPart = function(text, locations, solid) {\n    this.text = text;\n    this.locations = locations;\n    this.solid = solid;\n};\n\nvar isMultiPart = function(o) {\n  return o instanceof MultiPart;\n};\n\nMultiPart.prototype.toString = function() {\n\treturn this.text;\n};\n\n\n//////////////////////////////////////////////////////////////////////\n\n\n\n\n\nvar makeList = function(args) {\n    var result = Empty.EMPTY;\n    var i;\n    for(i = args.length-1; i >= 0; i--) {\n\tresult = Cons.makeInstance(args[i], result);\n    }\n    return result;\n};\n\n\nvar makeVector = function(args) {\n    return Vector.makeInstance(args.length, args);\n};\n\nvar makeString = function(s) {\n\tif (s instanceof Str) {\n\t\treturn s;\n\t}\n\telse if (s instanceof Array) {\n//\t\tfor (var i = 0; i < s.length; i++) {\n//\t\t\tif ( typeof s[i] !== 'string' || s[i].length != 1 ) {\n//\t\t\t\treturn undefined;\n//\t\t\t}\n//\t\t}\n\t\treturn Str.makeInstance(s);\n\t}\n\telse if (typeof s === 'string') {\n\t\treturn Str.fromString(s);\n\t}\n\telse {\n\t\tthrow types.internalError('makeString expects and array of 1-character strings or a string;' +\n\t\t\t\t\t  ' given ' + s.toString(),\n\t\t\t\t\t  false);\n\t}\n};\n\n\nvar makeHashEq = function(lst) {\n\tvar newHash = new EqHashTable();\n\twhile ( !lst.isEmpty() ) {\n\t\tnewHash.hash.put(lst.first().first(), lst.first().rest());\n\t\tlst = lst.rest();\n\t}\n\treturn newHash;\n};\n\n\nvar makeHashEqual = function(lst) {\n\tvar newHash = new EqualHashTable();\n\twhile ( !lst.isEmpty() ) {\n\t\tnewHash.hash.put(lst.first().first(), lst.first().rest());\n\t\tlst = lst.rest();\n\t}\n\treturn newHash;\n};\n\n\n//if there is not enough location information available,\n//this allows for highlighting to be turned off\nvar NoLocation = makeVector(['<no-location>', 0,0,0,0]);\n\nvar isNoLocation = function(o) {\n  return o === NoLocation;\n};\n\n\n\nvar Posn = makeStructureType('posn', false, 2, 0, false, false);\nvar Color = makeStructureType('color', false, 4, 0, false, false);\nvar ArityAtLeast = makeStructureType('arity-at-least', false, 1, 0, false,\n\t\tfunction(k, n, name) {\n\t\t\thelpers.check(undefined, n, function(x) { return ( jsnums.isExact(x) &&\n\t\t\t\t\t\t\t\tjsnums.isInteger(x) &&\n\t\t\t\t\t\t\t\tjsnums.greaterThanOrEqual(x, 0) ); },\n\t\t\t\t      name, 'exact non-negative integer', 1);\n\t\t\tk(n);\n\t\t});\n\n\ntypes.symbol = Symbol.makeInstance;\ntypes.rational = jsnums.makeRational;\ntypes['float'] = jsnums.makeFloat;\ntypes.complex = jsnums.makeComplex;\ntypes.bignum = jsnums.makeBignum;\ntypes.list = makeList;\ntypes.vector = makeVector;\ntypes.regexp = function(p) { return new RegularExpression(p) ; }\ntypes.byteRegexp = function(p) { return new ByteRegularExpression(p) ; }\ntypes['char'] = Char.makeInstance;\ntypes['string'] = makeString;\ntypes.box = function(x) { return new Box(x, true); };\ntypes.boxImmutable = function(x) { return new Box(x, false); };\ntypes.path = function(x) { return new Path(x); };\ntypes.bytes = function(x, mutable) { return new Bytes(x, mutable); };\ntypes.keyword = function(k) { return new Keyword(k); };\ntypes.pair = function(x, y) { return Cons.makeInstance(x, y); };\ntypes.hash = makeHashEqual;\ntypes.hashEq = makeHashEq;\ntypes.jsObject = function(name, obj) { return new JsObject(name, obj); };\n\ntypes.toWrittenString = toWrittenString;\ntypes.toDisplayedString = toDisplayedString;\ntypes.toDomNode = toDomNode;\n\ntypes.posn = Posn.constructor;\ntypes.posnX = function(psn) { return Posn.accessor(psn, 0); };\ntypes.posnY = function(psn) { return Posn.accessor(psn, 1); };\n\ntypes.color = function(r, g, b, a) { \n    if (a === undefined) {\n        a = 255;\n    }\n    return Color.constructor(r, g, b, a);\n};\ntypes.colorRed = function(x) { return Color.accessor(x, 0); };\ntypes.colorGreen = function(x) { return Color.accessor(x, 1); };\ntypes.colorBlue = function(x) { return Color.accessor(x, 2); };\ntypes.colorAlpha = function(x) { return Color.accessor(x, 3); };\n\ntypes.arityAtLeast = ArityAtLeast.constructor;\ntypes.arityValue = function(arity) { return ArityAtLeast.accessor(arity, 0); };\n\n\ntypes.FALSE = Logic.FALSE;\ntypes.TRUE = Logic.TRUE;\ntypes.EMPTY = Empty.EMPTY;\n\ntypes.isEqual = isEqual;\ntypes.isNumber = isNumber;\ntypes.isSymbol = function(x) { return x instanceof Symbol; };\ntypes.isChar = function(x) { return x instanceof Char; };\ntypes.isString = isString;\ntypes.isPair = function(x) { return x instanceof Cons; };\ntypes.isVector = function(x) { return x instanceof Vector; };\ntypes.isBox = function(x) { return x instanceof Box; };\ntypes.isHash = function(x) { return (x instanceof EqHashTable ||\n\t\t\t\t     x instanceof EqualHashTable); };\ntypes.isByteString = function(x) { return x instanceof Bytes; };\ntypes.isStruct = function(x) { return x instanceof Struct; };\ntypes.isPosn = Posn.predicate;\ntypes.isArityAtLeast = ArityAtLeast.predicate;\ntypes.isColor = Color.predicate;\ntypes.isFunction = function(x) {\n\treturn (x instanceof PrimProc ||\n\t\tx instanceof CasePrimitive ||\n\t\tx instanceof ClosureValue ||\n\t\tx instanceof CaseLambdaValue ||\n\t\tx instanceof ContinuationClosureValue);\n};\ntypes.getProcedureType = function(x){\n return (x instanceof PrimProc)? \"PrimProc\" :\n       (x instanceof CasePrimitive)? \"CasePrimitive\" :\n       (x instanceof ClosureValue)? \"ClosureValue\" :\n       (x instanceof CaseLambdaValue)? \"CaseLambdaValue\" :\n       (x instanceof ContinuationClosureValue)? \"ContinuationClosureValue\" :\n       /* else */ false;\n};\n \ntypes.isJsObject = function(x) { return x instanceof JsObject; };\n\ntypes.UnionFind = UnionFind;\ntypes.cons = Cons.makeInstance;\n\ntypes.UNDEFINED = UNDEFINED_VALUE;\ntypes.VOID = VOID_VALUE;\ntypes.EOF = EOF_VALUE;\n\ntypes.ValuesWrapper = ValuesWrapper;\ntypes.ClosureValue = ClosureValue;\ntypes.ContinuationPrompt = ContinuationPrompt;\ntypes.defaultContinuationPrompt = defaultContinuationPrompt;\ntypes.ContinuationClosureValue = ContinuationClosureValue;\ntypes.CaseLambdaValue = CaseLambdaValue;\ntypes.PrimProc = PrimProc;\ntypes.CasePrimitive = CasePrimitive;\n\ntypes.contMarkRecordControl = function(dict) { return new ContMarkRecordControl(dict); };\ntypes.isContMarkRecordControl = function(x) { return x instanceof ContMarkRecordControl; };\ntypes.continuationMarkSet = function(dict) { return new ContinuationMarkSet(dict); };\ntypes.isContinuationMarkSet = function(x) { return x instanceof ContinuationMarkSet; };\n\n\ntypes.PrefixValue = PrefixValue;\ntypes.GlobalBucket = GlobalBucket;\ntypes.ModuleVariableRecord = ModuleVariableRecord;\ntypes.VariableReference = VariableReference;\n\ntypes.Box = Box;\ntypes.ThreadCell = ThreadCell;\n\n\n\ntypes.Class = Class;\n\n\ntypes.makeStructureType = makeStructureType;\ntypes.isStructType = function(x) { return x instanceof StructType; };\n\n\ntypes.makeLowLevelEqHash = makeLowLevelEqHash;\n\n\n// Error type exports\nvar InternalError = function(val, contMarks) {\n\tthis.val = val;\n\tthis.contMarks = (contMarks ? contMarks : false);\n}\ntypes.internalError = function(v, contMarks) { return new InternalError(v, contMarks); };\ntypes.isInternalError = function(x) { return x instanceof InternalError; };\n\nvar SchemeError = function(val) {\n\tthis.val = val;\n}\ntypes.schemeError = function(v) { return new SchemeError(v); };\ntypes.isSchemeError = function(v) { return v instanceof SchemeError; };\n\n\nvar IncompleteExn = function(constructor, msg, otherArgs) {\n\tthis.constructor = constructor;\n\tthis.msg = msg;\n\tthis.otherArgs = otherArgs;\n};\ntypes.incompleteExn = function(constructor, msg, args) { return new IncompleteExn(constructor, msg, args); };\ntypes.isIncompleteExn = function(x) { return x instanceof IncompleteExn; };\n\nvar Exn = makeStructureType('exn', false, 2, 0, false,\n\t\tfunction(k, msg, contMarks, name) {\n\t\t\t// helpers.check(msg, isString, name, 'string', 1, [msg, contMarks]);\n\t\t\thelpers.check(undefined, contMarks, types.isContinuationMarkSet, name, 'continuation mark set', 2);\n\t\t\tk( new ValuesWrapper([msg, contMarks]) );\n\t\t});\ntypes.exn = Exn.constructor;\ntypes.isExn = Exn.predicate;\ntypes.exnMessage = function(exn) { return Exn.accessor(exn, 0); };\ntypes.exnContMarks = function(exn) { return Exn.accessor(exn, 1); };\ntypes.exnSetContMarks = function(exn, v) { Exn.mutator(exn, 1, v); };\n\n// (define-struct (exn:break exn) (continuation))\nvar ExnBreak = makeStructureType('exn:break', Exn, 1, 0, false,\n\t\tfunction(k, msg, contMarks, cont, name) {\n\t\t// FIXME: what type is a continuation here?\n//\t\t\thelpers.check(cont, isContinuation, name, 'continuation', 3);\n\t\t\tk( new ValuesWrapper([msg, contMarks, cont]) );\n\t\t});\ntypes.exnBreak = ExnBreak.constructor;\ntypes.isExnBreak = ExnBreak.predicate;\ntypes.exnBreakContinuation = function(exn) {\n    return ExnBreak.accessor(exn, 0); };\n\nvar ExnFail = makeStructureType('exn:fail', Exn, 0, 0, false, false);\ntypes.exnFail = ExnFail.constructor;\ntypes.isExnFail = ExnFail.predicate;\n\nvar ExnFailContract = makeStructureType('exn:fail:contract', ExnFail, 0, 0, false, false);\ntypes.exnFailContract = ExnFailContract.constructor;\ntypes.isExnFailContract = ExnFailContract.predicate;\n\nvar ExnFailContractArity = makeStructureType('exn:fail:contract:arity', ExnFailContract, 0, 0, false, false);\ntypes.exnFailContractArity = ExnFailContract.constructor;\ntypes.isExnFailContractArity = ExnFailContract.predicate;\n\nvar ExnFailContractVariable = makeStructureType('exn:fail:contract:variable', ExnFailContract, 1, 0, false, false);\ntypes.exnFailContractVariable = ExnFailContract.constructor;\ntypes.isExnFailContractVariable = ExnFailContract.predicate;\ntypes.exnFailContractVariableId = function(exn) { return ExnFailContractVariable.accessor(exn, 0); };\n\nvar ExnFailContractDivisionByZero = makeStructureType('exn:fail:contract:division-by-zero', ExnFailContract, 0, 0, false, false);\ntypes.exnFailContractDivisionByZero = ExnFailContractDivisionByZero.constructor;\ntypes.isExnFailContractDivisionByZero = ExnFailContractDivisionByZero.predicate;\n\nvar ExnFailContractArityWithPosition = makeStructureType('exn:fail:contract:arity:position', ExnFailContractArity, 1, 0, false, false);\ntypes.exnFailContractArityWithPosition = ExnFailContractArityWithPosition.constructor;\ntypes.isExnFailContractArityWithPosition = ExnFailContractArityWithPosition.predicate;\n\ntypes.exnFailContractArityWithPositionLocations = function(exn) { return ExnFailContractArityWithPosition.accessor(exn, 0); };\n\n\n///////////////////////////////////////\n// World-specific exports\n\ntypes.worldConfig = function(startup, shutdown, args) { return new WorldConfig(startup, shutdown, args); };\ntypes.isWorldConfig = function(x) { return x instanceof WorldConfig; };\n\ntypes.makeEffectType = makeEffectType;\ntypes.isEffectType = function(x) {\n\treturn (x instanceof StructType && x.type.prototype.invokeEffect) ? true : false;\n};\n\n\ntypes.isEffect = Effect.predicate;\n\n//types.EffectDoNothing = makeEffectType('effect:do-nothing',\n//\t\t\t\t       false,\n//\t\t\t\t       0,\n//\t\t\t\t       function(k) { k(); },\n//\t\t\t\t       [],\n//\t\t\t\t       function(k) { k(new ValuesWrapper([])); },\n//\t\t\t\t       function(f, args, k) { f(k); });\n//types.effectDoNothing = EffectDoNothing.constructor;\n//types.isEffectDoNothing = EffectDoNothing.predicate;\n\n\n//RenderEffect = makeStructureType('render-effect', false, 2, 0, false,\n//\t\tfunction(k, domNode, effects, name) {\n//\t\t\thelpers.checkListOf(effects, helpers.procArityContains(0), name, 'procedure (arity 0)', 2);\n//\t\t\tk( new ValuesWrapper([domNode, effects]) );\n//\t\t});\n\ntypes.makeRenderEffectType = makeRenderEffectType;\ntypes.isRenderEffectType = function(x) {\n\treturn (x instanceof StructType && x.type.prototype.callImplementation) ? true : false;\n};\n\n//types.RenderEffect = RenderEffect;\n//types.makeRenderEffect = RenderEffect.constructor;\ntypes.isRenderEffect = RenderEffect.predicate;\n//types.renderEffectDomNode = function(x) { return RenderEffect.accessor(x, 0); };\n//types.renderEffectEffects = function(x) { return RenderEffect.accessor(x, 1); };\n//types.setRenderEffectEffects = function(x, v) { RenderEffect.mutator(x, 1, v); };\n\n\ntypes.NoLocation = NoLocation;\ntypes.isNoLocation = isNoLocation;\n\n\n\ntypes.ColoredPart = ColoredPart;\ntypes.Message = Message;\ntypes.isColoredPart = isColoredPart;\ntypes.isMessage = isMessage;\ntypes.GradientPart = GradientPart;\ntypes.isGradientPart = isGradientPart;\ntypes.MultiPart = MultiPart;\ntypes.isMultiPart = isMultiPart;\ntypes.Vector = Vector;\n\n\n})();\n\nmodule.exports = types;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/runtime/types.js\n ** module id = 3\n ** module chunks = 0\n **/","// Scheme numbers.\n\n\nvar __PLTNUMBERS_TOP__;\nif (typeof(exports) !== 'undefined') {\n    __PLTNUMBERS_TOP__ = exports;\n} else {\n    if (! this['jsnums']) {\n \tthis['jsnums'] = {};\n    }\n    __PLTNUMBERS_TOP__  = this['jsnums'];\n}\n\n//var jsnums = {};\n\n\n// The numeric tower has the following levels:\n//     integers\n//     rationals\n//     floats\n//     complex numbers\n//\n// with the representations:\n//     integers: fixnum or BigInteger [level=0]\n//     rationals: Rational [level=1]\n//     floats: FloatPoint [level=2]\n//     complex numbers: Complex [level=3]\n\n// We try to stick with the unboxed fixnum representation for\n// integers, since that's what scheme programs commonly deal with, and\n// we want that common type to be lightweight.\n\n\n// A boxed-scheme-number is either BigInteger, Rational, FloatPoint, or Complex.\n// An integer-scheme-number is either fixnum or BigInteger.\n\n\n(function() {\n    'use strict';\n    // Abbreviation\n    var Numbers = __PLTNUMBERS_TOP__;\n    //var Numbers = jsnums;\n\n\n    // makeNumericBinop: (fixnum fixnum -> any) (scheme-number scheme-number -> any) -> (scheme-number scheme-number) X\n    // Creates a binary function that works either on fixnums or boxnums.\n    // Applies the appropriate binary function, ensuring that both scheme numbers are\n    // lifted to the same level.\n    var makeNumericBinop = function(onFixnums, onBoxednums, options) {\n\toptions = options || {};\n\treturn function(x, y) {\n\t    if (options.isXSpecialCase && options.isXSpecialCase(x))\n\t\treturn options.onXSpecialCase(x, y);\n\t    if (options.isYSpecialCase && options.isYSpecialCase(y))\n\t\treturn options.onYSpecialCase(x, y);\n\n\t    if (typeof(x) === 'number' &&\n\t\ttypeof(y) === 'number') {\n\t\treturn onFixnums(x, y);\n\t    }\n\t    if (typeof(x) === 'number') {\n\t\tx = liftFixnumInteger(x, y);\n\t    }\n\t    if (typeof(y) === 'number') {\n\t\ty = liftFixnumInteger(y, x);\n\t    }\n\n\t    if (x.level < y.level) x = x.liftTo(y);\n\t    if (y.level < x.level) y = y.liftTo(x);\n\t    return onBoxednums(x, y);\n\t};\n    }\n    \n    \n    // fromFixnum: fixnum -> scheme-number\n    var fromFixnum = function(x) {\n\tif (isNaN(x) || (! isFinite(x))) {\n\t    return FloatPoint.makeInstance(x);\n\t}\n\tvar nf = Math.floor(x);\n\tif (nf === x) {\n            if (isOverflow(nf)) {\n\t\treturn makeBignum(expandExponent(x+''));\n            } else {\n\t\treturn nf;\n\t    }\n\t} else {\n            return FloatPoint.makeInstance(x);\n\t}\n    };\n\n    var expandExponent = function(s) {\n\tvar match = s.match(scientificPattern(digitsForRadix(10), expMarkForRadix(10))), mantissaChunks, exponent;\n\tif (match) {\n\t    mantissaChunks = match[1].match(/^([^.]*)(.*)$/);\n\t    exponent = Number(match[2]);\n\n\t    if (mantissaChunks[2].length === 0) {\n\t\treturn mantissaChunks[1] + zfill(exponent);\n\t    }\n\n\t    if (exponent >= mantissaChunks[2].length - 1) {\n\t\treturn (mantissaChunks[1] + \n\t\t\tmantissaChunks[2].substring(1) + \n\t\t\tzfill(exponent - (mantissaChunks[2].length - 1)));\n\t    } else {\n\t\treturn (mantissaChunks[1] +\n\t\t\tmantissaChunks[2].substring(1, 1+exponent));\n\t    }\n\t} else {\n\t    return s;\n\t}\n    };\n\n    // zfill: integer -> string\n    // builds a string of \"0\"'s of length n.\n    var zfill = function(n) {\n\tvar buffer = [];\n\tbuffer.length = n;\n\tfor (var i = 0; i < n; i++) {\n\t    buffer[i] = '0';\n\t}\n\treturn buffer.join('');\n    };\n    \n\n    \n    // liftFixnumInteger: fixnum-integer boxed-scheme-number -> boxed-scheme-number\n    // Lifts up fixnum integers to a boxed type.\n    var liftFixnumInteger = function(x, other) {\n\tswitch(other.level) {\n\tcase 0: // BigInteger\n\t    return makeBignum(x);\n\tcase 1: // Rational\n\t    return new Rational(x, 1);\n\tcase 2: // FloatPoint\n\t    return new FloatPoint(x);\n\tcase 3: // Complex\n\t    return new Complex(x, 0);\n\tdefault:\n\t    throwRuntimeError(\"IMPOSSIBLE: cannot lift fixnum integer to \" + other.toString(), x, other);\n\t}\n    };\n    \n    \n    // throwRuntimeError: string (scheme-number | undefined) (scheme-number | undefined) -> void\n    // Throws a runtime error with the given message string.\n    var throwRuntimeError = function(msg, x, y) {\n\tNumbers['onThrowRuntimeError'](msg, x, y);\n    };\n\n\n\n    // onThrowRuntimeError: string (scheme-number | undefined) (scheme-number | undefined) -> void\n    // By default, will throw a new Error with the given message.\n    // Override Numbers['onThrowRuntimeError'] if you need to do something special.\n    var onThrowRuntimeError = function(msg, x, y) {\n\tthrow new Error(msg);\n    };\n\n\n    // isSchemeNumber: any -> boolean\n    // Returns true if the thing is a scheme number.\n    var isSchemeNumber = function(thing) {\n\treturn (typeof(thing) === 'number'\n\t\t|| (thing instanceof Rational ||\n\t\t    thing instanceof FloatPoint ||\n\t\t    thing instanceof Complex ||\n\t\t    thing instanceof BigInteger));\n    };\n\n\n    // isRational: scheme-number -> boolean\n    var isRational = function(n) {\n\treturn (typeof(n) === 'number' ||\n\t\t(isSchemeNumber(n) && n.isRational()));\n    };\n\n    // isReal: scheme-number -> boolean\n    var isReal = function(n) {\n\treturn (typeof(n) === 'number' ||\n\t\t(isSchemeNumber(n) && n.isReal()));\n    };\n\n    // isExact: scheme-number -> boolean\n    var isExact = function(n) {\n\treturn (typeof(n) === 'number' || \n\t\t(isSchemeNumber(n) && n.isExact()));\n    };\n\n    // isExact: scheme-number -> boolean\n    var isInexact = function(n) {\n\tif (typeof(n) === 'number') {\n\t    return false;\n\t} else {\n\t    return (isSchemeNumber(n) && n.isInexact());\n\t}\n    };\n\n    // isInteger: scheme-number -> boolean\n    var isInteger = function(n) {\n\treturn (typeof(n) === 'number' ||\n\t\t(isSchemeNumber(n) && n.isInteger()));\n    };\n\n    // isExactInteger: scheme-number -> boolean\n    var isExactInteger = function(n) {\n\treturn (typeof(n) === 'number' ||\n\t\t(isSchemeNumber(n) && \n\t\t n.isInteger() && \n\t\t n.isExact()));\n    }\n\n\n\n    // toFixnum: scheme-number -> javascript-number\n    var toFixnum = function(n) {\n\tif (typeof(n) === 'number')\n\t    return n;\n\treturn n.toFixnum();\n    };\n\n    // toExact: scheme-number -> scheme-number\n    var toExact = function(n) {\n\tif (typeof(n) === 'number')\n\t    return n;\n\treturn n.toExact();\n    };\n\n\n    // toExact: scheme-number -> scheme-number\n    var toInexact = function(n) {\n\tif (typeof(n) === 'number')\n\t    return FloatPoint.makeInstance(n);\n\treturn n.toInexact();\n    };\n\n\n\n    //////////////////////////////////////////////////////////////////////\n\n\n    // add: scheme-number scheme-number -> scheme-number\n    var add = function(x, y) {\n        var sum;\n        if (typeof(x) === 'number' && typeof(y) === 'number') {\n            sum = x + y;\n            if (isOverflow(sum)) {\n\t\treturn (makeBignum(x)).add(makeBignum(y));\n            }\n        }\n        if (x instanceof FloatPoint && y instanceof FloatPoint) {\n            return x.add(y);\n        }\n        return addSlow(x, y);        \n    };\n\n    var addSlow = makeNumericBinop(\n\tfunction(x, y) {\n\t    var sum = x + y;\n\t    if (isOverflow(sum)) {\n\t\treturn (makeBignum(x)).add(makeBignum(y));\n\t    } else {\n\t\treturn sum;\n\t    }\n\t},\n\tfunction(x, y) {\n\t    return x.add(y);\n\t},\n\t{isXSpecialCase: function(x) { \n\t    return isExactInteger(x) && _integerIsZero(x) },\n\t onXSpecialCase: function(x, y) { return y; },\n\t isYSpecialCase: function(y) { \n\t     return isExactInteger(y) && _integerIsZero(y) },\n\t onYSpecialCase: function(x, y) { return x; }\n\t});\n\n\n    // subtract: scheme-number scheme-number -> scheme-number\n    var subtract = makeNumericBinop(\n\tfunction(x, y) {\n\t    var diff = x - y;\n\t    if (isOverflow(diff)) {\n\t\treturn (makeBignum(x)).subtract(makeBignum(y));\n\t    } else {\n\t\treturn diff;\n\t    }\n\t},\n\tfunction(x, y) {\n\t    return x.subtract(y);\n\t},\n\t{isXSpecialCase: function(x) { \n\t    return isExactInteger(x) && _integerIsZero(x) },\n\t onXSpecialCase: function(x, y) { return negate(y); },\n\t isYSpecialCase: function(y) { \n\t     return isExactInteger(y) && _integerIsZero(y) },\n\t onYSpecialCase: function(x, y) { return x; }\n\t});\n\n\n    // mulitply: scheme-number scheme-number -> scheme-number\n    var multiply = function(x, y) {\n        var prod;\n        if (typeof(x) === 'number' && typeof(y) === 'number') {\n\t    prod = x * y;\n\t    if (isOverflow(prod)) {\n\t\treturn (makeBignum(x)).multiply(makeBignum(y));\n            } else {\n                return prod;\n            }\n        }\n        if (x instanceof FloatPoint && y instanceof FloatPoint) {\n            return x.multiply(y);\n        }\n        return multiplySlow(x, y);\n    };\n    var multiplySlow = makeNumericBinop(\n\tfunction(x, y) {\n\t    var prod = x * y;\n\t    if (isOverflow(prod)) {\n\t\treturn (makeBignum(x)).multiply(makeBignum(y));\n\t    } else {\n\t\treturn prod;\n\t    }\n\t},\n\tfunction(x, y) {\n\t    return x.multiply(y);\n\t},\n\t{isXSpecialCase: function(x) { \n\t    return (isExactInteger(x) && \n\t\t    (_integerIsZero(x) || _integerIsOne(x) || _integerIsNegativeOne(x))) },\n\t onXSpecialCase: function(x, y) { \n\t     if (_integerIsZero(x))\n\t\t return 0;\n\t     if (_integerIsOne(x))\n\t\t return y;\n\t     if (_integerIsNegativeOne(x))\n\t\t return negate(y);\n\t },\n\t isYSpecialCase: function(y) { \n\t     return (isExactInteger(y) && \n\t\t     (_integerIsZero(y) || _integerIsOne(y) || _integerIsNegativeOne(y)))},\n\t onYSpecialCase: function(x, y) { \n\t     if (_integerIsZero(y))\n\t\t return 0;\n\t     if (_integerIsOne(y))\n\t\t return x;\n\t     if (_integerIsNegativeOne(y)) \n\t\t return negate(x);\n\t }\n\t});\n\n    \n    // divide: scheme-number scheme-number -> scheme-number\n    var divide = makeNumericBinop(\n\tfunction(x, y) {\n\t    if (_integerIsZero(y))\n\t\tthrowRuntimeError(\"/: division by zero\", x, y);\n\t    var div = x / y;\n\t    if (isOverflow(div)) {\n\t\treturn (makeBignum(x)).divide(makeBignum(y));\n\t    } else if (Math.floor(div) !== div) {\n\t\treturn Rational.makeInstance(x, y);\n\t    } else {\n\t\treturn div;\n\t    }\n\t},\n\tfunction(x, y) {\n\t    return x.divide(y);\n\t},\n\t{ isXSpecialCase: function(x) {\n\t    return (eqv(x, 0));\n\t},\n\t  onXSpecialCase: function(x, y) {\n\t      if (eqv(y, 0)) {\n\t\t  throwRuntimeError(\"/: division by zero\", x, y);\n\t      }\n\t      return 0;\n\t  },\n\t  isYSpecialCase: function(y) { \n\t    return (eqv(y, 0)); },\n\t  onYSpecialCase: function(x, y) {\n\t      throwRuntimeError(\"/: division by zero\", x, y);\n\t  }\n\t});\n    \n    \n    // equals: scheme-number scheme-number -> boolean\n    var equals = makeNumericBinop(\n\tfunction(x, y) {\n\t    return x === y;\n\t},\n\tfunction(x, y) {\n\t    return x.equals(y);\n\t});\n\n\n    // eqv: scheme-number scheme-number -> boolean\n    var eqv = function(x, y) {\n\tif (x === y)\n\t    return true;\n\tif (typeof(x) === 'number' && typeof(y) === 'number')\n\t    return x === y;\n\tif (x === NEGATIVE_ZERO || y === NEGATIVE_ZERO)\n\t    return x === y;\n\tif (x instanceof Complex || y instanceof Complex) {\n\t    return (eqv(realPart(x), realPart(y)) &&\n\t\t    eqv(imaginaryPart(x), imaginaryPart(y)));\n\t}\n\tvar ex = isExact(x), ey = isExact(y);\n\treturn (((ex && ey) || (!ex && !ey)) && equals(x, y));\n    };\n\n    // approxEqual: scheme-number scheme-number scheme-number -> boolean\n    var approxEquals = function(x, y, delta) {\n\treturn lessThan(abs(subtract(x, y)),\n                        delta);\n    };\n\n    // greaterThanOrEqual: scheme-number scheme-number -> boolean\n    var greaterThanOrEqual = makeNumericBinop(\n\tfunction(x, y) {\n\t    return x >= y;\n\t},\n\tfunction(x, y) {\n\t    if (!(isReal(x) && isReal(y)))\n\t\tthrowRuntimeError(\n\t\t    \">=: couldn't be applied to complex number\", x, y);\n\t    return x.greaterThanOrEqual(y);\n\t});\n\n\n    // lessThanOrEqual: scheme-number scheme-number -> boolean\n    var lessThanOrEqual = makeNumericBinop(\n\tfunction(x, y){\n\n\t    return x <= y;\n\t},\n\tfunction(x, y) {\n\t    if (!(isReal(x) && isReal(y)))\n\t\tthrowRuntimeError(\"<=: couldn't be applied to complex number\", x, y);\n\t    return x.lessThanOrEqual(y);\n\t});\n\n\n    // greaterThan: scheme-number scheme-number -> boolean\n    var greaterThan = makeNumericBinop(\n\tfunction(x, y){\n\t    return x > y;\n\t},\n\tfunction(x, y) {\n\t    if (!(isReal(x) && isReal(y)))\n\t\tthrowRuntimeError(\">: couldn't be applied to complex number\", x, y);\n\t    return x.greaterThan(y);\n\t});\n\n\n    // lessThan: scheme-number scheme-number -> boolean\n    var lessThan = makeNumericBinop(\n\tfunction(x, y){\n\n\t    return x < y;\n\t},\n\tfunction(x, y) {\n\t    if (!(isReal(x) && isReal(y)))\n\t\tthrowRuntimeError(\"<: couldn't be applied to complex number\", x, y);\n\t    return x.lessThan(y);\n\t});\n\n\n\n    // expt: scheme-number scheme-number -> scheme-number\n    var expt = (function() {\n\tvar _expt = makeNumericBinop(\n\t    function(x, y){\n\t\tvar pow = Math.pow(x, y);\n\t\tif (isOverflow(pow)) {\n\t\t    return (makeBignum(x)).expt(makeBignum(y));\n\t\t} else {\n\t\t    return pow;\n\t\t}\n\t    },\n\t    function(x, y) {\n\t\tif (equals(y, 0)) {\n\t\t    return add(y, 1);\n\t\t} else {\n\t\t    return x.expt(y);\n\t\t}\n\t    });\n\treturn function(x, y) {\n\t    if (equals(y, 0)) \n\t\treturn add(y, 1);\n\t    if (isReal(y) && lessThan(y, 0)) {\n\t\treturn _expt(divide(1, x), negate(y));\n\t    }\n\t    return _expt(x, y);\n\t};\n    })();\n\n\n    // exp: scheme-number -> scheme-number\n    var exp = function(n) {\n\tif ( eqv(n, 0) ) {\n\t\treturn 1;\n\t}\n\tif (typeof(n) === 'number') {\n\t    return FloatPoint.makeInstance(Math.exp(n));\n\t}\n\treturn n.exp();\n    };\n\n\n    // modulo: scheme-number scheme-number -> scheme-number\n    var modulo = function(m, n) {\n\tif (! isInteger(m)) {\n\t    throwRuntimeError('modulo: the first argument '\n\t\t\t      + m + \" is not an integer.\", m, n);\n\t}\n\tif (! isInteger(n)) {\n\t    throwRuntimeError('modulo: the second argument '\n\t\t\t      + n + \" is not an integer.\", m, n);\n\t}\n\tvar result;\n\tif (typeof(m) === 'number') {\n\t    result = m % n;\n\t    if (n < 0) {\n\t\tif (result <= 0)\n\t\t    return result;\n\t\telse\n\t\t    return result + n;\n\t    } else {\n\t\tif (result < 0)\n\t\t    return result + n;\n\t\telse\n\t\t    return result;\n\t    }\n\t}\n\tresult = _integerModulo(floor(m), floor(n));\n\t// The sign of the result should match the sign of n.\n\tif (lessThan(n, 0)) {\n\t    if (lessThanOrEqual(result, 0)) {\n\t\treturn result;\n\t    }\n\t    return add(result, n);\n\n\t} else {\n\t    if (lessThan(result, 0)) {\n\t\treturn add(result, n);\n\t    }\n\t    return result;\n\t}\n    };\n\n\n\n    // numerator: scheme-number -> scheme-number\n    var numerator = function(n) {\n\tif (typeof(n) === 'number')\n\t    return n;\n\treturn n.numerator();\n    };\n\n\n    // denominator: scheme-number -> scheme-number\n    var denominator = function(n) {\n\tif (typeof(n) === 'number')\n\t    return 1;\n\treturn n.denominator();\n    };\n\n    // sqrt: scheme-number -> scheme-number\n    var sqrt = function(n) {\n\tif (typeof(n) === 'number') {\n\t    if (n >= 0) {\n\t\tvar result = Math.sqrt(n);\n\t\tif (Math.floor(result) === result) {\n\t\t    return result;\n\t\t} else {\n\t\t    return FloatPoint.makeInstance(result);\n\t\t}\n\t    } else {\n\t\treturn (Complex.makeInstance(0, sqrt(-n)));\n\t    }\n\t}\n\treturn n.sqrt();\n    };\n\n    // abs: scheme-number -> scheme-number\n    var abs = function(n) {\n\tif (typeof(n) === 'number') {\n\t    return Math.abs(n);\n\t}\n\treturn n.abs();\n    };\n\n    // floor: scheme-number -> scheme-number\n    var floor = function(n) {\n\tif (typeof(n) === 'number')\n\t    return n;\n\treturn n.floor();\n    };\n\n    // ceiling: scheme-number -> scheme-number\n    var ceiling = function(n) {\n\tif (typeof(n) === 'number')\n\t    return n;\n\treturn n.ceiling();\n    };\n\n    // conjugate: scheme-number -> scheme-number\n    var conjugate = function(n) {\n\tif (typeof(n) === 'number')\n\t    return n;\n\treturn n.conjugate();\n    };\n\n    // magnitude: scheme-number -> scheme-number\n    var magnitude = function(n) {\n\tif (typeof(n) === 'number')\n\t    return Math.abs(n);\n\treturn n.magnitude();\n    };\n\n\n    // log: scheme-number -> scheme-number\n    var log = function(n) {\n\tif ( eqv(n, 1) ) {\n\t\treturn 0;\n\t}\n\tif (typeof(n) === 'number') {\n\t    return FloatPoint.makeInstance(Math.log(n));\n\t}\n\treturn n.log();\n    };\n\n    // angle: scheme-number -> scheme-number\n    var angle = function(n) {\n\tif (typeof(n) === 'number') {\n\t    if (n > 0)\n\t\treturn 0;\n\t    else\n\t\treturn FloatPoint.pi;\n\t}\n\treturn n.angle();\n    };\n\n    // tan: scheme-number -> scheme-number\n    var tan = function(n) {\n\tif (eqv(n, 0)) { return 0; }\n\tif (typeof(n) === 'number') {\n\t    return FloatPoint.makeInstance(Math.tan(n));\n\t}\n\treturn n.tan();\n    };\n\n    // atan: scheme-number -> scheme-number\n    var atan = function(n) {\n\tif (eqv(n, 0)) { return 0; }\n\tif (typeof(n) === 'number') {\n\t    return FloatPoint.makeInstance(Math.atan(n));\n\t}\n\treturn n.atan();\n    };\n\n    // cos: scheme-number -> scheme-number\n    var cos = function(n) {\n\tif (eqv(n, 0)) { return 1; }\n\tif (typeof(n) === 'number') {\n\t    return FloatPoint.makeInstance(Math.cos(n));\n\t}\n\treturn n.cos();\n    };\n\n    // sin: scheme-number -> scheme-number\n    var sin = function(n) {\n\tif (eqv(n, 0)) { return 0; }\n\tif (typeof(n) === 'number') {\n\t    return FloatPoint.makeInstance(Math.sin(n));\n\t}\n\treturn n.sin();\n    };\n\n    // acos: scheme-number -> scheme-number\n    var acos = function(n) {\n\tif (eqv(n, 1)) { return 0; }\n\tif (typeof(n) === 'number') {\n\t    return FloatPoint.makeInstance(Math.acos(n));\n\t}\n\treturn n.acos();\n    };\n\n    // asin: scheme-number -> scheme-number\n    var asin = function(n) {\n        if (eqv(n, 0)) { return 0; }\n\tif (typeof(n) === 'number') {\n\t    return FloatPoint.makeInstance(Math.asin(n));\n\t}\n\treturn n.asin();\n    };\n\n    // imaginaryPart: scheme-number -> scheme-number\n    var imaginaryPart = function(n) {\n\tif (typeof(n) === 'number') {\n\t    return 0;\n\t}\n\treturn n.imaginaryPart();\n    };\n\n    // realPart: scheme-number -> scheme-number\n    var realPart = function(n) {\n\tif (typeof(n) === 'number') {\n\t    return n;\n\t}\n\treturn n.realPart();\n    };\n\n    // round: scheme-number -> scheme-number\n    var round = function(n) {\n\tif (typeof(n) === 'number') {\n\t    return n;\n\t}\n\treturn n.round();\n    };\n\n\n\n    // sqr: scheme-number -> scheme-number\n    var sqr = function(x) {\n\treturn multiply(x, x);\n    };\n\n\n    // integerSqrt: scheme-number -> scheme-number\n    var integerSqrt = function(x) {\n\tif (! isInteger(x)) {\n\t    throwRuntimeError('integer-sqrt: the argument ' + x.toString() +\n\t\t\t      \" is not an integer.\", x);\n\t}\n\tif (typeof (x) === 'number') {\n\t    if(x < 0) {\n\t        return Complex.makeInstance(0,\n\t\t\t\t\t    Math.floor(Math.sqrt(-x)))\n\t    } else {\n\t\treturn Math.floor(Math.sqrt(x));\n\t    }\n\t}\n\treturn x.integerSqrt();\n    };\n\n\n    // gcd: scheme-number [scheme-number ...] -> scheme-number\n    var gcd = function(first, rest) {\n\tif (! isInteger(first)) {\n\t    throwRuntimeError('gcd: the argument ' + first.toString() +\n\t\t\t      \" is not an integer.\", first);\n\t}\n\tvar a = abs(first), t, b;\n\tfor(var i = 0; i < rest.length; i++) {\n\t    b = abs(rest[i]);\t\n\t    if (! isInteger(b)) {\n\t\tthrowRuntimeError('gcd: the argument ' + b.toString() +\n\t\t\t\t  \" is not an integer.\", b);\n\t    }\n\t    while (! _integerIsZero(b)) {\n\t\tt = a;\n\t\ta = b;\n\t\tb = _integerModulo(t, b);\n\t    }\n\t}\n\treturn a;\n    };\n\n    // lcm: scheme-number [scheme-number ...] -> scheme-number\n    var lcm = function(first, rest) {\n\tif (! isInteger(first)) {\n\t    throwRuntimeError('lcm: the argument ' + first.toString() +\n\t\t\t      \" is not an integer.\", first);\n\t}\n\tvar result = abs(first);\n\tif (_integerIsZero(result)) { return 0; }\n\tfor (var i = 0; i < rest.length; i++) {\n\t    if (! isInteger(rest[i])) {\n\t\tthrowRuntimeError('lcm: the argument ' + rest[i].toString() +\n\t\t\t\t  \" is not an integer.\", rest[i]);\n\t    }\n\t    var divisor = _integerGcd(result, rest[i]);\n\t    if (_integerIsZero(divisor)) {\n\t\treturn 0;\n\t    }\n\t    result = divide(multiply(result, rest[i]), divisor);\n\t}\n\treturn result;\n    };\n    \n\n    var quotient = function(x, y) {\n \tif (! isInteger(x)) {\n\t    throwRuntimeError('quotient: the first argument ' + x.toString() +\n\t\t\t      \" is not an integer.\", x);\n\t}\n\tif (! isInteger(y)) {\n\t    throwRuntimeError('quotient: the second argument ' + y.toString() +\n\t\t\t      \" is not an integer.\", y);\n\t}\n\treturn _integerQuotient(x, y);\n    };\n\n    \n    var remainder = function(x, y) {\n\tif (! isInteger(x)) {\n\t    throwRuntimeError('remainder: the first argument ' + x.toString() +\n\t\t\t      \" is not an integer.\", x);\n\t}\n\tif (! isInteger(y)) {\n\t    throwRuntimeError('remainder: the second argument ' + y.toString() +\n\t\t\t      \" is not an integer.\", y);\n\t}\n\treturn _integerRemainder(x, y);\n    };\n\n\n    // Implementation of the hyperbolic functions\n    // http://en.wikipedia.org/wiki/Hyperbolic_cosine\n    var cosh = function(x) {\n\tif (eqv(x, 0)) {\n\t    return FloatPoint.makeInstance(1.0);\n\t}\n\treturn divide(add(exp(x), exp(negate(x))),\n\t\t      2);\n    };\n\t\n    var sinh = function(x) {\n\treturn divide(subtract(exp(x), exp(negate(x))),\n\t\t      2);\n    };\n\n\n        \n    var makeComplexPolar = function(r, theta) {\n\t// special case: if theta is zero, just return\n\t// the scalar.\n\tif (eqv(theta, 0)) {\n\t    return r;\n\t}\n\treturn Complex.makeInstance(multiply(r, cos(theta)),\n\t\t\t\t    multiply(r, sin(theta)));\n    };\n\n\n\n    //////////////////////////////////////////////////////////////////////\n\n    // Helpers\n\n\n    // IsFinite: scheme-number -> boolean\n    // Returns true if the scheme number is finite or not.\n    var isSchemeNumberFinite = function(n) {\n\tif (typeof(n) === 'number') {\n\t    return isFinite(n);\n\t} else {\n\t    return n.isFinite();\n\t}\n    };\n\n    // isOverflow: javascript-number -> boolean\n    // Returns true if we consider the number an overflow.\n    var MIN_FIXNUM = -(9e15);\n    var MAX_FIXNUM = (9e15);\n    var isOverflow = function(n) {\n\treturn (n < MIN_FIXNUM ||  MAX_FIXNUM < n);\n    };\n\n\n    // negate: scheme-number -> scheme-number\n    // multiplies a number times -1.\n    var negate = function(n) {\n\tif (typeof(n) === 'number') {\n\t    return -n;\n\t}\n\treturn n.negate();\n    };\n\n\n    // halve: scheme-number -> scheme-number\n    // Divide a number by 2.\n    var halve = function(n) {\n\treturn divide(n, 2);\n    };\n\n\n    // timesI: scheme-number scheme-number\n    // multiplies a number times i.\n    var timesI = function(x) {\n\treturn multiply(x, plusI);\n    };\n\n\n    // fastExpt: computes n^k by squaring.\n    // n^k = (n^2)^(k/2)\n    // Assumes k is non-negative integer.\n    var fastExpt = function(n, k) {\n\tvar acc = 1;\n\twhile (true) {\n\t    if (_integerIsZero(k)) {\n\t\treturn acc;\n\t    }\n\t    if (equals(modulo(k, 2), 0)) {\n\t\tn = multiply(n, n);\n\t\tk = divide(k, 2);\n\t    } else {\n\t\tacc = multiply(acc, n);\n\t\tk = subtract(k, 1);\n\t    }\n\t}\n    };\n\n\n\n    //////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////\n\n\n    // Integer operations\n    // Integers are either represented as fixnums or as BigIntegers.\n\n    // makeIntegerBinop: (fixnum fixnum -> X) (BigInteger BigInteger -> X) -> X\n    // Helper to collect the common logic for coersing integer fixnums or bignums to a\n    // common type before doing an operation.\n    var makeIntegerBinop = function(onFixnums, onBignums, options) {\n\toptions = options || {};\n\treturn (function(m, n) {\n\t    if (m instanceof Rational) {\n\t\tm = numerator(m);\n\t    } else if (m instanceof Complex) {\n\t\tm = realPart(m);\n\t    }\n\n\t    if (n instanceof Rational) {\n\t\tn = numerator(n);\n\t    }else if (n instanceof Complex) {\n\t\tn = realPart(n);\n\t    }\n\n\t    if (typeof(m) === 'number' && typeof(n) === 'number') {\n\t\tvar result = onFixnums(m, n);\n\t\tif (! isOverflow(result) ||\n\t\t    (options.ignoreOverflow)) {\n\t\t    return result;\n\t\t}\n\t    }\n\t    if (m instanceof FloatPoint || n instanceof FloatPoint) {\n\t\tif (options.doNotCoerseToFloating) {\n\t\t    return onFixnums(toFixnum(m), toFixnum(n));\n\t\t}\n\t\telse {\n\t\t    return FloatPoint.makeInstance(\n\t\t\tonFixnums(toFixnum(m), toFixnum(n)));\n\t\t}\n\t    }\n\t    if (typeof(m) === 'number') {\n\t\tm = makeBignum(m);\n\t    }\n\t    if (typeof(n) === 'number') {\n\t\tn = makeBignum(n);\n\t    }\n\t    return onBignums(m, n);\n\t});\n    };\n\n\n    var makeIntegerUnOp = function(onFixnums, onBignums, options) {\n\toptions = options || {};\n\treturn (function(m) {\n\t    if (m instanceof Rational) {\n\t\tm = numerator(m);\n\t    } else if (m instanceof Complex) {\n\t\tm = realPart(m);\n\t    }\n\n\t    if (typeof(m) === 'number') {\n\t\tvar result = onFixnums(m);\n\t\tif (! isOverflow(result) ||\n\t\t    (options.ignoreOverflow)) {\n\t\t    return result;\n\t\t}\n\t    }\n\t    if (m instanceof FloatPoint) {\n\t\treturn onFixnums(toFixnum(m));\n\t    }\n\t    if (typeof(m) === 'number') {\n\t\tm = makeBignum(m);\n\t    }\n\t    return onBignums(m);\n\t});\n    };\n\n\n\n    // _integerModulo: integer-scheme-number integer-scheme-number -> integer-scheme-number\n    var _integerModulo = makeIntegerBinop(\n\tfunction(m, n) {\n\t    return m % n;\n\t},\n\tfunction(m, n) {\n\t    return bnMod.call(m, n);\n\t});\n\n\n    // _integerGcd: integer-scheme-number integer-scheme-number -> integer-scheme-number\n    var _integerGcd = makeIntegerBinop(\n\tfunction(a, b) {\n\t    var t;\n\t    while (b !== 0) {\n\t\tt = a;\n\t\ta = b;\n\t\tb = t % b;\n\t    }\n\t    return a;\n\t},\n\tfunction(m, n) {\n\t    return bnGCD.call(m, n);\n\t});\n\n\n    // _integerIsZero: integer-scheme-number -> boolean\n    // Returns true if the number is zero.\n    var _integerIsZero = makeIntegerUnOp(\n\tfunction(n){\n\t    return n === 0;\n\t},\n\tfunction(n) {\n\t    return bnEquals.call(n, BigInteger.ZERO);\n\t}\n    );\n\n\n    // _integerIsOne: integer-scheme-number -> boolean\n    var _integerIsOne = makeIntegerUnOp(\n\tfunction(n) {\n\t    return n === 1;\n\t},\n\tfunction(n) {\n\t    return bnEquals.call(n, BigInteger.ONE);\n\t});\n    \n\n \n    // _integerIsNegativeOne: integer-scheme-number -> boolean\n    var _integerIsNegativeOne = makeIntegerUnOp(\n\tfunction(n) {\n\t    return n === -1;\n\t},\n\tfunction(n) {\n\t    return bnEquals.call(n, BigInteger.NEGATIVE_ONE);\n\t});\n    \n\n\n    // _integerAdd: integer-scheme-number integer-scheme-number -> integer-scheme-number\n    var _integerAdd = makeIntegerBinop(\n\tfunction(m, n) {\n\t    return m + n;\n\t},\n\tfunction(m, n) {\n\t    return bnAdd.call(m, n);\n\t});\n\n    // _integerSubtract: integer-scheme-number integer-scheme-number -> integer-scheme-number\n    var _integerSubtract = makeIntegerBinop(\n\tfunction(m, n) {\n\t    return m - n;\n\t},\n\tfunction(m, n) {\n\t    return bnSubtract.call(m, n);\n\t});\n\n    // _integerMultiply: integer-scheme-number integer-scheme-number -> integer-scheme-number\n    var _integerMultiply = makeIntegerBinop(\n\tfunction(m, n) {\n\t    return m * n;\n\t},\n\tfunction(m, n) {\n\t    return bnMultiply.call(m, n);\n\t});\n\n    //_integerQuotient: integer-scheme-number integer-scheme-number -> integer-scheme-number\n    var _integerQuotient = makeIntegerBinop(\n\tfunction(m, n) {\n\t    return ((m - (m % n))/ n);\n\t},\n\tfunction(m, n) {\n            return bnDivide.call(m, n);\n\t});\n\n    var _integerRemainder = makeIntegerBinop(\n\tfunction(m, n) {\n\t    return m % n;\n\t},\n\tfunction(m, n) {\n\t    return bnRemainder.call(m, n);\n\t});\n\n\n    // _integerDivideToFixnum: integer-scheme-number integer-scheme-number -> fixnum\n    var _integerDivideToFixnum = makeIntegerBinop(\n\tfunction(m, n) {\n\t    return m / n;\n\t},\n\tfunction(m, n) {\n\t    return toFixnum(m) / toFixnum(n);\n\t},\n\t{ignoreOverflow: true,\n\t doNotCoerseToFloating: true});\n\n\n    // _integerEquals: integer-scheme-number integer-scheme-number -> boolean\n    var _integerEquals = makeIntegerBinop(\n\tfunction(m, n) {\n\t    return m === n;\n\t},\n\tfunction(m, n) {\n\t    return bnEquals.call(m, n);\n\t},\n\t{doNotCoerseToFloating: true});\n\n    // _integerGreaterThan: integer-scheme-number integer-scheme-number -> boolean\n    var _integerGreaterThan = makeIntegerBinop(\n\tfunction(m, n) {\n\t    return m > n;\n\t},\n\tfunction(m, n) {\n\t    return bnCompareTo.call(m, n) > 0;\n\t},\n\t{doNotCoerseToFloating: true});\n\n    // _integerLessThan: integer-scheme-number integer-scheme-number -> boolean\n    var _integerLessThan = makeIntegerBinop(\n\tfunction(m, n) {\n\t    return m < n;\n\t},\n\tfunction(m, n) {\n\t    return bnCompareTo.call(m, n) < 0;\n\t},\n\t{doNotCoerseToFloating: true});\n\n    // _integerGreaterThanOrEqual: integer-scheme-number integer-scheme-number -> boolean\n    var _integerGreaterThanOrEqual = makeIntegerBinop(\n\tfunction(m, n) {\n\t    return m >= n;\n\t},\n\tfunction(m, n) {\n\t    return bnCompareTo.call(m, n) >= 0;\n\t},\n\t{doNotCoerseToFloating: true});\n\n    // _integerLessThanOrEqual: integer-scheme-number integer-scheme-number -> boolean\n    var _integerLessThanOrEqual = makeIntegerBinop(\n\tfunction(m, n) {\n\t    return m <= n;\n\t},\n\tfunction(m, n) {\n\t    return bnCompareTo.call(m, n) <= 0;\n\t},\n\t{doNotCoerseToFloating: true});\n\n\n\n    //////////////////////////////////////////////////////////////////////\n    // The boxed number types are expected to implement the following\n    // interface.\n    //\n    // toString: -> string\n\n    // level: number\n\n    // liftTo: scheme-number -> scheme-number\n\n    // isFinite: -> boolean\n\n    // isInteger: -> boolean\n    // Produce true if this number can be coersed into an integer.\n\n    // isRational: -> boolean\n    // Produce true if the number is rational.\n\n    // isReal: -> boolean\n    // Produce true if the number is real.\n\n    // isExact: -> boolean\n    // Produce true if the number is exact\n\n    // toExact: -> scheme-number\n    // Produce an exact number.\n\n    // toFixnum: -> javascript-number\n    // Produce a javascript number.\n\n    // greaterThan: scheme-number -> boolean\n    // Compare against instance of the same type.\n\n    // greaterThanOrEqual: scheme-number -> boolean\n    // Compare against instance of the same type.\n\n    // lessThan: scheme-number -> boolean\n    // Compare against instance of the same type.\n\n    // lessThanOrEqual: scheme-number -> boolean\n    // Compare against instance of the same type.\n\n    // add: scheme-number -> scheme-number\n    // Add with an instance of the same type.\n\n    // subtract: scheme-number -> scheme-number\n    // Subtract with an instance of the same type.\n\n    // multiply: scheme-number -> scheme-number\n    // Multiply with an instance of the same type.\n\n    // divide: scheme-number -> scheme-number\n    // Divide with an instance of the same type.\n\n    // numerator: -> scheme-number\n    // Return the numerator.\n\n    // denominator: -> scheme-number\n    // Return the denominator.\n\n    // integerSqrt: -> scheme-number\n    // Produce the integer square root.\n\n    // sqrt: -> scheme-number\n    // Produce the square root.\n\n    // abs: -> scheme-number\n    // Produce the absolute value.\n\n    // floor: -> scheme-number\n    // Produce the floor.\n\n    // ceiling: -> scheme-number\n    // Produce the ceiling.\n\n    // conjugate: -> scheme-number\n    // Produce the conjugate.\n\n    // magnitude: -> scheme-number\n    // Produce the magnitude.\n\n    // log: -> scheme-number\n    // Produce the log.\n\n    // angle: -> scheme-number\n    // Produce the angle.\n\n    // atan: -> scheme-number\n    // Produce the arc tangent.\n\n    // cos: -> scheme-number\n    // Produce the cosine.\n\n    // sin: -> scheme-number\n    // Produce the sine.\n\n    // expt: scheme-number -> scheme-number\n    // Produce the power to the input.\n\n    // exp: -> scheme-number\n    // Produce e raised to the given power.\n\n    // acos: -> scheme-number\n    // Produce the arc cosine.\n\n    // asin: -> scheme-number\n    // Produce the arc sine.\n\n    // imaginaryPart: -> scheme-number\n    // Produce the imaginary part\n\n    // realPart: -> scheme-number\n    // Produce the real part.\n\n    // round: -> scheme-number\n    // Round to the nearest integer.\n\n    // equals: scheme-number -> boolean\n    // Produce true if the given number of the same type is equal.\n\n\n\n    //////////////////////////////////////////////////////////////////////\n\n    // Rationals\n\n\n    var Rational = function(n, d) {\n\tthis.n = n;\n\tthis.d = d;\n    };\n\n\n    Rational.prototype.toString = function() {\n\tif (_integerIsOne(this.d)) {\n\t    return this.n.toString() + \"\";\n\t} else {\n\t    return this.n.toString() + \"/\" + this.d.toString();\n\t}\n    };\n\n\n    Rational.prototype.level = 1;\n\n\n    Rational.prototype.liftTo = function(target) {\n\tif (target.level === 2)\n\t    return new FloatPoint(\n\t\t_integerDivideToFixnum(this.n, this.d));\n\tif (target.level === 3)\n\t    return new Complex(this, 0);\n\treturn throwRuntimeError(\"invalid level of Number\", this, target);\n    };\n\n    Rational.prototype.isFinite = function() {\n\treturn true;\n    };\n\n    Rational.prototype.equals = function(other) {\n\treturn (other instanceof Rational &&\n\t\t_integerEquals(this.n, other.n) &&\n\t\t_integerEquals(this.d, other.d));\n    };\n\n\n\n    Rational.prototype.isInteger = function() {\n\treturn _integerIsOne(this.d);\n    };\n\n    Rational.prototype.isRational = function() {\n        return true;\n    };\n\n    Rational.prototype.isReal = function() {\n\treturn true;\n    };\n\n\n    Rational.prototype.add = function(other) {\n\treturn Rational.makeInstance(_integerAdd(_integerMultiply(this.n, other.d),\n\t\t\t\t\t\t _integerMultiply(this.d, other.n)),\n\t\t\t\t     _integerMultiply(this.d, other.d));\n    };\n\n    Rational.prototype.subtract = function(other) {\n\treturn Rational.makeInstance(_integerSubtract(_integerMultiply(this.n, other.d),\n\t\t\t\t\t\t      _integerMultiply(this.d, other.n)),\n\t\t\t\t     _integerMultiply(this.d, other.d));\n    };\n\n    Rational.prototype.negate = function() { \n\treturn Rational.makeInstance(-this.n, this.d) \n    };\n\n    Rational.prototype.multiply = function(other) {\n\treturn Rational.makeInstance(_integerMultiply(this.n, other.n),\n\t\t\t\t     _integerMultiply(this.d, other.d));\n    };\n\n    Rational.prototype.divide = function(other) {\n\tif (_integerIsZero(this.d) || _integerIsZero(other.n)) {\n\t    throwRuntimeError(\"/: division by zero\", this, other);\n\t}\n\treturn Rational.makeInstance(_integerMultiply(this.n, other.d),\n\t\t\t\t     _integerMultiply(this.d, other.n));\n    };\n\n\n    Rational.prototype.toExact = function() {\n\treturn this;\n    };\n\n    Rational.prototype.toInexact = function() {\n\treturn FloatPoint.makeInstance(this.toFixnum());\n    };\n\n\n    Rational.prototype.isExact = function() {\n        return true;\n    };\n\n    Rational.prototype.isInexact = function() {\n        return false;\n    };\n\n\n    Rational.prototype.toFixnum = function() {\n\treturn _integerDivideToFixnum(this.n, this.d);\n    };\n\n    Rational.prototype.numerator = function() {\n\treturn this.n;\n    };\n\n    Rational.prototype.denominator = function() {\n\treturn this.d;\n    };\n\n    Rational.prototype.greaterThan = function(other) {\n\treturn _integerGreaterThan(_integerMultiply(this.n, other.d),\n\t\t\t\t   _integerMultiply(this.d, other.n));\n    };\n\n    Rational.prototype.greaterThanOrEqual = function(other) {\n\treturn _integerGreaterThanOrEqual(_integerMultiply(this.n, other.d),\n\t\t\t\t\t  _integerMultiply(this.d, other.n));\n    };\n\n    Rational.prototype.lessThan = function(other) {\n\treturn _integerLessThan(_integerMultiply(this.n, other.d),\n\t\t\t\t_integerMultiply(this.d, other.n));\n    };\n\n    Rational.prototype.lessThanOrEqual = function(other) {\n\treturn _integerLessThanOrEqual(_integerMultiply(this.n, other.d),\n\t\t\t\t       _integerMultiply(this.d, other.n));\n    };\n\n    Rational.prototype.integerSqrt = function() {\n\tvar result = sqrt(this);\n\tif (isRational(result)) {\n\t    return toExact(floor(result));\n\t} else if (isReal(result)) {\n\t    return toExact(floor(result));\n\t} else {\n\t    return Complex.makeInstance(toExact(floor(realPart(result))),\n\t\t\t\t\ttoExact(floor(imaginaryPart(result))));\n\t}\n    };\n\n\n    Rational.prototype.sqrt = function() {\n\tif (_integerGreaterThanOrEqual(this.n,  0)) {\n\t    var newN = sqrt(this.n);\n\t    var newD = sqrt(this.d);\n\t    if (equals(floor(newN), newN) &&\n\t\tequals(floor(newD), newD)) {\n\t\treturn Rational.makeInstance(newN, newD);\n\t    } else {\n\t\treturn FloatPoint.makeInstance(_integerDivideToFixnum(newN, newD));\n\t    }\n\t} else {\n\t    var newN = sqrt(negate(this.n));\n\t    var newD = sqrt(this.d);\n\t    if (equals(floor(newN), newN) &&\n\t\tequals(floor(newD), newD)) {\n\t\treturn Complex.makeInstance(\n\t\t    0,\n\t\t    Rational.makeInstance(newN, newD));\n\t    } else {\n\t\treturn Complex.makeInstance(\n\t\t    0,\n\t\t    FloatPoint.makeInstance(_integerDivideToFixnum(newN, newD)));\n\t    }\n\t}\n    };\n\n    Rational.prototype.abs = function() {\n\treturn Rational.makeInstance(abs(this.n),\n\t\t\t\t     this.d);\n    };\n\n\n    Rational.prototype.floor = function() {\n\tvar quotient = _integerQuotient(this.n, this.d);\n\tif (_integerLessThan(this.n, 0)) {\n\t    return subtract(quotient, 1);\n\t} else {\n\t    return quotient;\n\t}\n    };\n\n\n    Rational.prototype.ceiling = function() {\n\tvar quotient = _integerQuotient(this.n, this.d);\n\tif (_integerLessThan(this.n, 0)) {\n\t    return quotient;\n\t} else {\n\t    return add(quotient, 1);\n\t}\n    };\n\n    Rational.prototype.conjugate = function() {\n\treturn this;\n    };\n\n    Rational.prototype.magnitude = Rational.prototype.abs;\n\n    Rational.prototype.log = function(){\n\treturn FloatPoint.makeInstance(Math.log(this.n / this.d));\n    };\n\n    Rational.prototype.angle = function(){\n\tif (_integerIsZero(this.n))\n\t    return 0;\n\tif (_integerGreaterThan(this.n, 0))\n\t    return 0;\n\telse\n\t    return FloatPoint.pi;\n    };\n\n    Rational.prototype.tan = function(){\n\treturn FloatPoint.makeInstance(Math.tan(_integerDivideToFixnum(this.n, this.d)));\n    };\n\n    Rational.prototype.atan = function(){\n\treturn FloatPoint.makeInstance(Math.atan(_integerDivideToFixnum(this.n, this.d)));\n    };\n\n    Rational.prototype.cos = function(){\n\treturn FloatPoint.makeInstance(Math.cos(_integerDivideToFixnum(this.n, this.d)));\n    };\n\n    Rational.prototype.sin = function(){\n\treturn FloatPoint.makeInstance(Math.sin(_integerDivideToFixnum(this.n, this.d)));\n    };\n\n    Rational.prototype.expt = function(a){\n\tif (isExactInteger(a) && greaterThanOrEqual(a, 0)) {\n\t    return fastExpt(this, a);\n\t}\n\treturn FloatPoint.makeInstance(Math.pow(_integerDivideToFixnum(this.n, this.d),\n\t\t\t\t\t\t_integerDivideToFixnum(a.n, a.d)));\n    };\n\n    Rational.prototype.exp = function(){\n\treturn FloatPoint.makeInstance(Math.exp(_integerDivideToFixnum(this.n, this.d)));\n    };\n\n    Rational.prototype.acos = function(){\n\treturn FloatPoint.makeInstance(Math.acos(_integerDivideToFixnum(this.n, this.d)));\n    };\n\n    Rational.prototype.asin = function(){\n\treturn FloatPoint.makeInstance(Math.asin(_integerDivideToFixnum(this.n, this.d)));\n    };\n\n    Rational.prototype.imaginaryPart = function(){\n\treturn 0;\n    };\n\n    Rational.prototype.realPart = function(){\n\treturn this;\n    };\n\n\n   Rational.prototype.round = function() {\n     var halfintp = equals(this.d, 2);\n     var negativep = _integerLessThan(this.n, 0);\n     var n = this.n;\n     if (negativep) {\n       n = negate(n);\n     }\n     var quo = _integerQuotient(n, this.d);\n     if (halfintp) {\n       // rounding half to away from 0\n       // uncomment following if rounding half to even\n       // if (_integerIsOne(_integerModulo(quo, 2)))\n       quo = add(quo, 1);\n     } else {\n       var rem = _integerRemainder(n, this.d);\n       if (greaterThan(multiply(rem, 2), this.d)) {\n         quo = add(quo, 1);\n       }\n     }\n     if (negativep) {\n       quo = negate(quo);\n     }\n     return quo;\n   };\n\n    Rational.makeInstance = function(n, d) {\n\tif (n === undefined)\n\t    throwRuntimeError(\"n undefined\", n, d);\n\n\tif (d === undefined) { d = 1; }\n\n\tif (_integerIsZero(d)) {\n\t    throwRuntimeError(\"division by zero: \"+n+\"/\"+d);\n\t}\n\n  if (_integerLessThan(d, 0)) {\n\t    n = negate(n);\n\t    d = negate(d);\n\t}\n\n\tvar divisor = _integerGcd(abs(n), abs(d));\n\tn = _integerQuotient(n, divisor);\n\td = _integerQuotient(d, divisor);\n\n\t// Optimization: if we can get around construction the rational\n\t// in favor of just returning n, do it:\n\tif (_integerIsOne(d) || _integerIsZero(n)) {\n\t    return n;\n\t}\n\n\treturn new Rational(n, d);\n    };\n\n\n\n    // Floating Point numbers\n    var FloatPoint = function(n) {\n\tthis.n = n;\n    };\n    FloatPoint = FloatPoint;\n\n\n    var NaN = new FloatPoint(Number.NaN);\n    var inf = new FloatPoint(Number.POSITIVE_INFINITY);\n    var neginf = new FloatPoint(Number.NEGATIVE_INFINITY);\n\n    // We use these two constants to represent the floating-point coersion\n    // of bignums that can't be represented with fidelity.\n    var TOO_POSITIVE_TO_REPRESENT = new FloatPoint(Number.POSITIVE_INFINITY);\n    var TOO_NEGATIVE_TO_REPRESENT = new FloatPoint(Number.NEGATIVE_INFINITY);\n\n    // Negative zero is a distinguished value representing -0.0.\n    // There should only be one instance for -0.0.\n    var NEGATIVE_ZERO = new FloatPoint(-0.0);\n    var INEXACT_ZERO = new FloatPoint(0.0);\n\n    FloatPoint.pi = new FloatPoint(Math.PI);\n    FloatPoint.e = new FloatPoint(Math.E);\n    FloatPoint.nan = NaN;\n    FloatPoint.inf = inf;\n    FloatPoint.neginf = neginf;\n\n    FloatPoint.makeInstance = function(n) {\n\tif (isNaN(n)) {\n\t    return FloatPoint.nan;\n\t} else if (n === Number.POSITIVE_INFINITY) {\n\t    return FloatPoint.inf;\n\t} else if (n === Number.NEGATIVE_INFINITY) {\n\t    return FloatPoint.neginf;\n\t} else if (n === 0) {\n\t    if ((1/n) === -Infinity) {\n\t\treturn NEGATIVE_ZERO;\n\t    } else {\n\t\treturn INEXACT_ZERO;\n\t    }\n\t}\n\treturn new FloatPoint(n);\n    };\n\n\n    FloatPoint.prototype.isExact = function() {\n\treturn false;\n    };\n\n    FloatPoint.prototype.isInexact = function() {\n\treturn true;\n    };\n\n\n    FloatPoint.prototype.isFinite = function() {\n\treturn (isFinite(this.n) ||\n\t\tthis === TOO_POSITIVE_TO_REPRESENT ||\n\t\tthis === TOO_NEGATIVE_TO_REPRESENT);\n    };\n\n\n    FloatPoint.prototype.toExact = function() {\n\t// The precision of ieee is about 16 decimal digits, which we use here.\n\tif (! isFinite(this.n) || isNaN(this.n)) {\n\t    throwRuntimeError(\"toExact: no exact representation for \" + this, this);\n\t}\n\n\tvar stringRep = this.n.toString();\n\tvar match = stringRep.match(/^(.*)\\.(.*)$/);\n\tif (match) {\n\t    var intPart = parseInt(match[1]);\n\t    var fracPart = parseInt(match[2]);\n\t    var tenToDecimalPlaces = Math.pow(10, match[2].length);\n\t    return Rational.makeInstance(Math.round(this.n * tenToDecimalPlaces),\n\t\t\t\t\t tenToDecimalPlaces);\n\t}\n\telse {\n\t    return this.n;\n\t}\n    };\n\n    FloatPoint.prototype.toInexact = function() {\n\treturn this;\n    };\n\n    FloatPoint.prototype.isInexact = function() {\n\treturn true;\n    };\n\n\n    FloatPoint.prototype.level = 2;\n\n\n    FloatPoint.prototype.liftTo = function(target) {\n\tif (target.level === 3)\n\t    return new Complex(this, 0);\n\treturn throwRuntimeError(\"invalid level of Number\", this, target);\n    };\n\n    FloatPoint.prototype.toString = function() {\n\tif (isNaN(this.n))\n\t    return \"+nan.0\";\n\tif (this.n === Number.POSITIVE_INFINITY)\n\t    return \"+inf.0\";\n\tif (this.n === Number.NEGATIVE_INFINITY)\n\t    return \"-inf.0\";\n\tif (this === NEGATIVE_ZERO)\n\t    return \"-0.0\";\n\tvar partialResult = this.n.toString();\n\tif (! partialResult.match('\\\\.')) {\n\t    return partialResult + \".0\";\n\t} else {\n\t    return partialResult;\n\t}\n    };\n\n\n    FloatPoint.prototype.equals = function(other, aUnionFind) {\n\treturn ((other instanceof FloatPoint) &&\n\t\t((this.n === other.n)));\n    };\n\n\n\n    FloatPoint.prototype.isRational = function() {\n        return this.isFinite();\n    };\n\n    FloatPoint.prototype.isInteger = function() {\n\treturn this.isFinite() && this.n === Math.floor(this.n);\n    };\n\n    FloatPoint.prototype.isReal = function() {\n\treturn true;\n    };\n\n\n    // sign: Number -> {-1, 0, 1}\n    var sign = function(n) {\n\tif (lessThan(n, 0)) {\n\t    return -1;\n\t} else if (greaterThan(n, 0)) {\n\t    return 1;\n\t} else if (n === NEGATIVE_ZERO) {\n\t    return -1;\n\t} else {\n\t    return 0;\n\t}\n    };\n\n\n    FloatPoint.prototype.add = function(other) {\n\tif (this.isFinite() && other.isFinite()) {\n\t    return FloatPoint.makeInstance(this.n + other.n);\n\t} else {\n\t    if (isNaN(this.n) || isNaN(other.n)) {\n\t\treturn NaN;\n\t    } else if (this.isFinite() && ! other.isFinite()) {\n\t\treturn other;\n\t    } else if (!this.isFinite() && other.isFinite()) {\n\t\treturn this;\n\t    } else {\n\t\treturn ((sign(this) * sign(other) === 1) ?\n\t\t\tthis : NaN);\n\t    };\n\t}\n    };\n\n    FloatPoint.prototype.subtract = function(other) {\n\tif (this.isFinite() && other.isFinite()) {\n\t    return FloatPoint.makeInstance(this.n - other.n);\n\t} else if (isNaN(this.n) || isNaN(other.n)) {\n\t    return NaN;\n\t} else if (! this.isFinite() && ! other.isFinite()) {\n\t    if (sign(this) === sign(other)) {\n\t\treturn NaN;\n\t    } else {\n\t\treturn this;\n\t    }\n\t} else if (this.isFinite()) {\n\t    return multiply(other, -1);\n\t} else {  // other.isFinite()\n\t    return this;\n\t}\n    };\n\n\n    FloatPoint.prototype.negate = function() {\n\treturn FloatPoint.makeInstance(-this.n);\n    };\n\n    FloatPoint.prototype.multiply = function(other) {\n\treturn FloatPoint.makeInstance(this.n * other.n);\n    };\n\n    FloatPoint.prototype.divide = function(other) {\n        return FloatPoint.makeInstance(this.n / other.n);\n    };\n\n\n    FloatPoint.prototype.toFixnum = function() {\n\treturn this.n;\n    };\n\n    FloatPoint.prototype.numerator = function() {\n\tvar stringRep = this.n.toString();\n\tvar match = stringRep.match(/^(.*)\\.(.*)$/);\n\tif (match) {\n\t    var afterDecimal = parseInt(match[2]);\n\t    var factorToInt = Math.pow(10, match[2].length);\n\t    var extraFactor = _integerGcd(factorToInt, afterDecimal);\n\t    var multFactor = factorToInt / extraFactor;\n\t    return FloatPoint.makeInstance( Math.round(this.n * multFactor) );\n\t} else {\n\t    return this;\n\t}\n    };\n\n    FloatPoint.prototype.denominator = function() {\n\tvar stringRep = this.n.toString();\n\tvar match = stringRep.match(/^(.*)\\.(.*)$/);\n\tif (match) {\n\t    var afterDecimal = parseInt(match[2]);\n\t    var factorToInt = Math.pow(10, match[2].length);\n\t    var extraFactor = _integerGcd(factorToInt, afterDecimal);\n\t    return FloatPoint.makeInstance( Math.round(factorToInt/extraFactor) );\n\t} else {\n\t    return FloatPoint.makeInstance(1);\n\t}\n    };\n\n\n    FloatPoint.prototype.floor = function() {\n\treturn FloatPoint.makeInstance(Math.floor(this.n));\n    };\n\n    FloatPoint.prototype.ceiling = function() {\n\treturn FloatPoint.makeInstance(Math.ceil(this.n));\n    };\n\n\n    FloatPoint.prototype.greaterThan = function(other) {\n\treturn this.n > other.n;\n    };\n\n    FloatPoint.prototype.greaterThanOrEqual = function(other) {\n\treturn this.n >= other.n;\n    };\n\n    FloatPoint.prototype.lessThan = function(other) {\n\treturn this.n < other.n;\n    };\n\n    FloatPoint.prototype.lessThanOrEqual = function(other) {\n\treturn this.n <= other.n;\n    };\n\n\n    FloatPoint.prototype.integerSqrt = function() {\n\tif (this === NEGATIVE_ZERO) { return this; }\n\tif (isInteger(this)) {\n\t    if(this.n >= 0) {\n\t        return FloatPoint.makeInstance(Math.floor(Math.sqrt(this.n)));\n\t    } else {\n\t        return Complex.makeInstance(\n\t\t    INEXACT_ZERO,\n\t\t    FloatPoint.makeInstance(Math.floor(Math.sqrt(-this.n))));\n\t    }\n\t} else {\n\t    throwRuntimeError(\"integerSqrt: can only be applied to an integer\", this);\n\t}\n    };\n\n    FloatPoint.prototype.sqrt = function() {\n\tif (this.n < 0) {\n\t    var result = Complex.makeInstance(\n\t\t0,\n\t\tFloatPoint.makeInstance(Math.sqrt(-this.n)));\n\t    return result;\n\t} else {\n\t    return FloatPoint.makeInstance(Math.sqrt(this.n));\n\t}\n    };\n\n    FloatPoint.prototype.abs = function() {\n\treturn FloatPoint.makeInstance(Math.abs(this.n));\n    };\n\n\n\n    FloatPoint.prototype.log = function(){\n\tif (this.n < 0)\n\t    return (new Complex(this, 0)).log();\n\telse\n\t    return FloatPoint.makeInstance(Math.log(this.n));\n    };\n\n    FloatPoint.prototype.angle = function(){\n\tif (0 === this.n)\n\t    return 0;\n\tif (this.n > 0)\n\t    return 0;\n\telse\n\t    return FloatPoint.pi;\n    };\n\n    FloatPoint.prototype.tan = function(){\n\treturn FloatPoint.makeInstance(Math.tan(this.n));\n    };\n\n    FloatPoint.prototype.atan = function(){\n\treturn FloatPoint.makeInstance(Math.atan(this.n));\n    };\n\n    FloatPoint.prototype.cos = function(){\n\treturn FloatPoint.makeInstance(Math.cos(this.n));\n    };\n\n    FloatPoint.prototype.sin = function(){\n\treturn FloatPoint.makeInstance(Math.sin(this.n));\n    };\n\n    FloatPoint.prototype.expt = function(a){\n\tif (this.n === 1) {\n\t    if (a.isFinite()) {\n\t\treturn this;\n\t    } else if (isNaN(a.n)){\n\t\treturn this;\n\t    } else {\n\t\treturn this;\n\t    }\n\t} else {\n\t    return FloatPoint.makeInstance(Math.pow(this.n, a.n));\n\t}\n    };\n\n    FloatPoint.prototype.exp = function(){\n\treturn FloatPoint.makeInstance(Math.exp(this.n));\n    };\n\n    FloatPoint.prototype.acos = function(){\n\treturn FloatPoint.makeInstance(Math.acos(this.n));\n    };\n\n    FloatPoint.prototype.asin = function(){\n\treturn FloatPoint.makeInstance(Math.asin(this.n));\n    };\n\n    FloatPoint.prototype.imaginaryPart = function(){\n\treturn 0;\n    };\n\n    FloatPoint.prototype.realPart = function(){\n\treturn this;\n    };\n\n\n    FloatPoint.prototype.round = function(){\n\tif (isFinite(this.n)) {\n\t    if (this === NEGATIVE_ZERO) {\n\t\treturn this;\n\t    }\n\t    if (Math.abs(Math.floor(this.n) - this.n) === 0.5) {\n\t\tif (Math.floor(this.n) % 2 === 0)\n\t\t    return FloatPoint.makeInstance(Math.floor(this.n));\n\t\treturn FloatPoint.makeInstance(Math.ceil(this.n));\n\t    } else {\n\t\treturn FloatPoint.makeInstance(Math.round(this.n));\n\t    }\n\t} else {\n\t    return this;\n\t}\n    };\n\n\n    FloatPoint.prototype.conjugate = function() {\n\treturn this;\n    };\n\n    FloatPoint.prototype.magnitude = FloatPoint.prototype.abs;\n\n\n\n    //////////////////////////////////////////////////////////////////////\n    // Complex numbers\n    //////////////////////////////////////////////////////////////////////\n\n    var Complex = function(r, i){\n\tthis.r = r;\n\tthis.i = i;\n    };\n\n    // Constructs a complex number from two basic number r and i.  r and i can\n    // either be plt.type.Rational or plt.type.FloatPoint.\n    Complex.makeInstance = function(r, i){\n\tif (i === undefined) { i = 0; }\n\tif (isExact(i) && isInteger(i) && _integerIsZero(i)) {\n\t    return r;\n\t}\n\tif (isInexact(r) || isInexact(i)) {\n\t    r = toInexact(r);\n\t    i = toInexact(i);\n\t}\n\treturn new Complex(r, i);\n    };\n\n    Complex.prototype.toString = function() {\n\tvar realPart = this.r.toString(), imagPart = this.i.toString();\n\tif (imagPart[0] === '-' || imagPart[0] === '+') {\n\t    return realPart + imagPart + 'i';\n\t} else {\n\t    return realPart + \"+\" + imagPart + 'i';\n\t}\n    };\n\n\n    Complex.prototype.isFinite = function() {\n\treturn isSchemeNumberFinite(this.r) && isSchemeNumberFinite(this.i);\n    };\n\n\n    Complex.prototype.isRational = function() {\n\treturn isRational(this.r) && eqv(this.i, 0);\n    };\n\n    Complex.prototype.isInteger = function() {\n\treturn (isInteger(this.r) &&\n\t\teqv(this.i, 0));\n    };\n\n    Complex.prototype.toExact = function() {\n\treturn Complex.makeInstance( toExact(this.r), toExact(this.i) );\n    };\n\n    Complex.prototype.toInexact = function() {\n\treturn Complex.makeInstance(toInexact(this.r),\n\t\t\t\t    toInexact(this.i));\n    };\n\n\n    Complex.prototype.isExact = function() {\n        return isExact(this.r) && isExact(this.i);\n    };\n\n\n    Complex.prototype.isInexact = function() {\n\treturn isInexact(this.r) || isInexact(this.i);\n    };\n\n\n    Complex.prototype.level = 3;\n\n\n    Complex.prototype.liftTo = function(target){\n\tthrowRuntimeError(\"Don't know how to lift Complex number\", this, target);\n    };\n\n    Complex.prototype.equals = function(other) {\n\tvar result = ((other instanceof Complex) &&\n\t\t      (equals(this.r, other.r)) &&\n\t\t      (equals(this.i, other.i)));\n\treturn result;\n    };\n\n\n\n    Complex.prototype.greaterThan = function(other) {\n\tif (! this.isReal() || ! other.isReal()) {\n\t    throwRuntimeError(\">: expects argument of type real number\", this, other);\n\t}\n\treturn greaterThan(this.r, other.r);\n    };\n\n    Complex.prototype.greaterThanOrEqual = function(other) {\n\tif (! this.isReal() || ! other.isReal()) {\n\t    throwRuntimeError(\">=: expects argument of type real number\", this, other);\n\t}\n\treturn greaterThanOrEqual(this.r, other.r);\n    };\n\n    Complex.prototype.lessThan = function(other) {\n\tif (! this.isReal() || ! other.isReal()) {\n\t    throwRuntimeError(\"<: expects argument of type real number\", this, other);\n\t}\n\treturn lessThan(this.r, other.r);\n    };\n\n    Complex.prototype.lessThanOrEqual = function(other) {\n\tif (! this.isReal() || ! other.isReal()) {\n\t    throwRuntimeError(\"<=: expects argument of type real number\", this, other);\n\t}\n\treturn lessThanOrEqual(this.r, other.r);\n    };\n\n\n    Complex.prototype.abs = function(){\n\tif (!equals(this.i, 0).valueOf())\n\t    throwRuntimeError(\"abs: expects argument of type real number\", this);\n\treturn abs(this.r);\n    };\n\n    Complex.prototype.toFixnum = function(){\n\tif (!equals(this.i, 0).valueOf())\n\t    throwRuntimeError(\"toFixnum: expects argument of type real number\", this);\n\treturn toFixnum(this.r);\n    };\n\n    Complex.prototype.numerator = function() {\n\tif (!this.isReal())\n\t    throwRuntimeError(\"numerator: can only be applied to real number\", this);\n\treturn numerator(this.n);\n    };\n\n\n    Complex.prototype.denominator = function() {\n\tif (!this.isReal())\n\t    throwRuntimeError(\"floor: can only be applied to real number\", this);\n\treturn denominator(this.n);\n    };\n\n    Complex.prototype.add = function(other){\n\treturn Complex.makeInstance(\n\t    add(this.r, other.r),\n\t    add(this.i, other.i));\n    };\n\n    Complex.prototype.subtract = function(other){\n\treturn Complex.makeInstance(\n\t    subtract(this.r, other.r),\n\t    subtract(this.i, other.i));\n    };\n\n    Complex.prototype.negate = function() {\n\treturn Complex.makeInstance(negate(this.r),\n\t\t\t\t    negate(this.i));\n    };\n\n\n    Complex.prototype.multiply = function(other){\n\t// If the other value is real, just do primitive division\n\tif (other.isReal()) {\n\t    return Complex.makeInstance(\n\t\tmultiply(this.r, other.r),\n\t\tmultiply(this.i, other.r));\n\t}\n\tvar r = subtract(\n\t    multiply(this.r, other.r),\n\t    multiply(this.i, other.i));\n\tvar i = add(\n\t    multiply(this.r, other.i),\n\t    multiply(this.i, other.r));\n\treturn Complex.makeInstance(r, i);\n    };\n\n\n\n\n\n    Complex.prototype.divide = function(other){\n\tvar a, b, c, d, r, x, y;\n\t// If the other value is real, just do primitive division\n\tif (other.isReal()) {\n\t    return Complex.makeInstance(\n\t\tdivide(this.r, other.r),\n\t\tdivide(this.i, other.r));\n\t}\n\n\tif (this.isInexact() || other.isInexact()) {\n\t    // http://portal.acm.org/citation.cfm?id=1039814\n\t    // We currently use Smith's method, though we should\n\t    // probably switch over to Priest's method.\n\t    a = this.r;\n\t    b = this.i;\n\t    c = other.r;\n\t    d = other.i;\n\t    if (lessThanOrEqual(abs(d), abs(c))) {\n\t\tr = divide(d, c);\n\t\tx = divide(add(a, multiply(b, r)),\n\t\t\t   add(c, multiply(d, r)));\n\t\ty = divide(subtract(b, multiply(a, r)),\n\t\t\t   add(c, multiply(d, r)));\n\t    } else {\n\t\tr = divide(c, d);\n\t\tx = divide(add(multiply(a, r), b),\n\t\t\t   add(multiply(c, r), d));\n\t\ty = divide(subtract(multiply(b, r), a),\n\t\t\t   add(multiply(c, r), d));\n\t    }\n\t    return Complex.makeInstance(x, y);\n\t} else {\n\t    var con = conjugate(other);\n\t    var up = multiply(this, con);\n\n\t    // Down is guaranteed to be real by this point.\n\t    var down = realPart(multiply(other, con));\n\n\t    var result = Complex.makeInstance(\n\t\tdivide(realPart(up), down),\n\t\tdivide(imaginaryPart(up), down));\n\t    return result;\n\t}\n    };\n\n    Complex.prototype.conjugate = function(){\n\tvar result = Complex.makeInstance(\n\t    this.r,\n\t    subtract(0, this.i));\n\n\treturn result;\n    };\n\n    Complex.prototype.magnitude = function(){\n\tvar sum = add(\n\t    multiply(this.r, this.r),\n\t    multiply(this.i, this.i));\n\treturn sqrt(sum);\n    };\n\n    Complex.prototype.isReal = function(){\n\treturn eqv(this.i, 0);\n    };\n\n    Complex.prototype.integerSqrt = function() {\n\tif (isInteger(this)) {\n\t    return integerSqrt(this.r);\n\t} else {\n\t    throwRuntimeError(\"integerSqrt: can only be applied to an integer\", this);\n\t}\n    };\n\n    Complex.prototype.sqrt = function(){\n\tif (this.isReal())\n\t    return sqrt(this.r);\n\t// http://en.wikipedia.org/wiki/Square_root#Square_roots_of_negative_and_complex_numbers\n\tvar r_plus_x = add(this.magnitude(), this.r);\n\n\tvar r = sqrt(halve(r_plus_x));\n\n\tvar i = divide(this.i, sqrt(multiply(r_plus_x, 2)));\n\n\n\treturn Complex.makeInstance(r, i);\n    };\n\n    Complex.prototype.log = function(){\n\tvar m = this.magnitude();\n\tvar theta = this.angle();\n\tvar result = add(\n\t    log(m),\n\t    timesI(theta));\n\treturn result;\n    };\n\n    Complex.prototype.angle = function(){\n\tif (this.isReal()) {\n\t    return angle(this.r);\n\t}\n\tif (equals(0, this.r)) {\n\t    var tmp = halve(FloatPoint.pi);\n\t    return greaterThan(this.i, 0) ?\n\t\ttmp : negate(tmp);\n\t} else {\n\t    var tmp = atan(divide(abs(this.i), abs(this.r)));\n\t    if (greaterThan(this.r, 0)) {\n\t\treturn greaterThan(this.i, 0) ?\n\t\t    tmp : negate(tmp);\n\t    } else {\n\t\treturn greaterThan(this.i, 0) ?\n\t\t    subtract(FloatPoint.pi, tmp) : subtract(tmp, FloatPoint.pi);\n\t    }\n\t}\n    };\n\n    var plusI = Complex.makeInstance(0, 1);\n    var minusI = Complex.makeInstance(0, -1);\n\n\n    Complex.prototype.tan = function() {\n\treturn divide(this.sin(), this.cos());\n    };\n\n    Complex.prototype.atan = function(){\n\tif (equals(this, plusI) ||\n\t    equals(this, minusI)) {\n\t    return neginf;\n\t}\n\treturn multiply(\n\t    plusI,\n\t    multiply(\n\t\tFloatPoint.makeInstance(0.5),\n\t\tlog(divide(\n\t\t    add(plusI, this),\n\t\t    add(\n\t\t\tplusI,\n\t\t\tsubtract(0, this))))));\n    };\n\n    Complex.prototype.cos = function(){\n\tif (this.isReal())\n\t    return cos(this.r);\n\tvar iz = timesI(this);\n\tvar iz_negate = negate(iz);\n\n\treturn halve(add(exp(iz), exp(iz_negate)));\n    };\n\n    Complex.prototype.sin = function(){\n\tif (this.isReal())\n\t    return sin(this.r);\n\tvar iz = timesI(this);\n\tvar iz_negate = negate(iz);\n\tvar z2 = Complex.makeInstance(0, 2);\n\tvar exp_negate = subtract(exp(iz), exp(iz_negate));\n\tvar result = divide(exp_negate, z2);\n\treturn result;\n    };\n\n\n    Complex.prototype.expt = function(y){\n\tif (isExactInteger(y) && greaterThanOrEqual(y, 0)) {\n\t    return fastExpt(this, y);\n\t}\n\tvar expo = multiply(y, this.log());\n\treturn exp(expo);\n    };\n\n    Complex.prototype.exp = function(){\n\tvar r = exp(this.r);\n\tvar cos_a = cos(this.i);\n\tvar sin_a = sin(this.i);\n\n\treturn multiply(\n\t    r,\n\t    add(cos_a, timesI(sin_a)));\n    };\n\n    Complex.prototype.acos = function(){\n\tif (this.isReal())\n\t    return acos(this.r);\n\tvar pi_half = halve(FloatPoint.pi);\n\tvar iz = timesI(this);\n\tvar root = sqrt(subtract(1, sqr(this)));\n\tvar l = timesI(log(add(iz, root)));\n\treturn add(pi_half, l);\n    };\n\n    Complex.prototype.asin = function(){\n\tif (this.isReal())\n\t    return asin(this.r);\n\n\tvar oneNegateThisSq =\n\t    subtract(1, sqr(this));\n\tvar sqrtOneNegateThisSq = sqrt(oneNegateThisSq);\n\treturn multiply(2, atan(divide(this,\n\t\t\t\t       add(1, sqrtOneNegateThisSq))));\n    };\n\n    Complex.prototype.ceiling = function(){\n\tif (!this.isReal())\n\t    throwRuntimeError(\"ceiling: can only be applied to real number\", this);\n\treturn ceiling(this.r);\n    };\n\n    Complex.prototype.floor = function(){\n\tif (!this.isReal())\n\t    throwRuntimeError(\"floor: can only be applied to real number\", this);\n\treturn floor(this.r);\n    };\n\n    Complex.prototype.imaginaryPart = function(){\n\treturn this.i;\n    };\n\n    Complex.prototype.realPart = function(){\n\treturn this.r;\n    };\n\n    Complex.prototype.round = function(){\n\tif (!this.isReal())\n\t    throwRuntimeError(\"round: can only be applied to real number\", this);\n\treturn round(this.r);\n    };\n\n\n\n    var hashModifiersRegexp = new RegExp(\"^(#[ei]#[bodx]|#[bodx]#[ei]|#[bodxei])(.*)$\")\n    function rationalRegexp(digits) { return new RegExp(\"^([+-]?[\"+digits+\"]+)/([\"+digits+\"]+)$\"); }\n    function matchComplexRegexp(radix, x) {\n\tvar sign = \"[+-]\";\n\tvar maybeSign = \"[+-]?\";\n\tvar digits = digitsForRadix(radix)\n\tvar expmark = \"[\"+expMarkForRadix(radix)+\"]\"\n\tvar digitSequence = \"[\"+digits+\"]+\"\n\n\tvar unsignedRational = digitSequence+\"/\"+digitSequence\n\tvar rational = maybeSign + unsignedRational\n\n\tvar noDecimal = digitSequence\n\tvar decimalNumOnRight = \"[\"+digits+\"]*\\\\.[\"+digits+\"]+\"\n\tvar decimalNumOnLeft = \"[\"+digits+\"]+\\\\.[\"+digits+\"]*\"\n\n\tvar unsignedDecimal = \"(?:\" + noDecimal + \"|\" + decimalNumOnRight + \"|\" + decimalNumOnLeft + \")\"\n\n\tvar special = \"(?:inf\\.0|nan\\.0|inf\\.f|nan\\.f)\"\n\n\tvar unsignedRealNoExp = \"(?:\" + unsignedDecimal + \"|\" + unsignedRational + \")\"\n\tvar unsignedReal = unsignedRealNoExp + \"(?:\" + expmark + maybeSign + digitSequence + \")?\"\n\tvar unsignedRealOrSpecial = \"(?:\" + unsignedReal + \"|\" + special + \")\"\n\tvar real = \"(?:\" + maybeSign + unsignedReal + \"|\" + sign + special + \")\"\n\n\tvar alt1 = new RegExp(\"^(\" + rational + \")\"\n                             + \"(\" + sign + unsignedRational + \"?)\"\n                             + \"i$\");\n\tvar alt2 = new RegExp(\"^(\" + real + \")?\"\n                             + \"(\" + sign + unsignedRealOrSpecial + \"?)\"\n                             + \"i$\");\n\tvar alt3 = new RegExp(\"^(\" + real + \")@(\" + real + \")$\");\n\n\tvar match1 = x.match(alt1)\n\tvar match2 = x.match(alt2)\n\tvar match3 = x.match(alt3)\n\n\treturn match1 ? match1 :\n\t       match2 ? match2 :\n\t       match3 ? match3 :\n\t     /* else */ false\n    }\n\n    function digitRegexp(digits) { return new RegExp(\"^[+-]?[\"+digits+\"]+$\"); }\n    /**\n    /* NB: !!!! flonum regexp only matches \"X.\", \".X\", or \"X.X\", NOT \"X\", this\n    /* must be separately checked with digitRegexp.\n    /* I know this seems dumb, but the alternative would be that this regexp\n    /* returns six matches, which also seems dumb.\n    /***/\n    function flonumRegexp(digits) {\n\tvar decimalNumOnRight = \"([\"+digits+\"]*)\\\\.([\"+digits+\"]+)\"\n\tvar decimalNumOnLeft = \"([\"+digits+\"]+)\\\\.([\"+digits+\"]*)\"\n\treturn new RegExp(\"^(?:([+-]?)(\" +\n                          decimalNumOnRight+\"|\"+decimalNumOnLeft +\n                          \"))$\");\n    }\n    function scientificPattern(digits, exp_mark) {\n\tvar noDecimal = \"[\"+digits+\"]+\"\n\tvar decimalNumOnRight = \"[\"+digits+\"]*\\\\.[\"+digits+\"]+\"\n\tvar decimalNumOnLeft = \"[\"+digits+\"]+\\\\.[\"+digits+\"]*\"\n\treturn new RegExp(\"^(?:([+-]?\" +\n\t\t\t  \"(?:\"+noDecimal+\"|\"+decimalNumOnRight+\"|\"+decimalNumOnLeft+\")\" +\n\t\t\t  \")[\"+exp_mark+\"]([+-]?[\"+digits+\"]+))$\");\n    }\n\n    function digitsForRadix(radix) {\n\treturn radix === 2  ? \"01\" :\n\t       radix === 8  ? \"0-7\" :\n\t       radix === 10 ? \"0-9\" :\n\t       radix === 16 ? \"0-9a-fA-F\" :\n\t       throwRuntimeError(\"digitsForRadix: invalid radix\", this, radix)\n    }\n\n    function expMarkForRadix(radix) {\n\treturn (radix === 2 || radix === 8 || radix === 10) ? \"defsl\" :\n\t       (radix === 16)                               ? \"sl\" :\n\t       throwRuntimeError(\"expMarkForRadix: invalid radix\", this, radix)\n    }\n\n    function Exactness(i) {\n      this.defaultp = function () { return i == 0; }\n      this.exactp = function () { return i == 1; }\n      this.inexactp = function () { return i == 2; }\n    }\n\n    Exactness.def = new Exactness(0);\n    Exactness.on = new Exactness(1);\n    Exactness.off = new Exactness(2);\n\n    Exactness.prototype.intAsExactp = function () { return this.defaultp() || this.exactp(); };\n    Exactness.prototype.floatAsInexactp = function () { return this.defaultp() || this.inexactp(); };\n\n\n    // fromString: string boolean -> (scheme-number | false)\n    var fromString = function(x, exactness) {\n\tvar radix = 10\n\tvar exactness = typeof exactness === 'undefined' ? Exactness.def :\n\t\t\texactness === true               ? Exactness.on :\n\t\t\texactness === false              ? Exactness.off :\n\t   /* else */  throwRuntimeError( \"exactness must be true or false\"\n                                        , this\n                                        , r) ;\n\n\tvar hMatch = x.toLowerCase().match(hashModifiersRegexp)\n\tif (hMatch) {\n\t    var modifierString = hMatch[1].toLowerCase();\n\n\t    var exactFlag = modifierString.match(new RegExp(\"(#[ei])\"))\n\t    var radixFlag = modifierString.match(new RegExp(\"(#[bodx])\"))\n\n\t    if (exactFlag) {\n\t\tvar f = exactFlag[1].charAt(1)\n\t\texactness = f === 'e' ? Exactness.on :\n\t\t\t    f === 'i' ? Exactness.off :\n\t\t\t // this case is unreachable\n\t\t\t throwRuntimeError(\"invalid exactness flag\", this, r)\n\t    }\n\t    if (radixFlag) {\n\t\tvar f = radixFlag[1].charAt(1)\n\t\tradix = f === 'b' ? 2 :\n            f === 'o' ? 8 :\n            f === 'd' ? 10 :\n            f === 'x' ? 16 :\n\t\t\t // this case is unreachable\n\t\t\tthrowRuntimeError(\"invalid radix flag\", this, r)\n\t    }\n\t}\n\n\tvar numberString = hMatch ? hMatch[2] : x\n\t// if the string begins with a hash modifier, then it must parse as a\n\t// number, an invalid parse is an error, not false. False is returned\n\t// when the item could potentially have been read as a symbol.\n\tvar mustBeANumberp = hMatch ? true : false\n\n\treturn fromStringRaw(numberString, radix, exactness, mustBeANumberp)\n    };\n\n    function fromStringRaw(x, radix, exactness, mustBeANumberp) {\n\tvar cMatch = matchComplexRegexp(radix, x);\n\tif (cMatch) {\n\t  return Complex.makeInstance( fromStringRawNoComplex( cMatch[1] || \"0\"\n\t\t\t\t\t\t\t     , radix\n\t\t\t\t\t\t\t     , exactness\n\t\t\t\t\t\t\t     )\n\t\t\t\t     , fromStringRawNoComplex( cMatch[2] === \"+\" ? \"1\"  :\n\t\t\t\t\t\t\t       cMatch[2] === \"-\" ? \"-1\" :\n\t\t\t\t\t\t\t       cMatch[2]\n\t\t\t\t\t\t\t     , radix\n\t\t\t\t\t\t\t     , exactness\n\t\t\t\t\t\t\t     ));\n\t}\n\n        return fromStringRawNoComplex(x, radix, exactness, mustBeANumberp)\n    }\n\n    function fromStringRawNoComplex(x, radix, exactness, mustBeANumberp) {\n\tvar aMatch = x.match(rationalRegexp(digitsForRadix(radix)));\n\tif (aMatch) {\n\t    return Rational.makeInstance( fromStringRawNoComplex( aMatch[1]\n                                                                , radix\n                                                                , exactness\n                                                                )\n                                        , fromStringRawNoComplex( aMatch[2]\n                                                                , radix\n                                                                , exactness\n                                                                ));\n\t}\n\n\t// Floating point tests\n\tif (x === '+nan.0' || x === '-nan.0')\n\t    return FloatPoint.nan;\n\tif (x === '+inf.0')\n\t    return FloatPoint.inf;\n\tif (x === '-inf.0')\n\t    return FloatPoint.neginf;\n\tif (x === \"-0.0\") {\n\t    return NEGATIVE_ZERO;\n\t}\n\n\tvar fMatch = x.match(flonumRegexp(digitsForRadix(radix)))\n\tif (fMatch) {\n\t    var integralPart = fMatch[3] !== undefined ? fMatch[3] : fMatch[5];\n\t    var fractionalPart = fMatch[4] !== undefined ? fMatch[4] : fMatch[6];\n\t    return parseFloat( fMatch[1]\n                             , integralPart\n                             , fractionalPart\n                             , radix\n                             , exactness\n                             )\n\t}\n\n\tvar sMatch = x.match(scientificPattern( digitsForRadix(radix)\n\t\t\t\t\t      , expMarkForRadix(radix)\n\t\t\t\t\t      ))\n\tif (sMatch) {\n\t    var coefficient = fromStringRawNoComplex(sMatch[1], radix, exactness)\n\t    var exponent = fromStringRawNoComplex(sMatch[2], radix, exactness)\n\t    return multiply(coefficient, expt(radix, exponent));\n\t}\n\n\t// Finally, integer tests.\n\tif (x.match(digitRegexp(digitsForRadix(radix)))) {\n\t    var n = parseInt(x, radix);\n\t    if (isOverflow(n)) {\n\t\treturn makeBignum(x);\n\t    } else if (exactness.intAsExactp()) {\n\t\treturn n;\n\t    } else {\n\t\treturn FloatPoint.makeInstance(n)\n\t    }\n\t} else if (mustBeANumberp) {\n\t    if(x.length===0) throwRuntimeError(\"no digits\");\n\t    throwRuntimeError(\"bad number: \" + x, this);\n\t} else {\n\t    return false;\n\t}\n    };\n\n    function parseFloat(sign, integralPart, fractionalPart, radix, exactness) {\n\tvar sign = (sign == \"-\" ? -1 : 1);\n\tvar integralPartValue = integralPart === \"\"  ? 0  :\n\t\t\t\texactness.intAsExactp() ? parseExactInt(integralPart, radix) :\n\t\t\t\t\t\t\t  parseInt(integralPart, radix)\n\n\tvar fractionalNumerator = fractionalPart === \"\" ? 0 :\n\t\t\t\t  exactness.intAsExactp() ? parseExactInt(fractionalPart, radix) :\n\t\t\t\t\t\t\t    parseInt(fractionalPart, radix)\n\t/* unfortunately, for these next two calculations, `expt` and `divide` */\n\t/* will promote to Bignum and Rational, respectively, but we only want */\n\t/* these if we're parsing in exact mode */\n\tvar fractionalDenominator = exactness.intAsExactp() ? expt(radix, fractionalPart.length) :\n\t\t\t\t\t\t\t      Math.pow(radix, fractionalPart.length)\n\tvar fractionalPartValue = fractionalPart === \"\" ? 0 :\n\t\t\t\t  exactness.intAsExactp() ? divide(fractionalNumerator, fractionalDenominator) :\n\t\t\t\t\t\t\t    fractionalNumerator / fractionalDenominator\n\n\tvar forceInexact = function(o) {\n\t    return typeof o === \"number\" ? FloatPoint.makeInstance(o) :\n\t\t\t\t\t   o.toInexact();\n\t}\n\n\treturn exactness.floatAsInexactp() ? forceInexact(multiply(sign, add( integralPartValue, fractionalPartValue))) :\n\t\t\t\t\t     multiply(sign, add(integralPartValue, fractionalPartValue));\n    }\n\n    function parseExactInt(str, radix) {\n\treturn fromStringRawNoComplex(str, radix, Exactness.on, true);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////\n\n    // The code below comes from Tom Wu's BigInteger implementation:\n\n    // Copyright (c) 2005  Tom Wu\n    // All Rights Reserved.\n    // See \"LICENSE\" for details.\n\n    // Basic JavaScript BN library - subset useful for RSA encryption.\n\n    // Bits per digit\n    var dbits;\n\n    // JavaScript engine analysis\n    var canary = 0xdeadbeefcafe;\n    var j_lm = ((canary&0xffffff)==0xefcafe);\n\n    // (public) Constructor\n    function BigInteger(a,b,c) {\n\tif(a != null)\n\t    if(\"number\" == typeof a) this.fromNumber(a,b,c);\n\telse if(b == null && \"string\" != typeof a) this.fromString(a,256);\n\telse this.fromString(a,b);\n    }\n\n    // return new, unset BigInteger\n    function nbi() { return new BigInteger(null); }\n\n    // am: Compute w_j += (x*this_i), propagate carries,\n    // c is initial carry, returns final carry.\n    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n    // We need to select the fastest one that works in this environment.\n\n    // am1: use a single mult and divide to get the high bits,\n    // max digit bits should be 26 because\n    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n    function am1(i,x,w,j,c,n) {\n\twhile(--n >= 0) {\n\t    var v = x*this[i++]+w[j]+c;\n\t    c = Math.floor(v/0x4000000);\n\t    w[j++] = v&0x3ffffff;\n\t}\n\treturn c;\n    }\n    // am2 avoids a big mult-and-extract completely.\n    // Max digit bits should be <= 30 because we do bitwise ops\n    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n    function am2(i,x,w,j,c,n) {\n\tvar xl = x&0x7fff, xh = x>>15;\n\twhile(--n >= 0) {\n\t    var l = this[i]&0x7fff;\n\t    var h = this[i++]>>15;\n\t    var m = xh*l+h*xl;\n\t    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n\t    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n\t    w[j++] = l&0x3fffffff;\n\t}\n\treturn c;\n    }\n    // Alternately, set max digit bits to 28 since some\n    // browsers slow down when dealing with 32-bit numbers.\n    function am3(i,x,w,j,c,n) {\n\tvar xl = x&0x3fff, xh = x>>14;\n\twhile(--n >= 0) {\n\t    var l = this[i]&0x3fff;\n\t    var h = this[i++]>>14;\n\t    var m = xh*l+h*xl;\n\t    l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n\t    c = (l>>28)+(m>>14)+xh*h;\n\t    w[j++] = l&0xfffffff;\n\t}\n\treturn c;\n    }\n    if(j_lm && (typeof(navigator) !== 'undefined' && navigator.appName == \"Microsoft Internet Explorer\")) {\n\tBigInteger.prototype.am = am2;\n\tdbits = 30;\n    }\n    else if(j_lm && (typeof(navigator) !== 'undefined' && navigator.appName != \"Netscape\")) {\n\tBigInteger.prototype.am = am1;\n\tdbits = 26;\n    }\n    else { // Mozilla/Netscape seems to prefer am3\n\tBigInteger.prototype.am = am3;\n\tdbits = 28;\n    }\n\n    BigInteger.prototype.DB = dbits;\n    BigInteger.prototype.DM = ((1<<dbits)-1);\n    BigInteger.prototype.DV = (1<<dbits);\n\n    var BI_FP = 52;\n    BigInteger.prototype.FV = Math.pow(2,BI_FP);\n    BigInteger.prototype.F1 = BI_FP-dbits;\n    BigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n    // Digit conversions\n    var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    var BI_RC = [];\n    var rr,vv;\n    rr = \"0\".charCodeAt(0);\n    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n    rr = \"a\".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n    rr = \"A\".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n    function int2char(n) { return BI_RM.charAt(n); }\n    function intAt(s,i) {\n\tvar c = BI_RC[s.charCodeAt(i)];\n\treturn (c==null)?-1:c;\n    }\n\n    // (protected) copy this to r\n    function bnpCopyTo(r) {\n\tfor(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n\tr.t = this.t;\n\tr.s = this.s;\n    }\n\n    // (protected) set from integer value x, -DV <= x < DV\n    function bnpFromInt(x) {\n\tthis.t = 1;\n\tthis.s = (x<0)?-1:0;\n\tif(x > 0) this[0] = x;\n\telse if(x < -1) this[0] = x+DV;\n\telse this.t = 0;\n    }\n\n    // return bigint initialized to value\n    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n    // (protected) set from string and radix\n    function bnpFromString(s,b) {\n\tvar k;\n\tif(b == 16) k = 4;\n\telse if(b == 8) k = 3;\n\telse if(b == 256) k = 8; // byte array\n\telse if(b == 2) k = 1;\n\telse if(b == 32) k = 5;\n\telse if(b == 4) k = 2;\n\telse { this.fromRadix(s,b); return; }\n\tthis.t = 0;\n\tthis.s = 0;\n\tvar i = s.length, mi = false, sh = 0;\n\twhile(--i >= 0) {\n\t    var x = (k==8)?s[i]&0xff:intAt(s,i);\n\t    if(x < 0) {\n\t\tif(s.charAt(i) == \"-\") mi = true;\n\t\tcontinue;\n\t    }\n\t    mi = false;\n\t    if(sh == 0)\n\t\tthis[this.t++] = x;\n\t    else if(sh+k > this.DB) {\n\t\tthis[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n\t\tthis[this.t++] = (x>>(this.DB-sh));\n\t    }\n\t    else\n\t\tthis[this.t-1] |= x<<sh;\n\t    sh += k;\n\t    if(sh >= this.DB) sh -= this.DB;\n\t}\n\tif(k == 8 && (s[0]&0x80) != 0) {\n\t    this.s = -1;\n\t    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n\t}\n\tthis.clamp();\n\tif(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) clamp off excess high words\n    function bnpClamp() {\n\tvar c = this.s&this.DM;\n\twhile(this.t > 0 && this[this.t-1] == c) --this.t;\n    }\n\n    // (public) return string representation in given radix\n    function bnToString(b) {\n\tif(this.s < 0) return \"-\"+this.negate().toString(b);\n\tvar k;\n\tif(b == 16) k = 4;\n\telse if(b == 8) k = 3;\n\telse if(b == 2) k = 1;\n\telse if(b == 32) k = 5;\n\telse if(b == 4) k = 2;\n\telse return this.toRadix(b);\n\tvar km = (1<<k)-1, d, m = false, r = [], i = this.t;\n\tvar p = this.DB-(i*this.DB)%k;\n\tif(i-- > 0) {\n\t    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r.push(int2char(d)); }\n\t    while(i >= 0) {\n\t\tif(p < k) {\n\t\t    d = (this[i]&((1<<p)-1))<<(k-p);\n\t\t    d |= this[--i]>>(p+=this.DB-k);\n\t\t}\n\t\telse {\n\t\t    d = (this[i]>>(p-=k))&km;\n\t\t    if(p <= 0) { p += this.DB; --i; }\n\t\t}\n\t\tif(d > 0) m = true;\n\t\tif(m) r.push(int2char(d));\n\t    }\n\t}\n\treturn m?r.join(\"\"):\"0\";\n    }\n\n    // (public) -this\n    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n    // (public) |this|\n    function bnAbs() { return (this.s<0)?this.negate():this; }\n\n    // (public) return + if this > a, - if this < a, 0 if equal\n    function bnCompareTo(a) {\n\tvar r = this.s-a.s;\n\tif(r != 0) return r;\n\tvar i = this.t;\n\tif ( this.s < 0 ) {\n\t\tr = a.t - i;\n\t}\n\telse {\n\t\tr = i - a.t;\n\t}\n\tif(r != 0) return r;\n\twhile(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n\treturn 0;\n    }\n\n    // returns bit length of the integer x\n    function nbits(x) {\n\tvar r = 1, t;\n\tif((t=x>>>16) != 0) { x = t; r += 16; }\n\tif((t=x>>8) != 0) { x = t; r += 8; }\n\tif((t=x>>4) != 0) { x = t; r += 4; }\n\tif((t=x>>2) != 0) { x = t; r += 2; }\n\tif((t=x>>1) != 0) { x = t; r += 1; }\n\treturn r;\n    }\n\n    // (public) return the number of bits in \"this\"\n    function bnBitLength() {\n\tif(this.t <= 0) return 0;\n\treturn this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n    }\n\n    // (protected) r = this << n*DB\n    function bnpDLShiftTo(n,r) {\n\tvar i;\n\tfor(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n\tfor(i = n-1; i >= 0; --i) r[i] = 0;\n\tr.t = this.t+n;\n\tr.s = this.s;\n    }\n\n    // (protected) r = this >> n*DB\n    function bnpDRShiftTo(n,r) {\n\tfor(var i = n; i < this.t; ++i) r[i-n] = this[i];\n\tr.t = Math.max(this.t-n,0);\n\tr.s = this.s;\n    }\n\n    // (protected) r = this << n\n    function bnpLShiftTo(n,r) {\n\tvar bs = n%this.DB;\n\tvar cbs = this.DB-bs;\n\tvar bm = (1<<cbs)-1;\n\tvar ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n\tfor(i = this.t-1; i >= 0; --i) {\n\t    r[i+ds+1] = (this[i]>>cbs)|c;\n\t    c = (this[i]&bm)<<bs;\n\t}\n\tfor(i = ds-1; i >= 0; --i) r[i] = 0;\n\tr[ds] = c;\n\tr.t = this.t+ds+1;\n\tr.s = this.s;\n\tr.clamp();\n    }\n\n    // (protected) r = this >> n\n    function bnpRShiftTo(n,r) {\n\tr.s = this.s;\n\tvar ds = Math.floor(n/this.DB);\n\tif(ds >= this.t) { r.t = 0; return; }\n\tvar bs = n%this.DB;\n\tvar cbs = this.DB-bs;\n\tvar bm = (1<<bs)-1;\n\tr[0] = this[ds]>>bs;\n\tfor(var i = ds+1; i < this.t; ++i) {\n\t    r[i-ds-1] |= (this[i]&bm)<<cbs;\n\t    r[i-ds] = this[i]>>bs;\n\t}\n\tif(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n\tr.t = this.t-ds;\n\tr.clamp();\n    }\n\n    // (protected) r = this - a\n    function bnpSubTo(a,r) {\n\tvar i = 0, c = 0, m = Math.min(a.t,this.t);\n\twhile(i < m) {\n\t    c += this[i]-a[i];\n\t    r[i++] = c&this.DM;\n\t    c >>= this.DB;\n\t}\n\tif(a.t < this.t) {\n\t    c -= a.s;\n\t    while(i < this.t) {\n\t\tc += this[i];\n\t\tr[i++] = c&this.DM;\n\t\tc >>= this.DB;\n\t    }\n\t    c += this.s;\n\t}\n\telse {\n\t    c += this.s;\n\t    while(i < a.t) {\n\t\tc -= a[i];\n\t\tr[i++] = c&this.DM;\n\t\tc >>= this.DB;\n\t    }\n\t    c -= a.s;\n\t}\n\tr.s = (c<0)?-1:0;\n\tif(c < -1) r[i++] = this.DV+c;\n\telse if(c > 0) r[i++] = c;\n\tr.t = i;\n\tr.clamp();\n    }\n\n    // (protected) r = this * a, r != this,a (HAC 14.12)\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyTo(a,r) {\n\tvar x = this.abs(), y = a.abs();\n\tvar i = x.t;\n\tr.t = i+y.t;\n\twhile(--i >= 0) r[i] = 0;\n\tfor(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n\tr.s = 0;\n\tr.clamp();\n\tif(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (protected) r = this^2, r != this (HAC 14.16)\n    function bnpSquareTo(r) {\n\tvar x = this.abs();\n\tvar i = r.t = 2*x.t;\n\twhile(--i >= 0) r[i] = 0;\n\tfor(i = 0; i < x.t-1; ++i) {\n\t    var c = x.am(i,x[i],r,2*i,0,1);\n\t    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n\t\tr[i+x.t] -= x.DV;\n\t\tr[i+x.t+1] = 1;\n\t    }\n\t}\n\tif(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n\tr.s = 0;\n\tr.clamp();\n    }\n\n\n    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n    // r != q, this != m.  q or r may be null.\n    function bnpDivRemTo(m,q,r) {\n\tvar pm = m.abs();\n\tif(pm.t <= 0) return;\n\tvar pt = this.abs();\n\tif(pt.t < pm.t) {\n\t    if(q != null) q.fromInt(0);\n\t    if(r != null) this.copyTo(r);\n\t    return;\n\t}\n\tif(r == null) r = nbi();\n\tvar y = nbi(), ts = this.s, ms = m.s;\n\tvar nsh = this.DB-nbits(pm[pm.t-1]);\t// normalize modulus\n\tif(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n\telse { pm.copyTo(y); pt.copyTo(r); }\n\tvar ys = y.t;\n\tvar y0 = y[ys-1];\n\tif(y0 == 0) return;\n\tvar yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n\tvar d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n\tvar i = r.t, j = i-ys, t = (q==null)?nbi():q;\n\ty.dlShiftTo(j,t);\n\tif(r.compareTo(t) >= 0) {\n\t    r[r.t++] = 1;\n\t    r.subTo(t,r);\n\t}\n\tBigInteger.ONE.dlShiftTo(ys,t);\n\tt.subTo(y,y);\t// \"negative\" y so we can replace sub with am later\n\twhile(y.t < ys) y[y.t++] = 0;\n\twhile(--j >= 0) {\n\t    // Estimate quotient digit\n\t    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n\t    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {\t// Try it out\n\t\ty.dlShiftTo(j,t);\n\t\tr.subTo(t,r);\n\t\twhile(r[i] < --qd) r.subTo(t,r);\n\t    }\n\t}\n\tif(q != null) {\n\t    r.drShiftTo(ys,q);\n\t    if(ts != ms) BigInteger.ZERO.subTo(q,q);\n\t}\n\tr.t = ys;\n\tr.clamp();\n\tif(nsh > 0) r.rShiftTo(nsh,r);\t// Denormalize remainder\n\tif(ts < 0) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (public) this mod a\n    function bnMod(a) {\n\tvar r = nbi();\n\tthis.abs().divRemTo(a,null,r);\n\tif(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n\treturn r;\n    }\n\n    // Modular reduction using \"classic\" algorithm\n    function Classic(m) { this.m = m; }\n    function cConvert(x) {\n\tif(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n\telse return x;\n    }\n    function cRevert(x) { return x; }\n    function cReduce(x) { x.divRemTo(this.m,null,x); }\n    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    Classic.prototype.convert = cConvert;\n    Classic.prototype.revert = cRevert;\n    Classic.prototype.reduce = cReduce;\n    Classic.prototype.mulTo = cMulTo;\n    Classic.prototype.sqrTo = cSqrTo;\n\n    // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n    // justification:\n    //         xy == 1 (mod m)\n    //         xy =  1+km\n    //   xy(2-xy) = (1+km)(1-km)\n    // x[y(2-xy)] = 1-k^2m^2\n    // x[y(2-xy)] == 1 (mod m^2)\n    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n    // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n    function bnpInvDigit() {\n\tif(this.t < 1) return 0;\n\tvar x = this[0];\n\tif((x&1) == 0) return 0;\n\tvar y = x&3;\t\t// y == 1/x mod 2^2\n\ty = (y*(2-(x&0xf)*y))&0xf;\t// y == 1/x mod 2^4\n\ty = (y*(2-(x&0xff)*y))&0xff;\t// y == 1/x mod 2^8\n\ty = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;\t// y == 1/x mod 2^16\n\t// last step - calculate inverse mod DV directly;\n\t// assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\ty = (y*(2-x*y%this.DV))%this.DV;\t\t// y == 1/x mod 2^dbits\n\t// we really want the negative inverse, and -DV < y < DV\n\treturn (y>0)?this.DV-y:-y;\n    }\n\n    // Montgomery reduction\n    function Montgomery(m) {\n\tthis.m = m;\n\tthis.mp = m.invDigit();\n\tthis.mpl = this.mp&0x7fff;\n\tthis.mph = this.mp>>15;\n\tthis.um = (1<<(m.DB-15))-1;\n\tthis.mt2 = 2*m.t;\n    }\n\n    // xR mod m\n    function montConvert(x) {\n\tvar r = nbi();\n\tx.abs().dlShiftTo(this.m.t,r);\n\tr.divRemTo(this.m,null,r);\n\tif(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n\treturn r;\n    }\n\n    // x/R mod m\n    function montRevert(x) {\n\tvar r = nbi();\n\tx.copyTo(r);\n\tthis.reduce(r);\n\treturn r;\n    }\n\n    // x = x/R mod m (HAC 14.32)\n    function montReduce(x) {\n\twhile(x.t <= this.mt2)\t// pad x so am has enough room later\n\t    x[x.t++] = 0;\n\tfor(var i = 0; i < this.m.t; ++i) {\n\t    // faster way of calculating u0 = x[i]*mp mod DV\n\t    var j = x[i]&0x7fff;\n\t    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n\t    // use am to combine the multiply-shift-add into one call\n\t    j = i+this.m.t;\n\t    x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n\t    // propagate carry\n\t    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n\t}\n\tx.clamp();\n\tx.drShiftTo(this.m.t,x);\n\tif(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = \"x^2/R mod m\"; x != r\n    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = \"xy/R mod m\"; x,y != r\n    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Montgomery.prototype.convert = montConvert;\n    Montgomery.prototype.revert = montRevert;\n    Montgomery.prototype.reduce = montReduce;\n    Montgomery.prototype.mulTo = montMulTo;\n    Montgomery.prototype.sqrTo = montSqrTo;\n\n    // (protected) true iff this is even\n    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n    // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n    function bnpExp(e,z) {\n\t    if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n\t    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n\t    g.copyTo(r);\n\t    while(--i >= 0) {\n\t        z.sqrTo(r,r2);\n\t        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n\t        else { var t = r; r = r2; r2 = t; }\n\t    }\n\t    return z.revert(r);\n    }\n\n    // (public) this^e % m, 0 <= e < 2^32\n    function bnModPowInt(e,m) {\n\tvar z;\n\tif(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n\treturn this.exp(e,z);\n    }\n\n    // protected\n    BigInteger.prototype.copyTo = bnpCopyTo;\n    BigInteger.prototype.fromInt = bnpFromInt;\n    BigInteger.prototype.fromString = bnpFromString;\n    BigInteger.prototype.clamp = bnpClamp;\n    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n    BigInteger.prototype.lShiftTo = bnpLShiftTo;\n    BigInteger.prototype.rShiftTo = bnpRShiftTo;\n    BigInteger.prototype.subTo = bnpSubTo;\n    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n    BigInteger.prototype.squareTo = bnpSquareTo;\n    BigInteger.prototype.divRemTo = bnpDivRemTo;\n    BigInteger.prototype.invDigit = bnpInvDigit;\n    BigInteger.prototype.isEven = bnpIsEven;\n    BigInteger.prototype.bnpExp = bnpExp;\n\n    // public\n    BigInteger.prototype.toString = bnToString;\n    BigInteger.prototype.negate = bnNegate;\n    BigInteger.prototype.abs = bnAbs;\n    BigInteger.prototype.compareTo = bnCompareTo;\n    BigInteger.prototype.bitLength = bnBitLength;\n    BigInteger.prototype.mod = bnMod;\n    BigInteger.prototype.modPowInt = bnModPowInt;\n\n    // \"constants\"\n    BigInteger.ZERO = nbv(0);\n    BigInteger.ONE = nbv(1);\n\n    // Copyright (c) 2005-2009  Tom Wu\n    // All Rights Reserved.\n    // See \"LICENSE\" for details.\n\n    // Extended JavaScript BN functions, required for RSA private ops.\n\n    // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n\n    // (public)\n    function bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n    // (public) return value as integer\n    function bnIntValue() {\n\tif(this.s < 0) {\n\t    if(this.t == 1) return this[0]-this.DV;\n\t    else if(this.t == 0) return -1;\n\t}\n\telse if(this.t == 1) return this[0];\n\telse if(this.t == 0) return 0;\n\t// assumes 16 < DB < 32\n\treturn ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n    }\n\n    // (public) return value as byte\n    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n    // (public) return value as short (assumes DB>=16)\n    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n    // (protected) return x s.t. r^x < DV\n    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n    // (public) 0 if this == 0, 1 if this > 0\n    function bnSigNum() {\n\tif(this.s < 0) return -1;\n\telse if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n\telse return 1;\n    }\n\n    // (protected) convert to radix string\n    function bnpToRadix(b) {\n\tif(b == null) b = 10;\n\tif(this.signum() == 0 || b < 2 || b > 36) return \"0\";\n\tvar cs = this.chunkSize(b);\n\tvar a = Math.pow(b,cs);\n\tvar d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n\tthis.divRemTo(d,y,z);\n\twhile(y.signum() > 0) {\n\t    r = (a+z.intValue()).toString(b).substr(1) + r;\n\t    y.divRemTo(d,y,z);\n\t}\n\treturn z.intValue().toString(b) + r;\n    }\n\n    // (protected) convert from radix string\n    function bnpFromRadix(s,b) {\n\tthis.fromInt(0);\n\tif(b == null) b = 10;\n\tvar cs = this.chunkSize(b);\n\tvar d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n\tfor(var i = 0; i < s.length; ++i) {\n\t    var x = intAt(s,i);\n\t    if(x < 0) {\n\t\tif(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n\t\tcontinue;\n\t    }\n\t    w = b*w+x;\n\t    if(++j >= cs) {\n\t\tthis.dMultiply(d);\n\t\tthis.dAddOffset(w,0);\n\t\tj = 0;\n\t\tw = 0;\n\t    }\n\t}\n\tif(j > 0) {\n\t    this.dMultiply(Math.pow(b,j));\n\t    this.dAddOffset(w,0);\n\t}\n\tif(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) alternate constructor\n    function bnpFromNumber(a,b,c) {\n\tif(\"number\" == typeof b) {\n\t    // new BigInteger(int,int,RNG)\n\t    if(a < 2) this.fromInt(1);\n\t    else {\n\t\tthis.fromNumber(a,c);\n\t\tif(!this.testBit(a-1))\t// force MSB set\n\t\t    this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n\t\tif(this.isEven()) this.dAddOffset(1,0); // force odd\n\t\twhile(!this.isProbablePrime(b)) {\n\t\t    this.dAddOffset(2,0);\n\t\t    if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n\t\t}\n\t    }\n\t}\n\telse {\n\t    // new BigInteger(int,RNG)\n\t    var x = [], t = a&7;\n\t    x.length = (a>>3)+1;\n\t    b.nextBytes(x);\n\t    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n\t    this.fromString(x,256);\n\t}\n    }\n\n    // (public) convert to bigendian byte array\n    function bnToByteArray() {\n\tvar i = this.t, r = [];\n\tr[0] = this.s;\n\tvar p = this.DB-(i*this.DB)%8, d, k = 0;\n\tif(i-- > 0) {\n\t    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n\t\tr[k++] = d|(this.s<<(this.DB-p));\n\t    while(i >= 0) {\n\t\tif(p < 8) {\n\t\t    d = (this[i]&((1<<p)-1))<<(8-p);\n\t\t    d |= this[--i]>>(p+=this.DB-8);\n\t\t}\n\t\telse {\n\t\t    d = (this[i]>>(p-=8))&0xff;\n\t\t    if(p <= 0) { p += this.DB; --i; }\n\t\t}\n\t\tif((d&0x80) != 0) d |= -256;\n\t\tif(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n\t\tif(k > 0 || d != this.s) r[k++] = d;\n\t    }\n\t}\n\treturn r;\n    }\n\n    function bnEquals(a) { return(this.compareTo(a)==0); }\n    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\n    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n    // (protected) r = this op a (bitwise)\n    function bnpBitwiseTo(a,op,r) {\n\tvar i, f, m = Math.min(a.t,this.t);\n\tfor(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n\tif(a.t < this.t) {\n\t    f = a.s&this.DM;\n\t    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n\t    r.t = this.t;\n\t}\n\telse {\n\t    f = this.s&this.DM;\n\t    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n\t    r.t = a.t;\n\t}\n\tr.s = op(this.s,a.s);\n\tr.clamp();\n    }\n\n    // (public) this & a\n    function op_and(x,y) { return x&y; }\n    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n    // (public) this | a\n    function op_or(x,y) { return x|y; }\n    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n    // (public) this ^ a\n    function op_xor(x,y) { return x^y; }\n    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n    // (public) this & ~a\n    function op_andnot(x,y) { return x&~y; }\n    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n    // (public) ~this\n    function bnNot() {\n\tvar r = nbi();\n\tfor(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n\tr.t = this.t;\n\tr.s = ~this.s;\n\treturn r;\n    }\n\n    // (public) this << n\n    function bnShiftLeft(n) {\n\tvar r = nbi();\n\tif(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n\treturn r;\n    }\n\n    // (public) this >> n\n    function bnShiftRight(n) {\n\tvar r = nbi();\n\tif(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n\treturn r;\n    }\n\n    // return index of lowest 1-bit in x, x < 2^31\n    function lbit(x) {\n\tif(x == 0) return -1;\n\tvar r = 0;\n\tif((x&0xffff) == 0) { x >>= 16; r += 16; }\n\tif((x&0xff) == 0) { x >>= 8; r += 8; }\n\tif((x&0xf) == 0) { x >>= 4; r += 4; }\n\tif((x&3) == 0) { x >>= 2; r += 2; }\n\tif((x&1) == 0) ++r;\n\treturn r;\n    }\n\n    // (public) returns index of lowest 1-bit (or -1 if none)\n    function bnGetLowestSetBit() {\n\tfor(var i = 0; i < this.t; ++i)\n\t    if(this[i] != 0) return i*this.DB+lbit(this[i]);\n\tif(this.s < 0) return this.t*this.DB;\n\treturn -1;\n    }\n\n    // return number of 1 bits in x\n    function cbit(x) {\n\tvar r = 0;\n\twhile(x != 0) { x &= x-1; ++r; }\n\treturn r;\n    }\n\n    // (public) return number of set bits\n    function bnBitCount() {\n\tvar r = 0, x = this.s&this.DM;\n\tfor(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n\treturn r;\n    }\n\n    // (public) true iff nth bit is set\n    function bnTestBit(n) {\n\tvar j = Math.floor(n/this.DB);\n\tif(j >= this.t) return(this.s!=0);\n\treturn((this[j]&(1<<(n%this.DB)))!=0);\n    }\n\n    // (protected) this op (1<<n)\n    function bnpChangeBit(n,op) {\n\tvar r = BigInteger.ONE.shiftLeft(n);\n\tthis.bitwiseTo(r,op,r);\n\treturn r;\n    }\n\n    // (public) this | (1<<n)\n    function bnSetBit(n) { return this.changeBit(n,op_or); }\n\n    // (public) this & ~(1<<n)\n    function bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n    // (public) this ^ (1<<n)\n    function bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n    // (protected) r = this + a\n    function bnpAddTo(a,r) {\n\tvar i = 0, c = 0, m = Math.min(a.t,this.t);\n\twhile(i < m) {\n\t    c += this[i]+a[i];\n\t    r[i++] = c&this.DM;\n\t    c >>= this.DB;\n\t}\n\tif(a.t < this.t) {\n\t    c += a.s;\n\t    while(i < this.t) {\n\t\tc += this[i];\n\t\tr[i++] = c&this.DM;\n\t\tc >>= this.DB;\n\t    }\n\t    c += this.s;\n\t}\n\telse {\n\t    c += this.s;\n\t    while(i < a.t) {\n\t\tc += a[i];\n\t\tr[i++] = c&this.DM;\n\t\tc >>= this.DB;\n\t    }\n\t    c += a.s;\n\t}\n\tr.s = (c<0)?-1:0;\n\tif(c > 0) r[i++] = c;\n\telse if(c < -1) r[i++] = this.DV+c;\n\tr.t = i;\n\tr.clamp();\n    }\n\n    // (public) this + a\n    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n    // (public) this - a\n    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n    // (public) this * a\n    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n    // (public) this / a\n    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n    // (public) this % a\n    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n    // (public) [this/a,this%a]\n    function bnDivideAndRemainder(a) {\n\tvar q = nbi(), r = nbi();\n\tthis.divRemTo(a,q,r);\n\treturn [q,r];\n    }\n\n    // (protected) this *= n, this >= 0, 1 < n < DV\n    function bnpDMultiply(n) {\n\tthis[this.t] = this.am(0,n-1,this,0,0,this.t);\n\t++this.t;\n\tthis.clamp();\n    }\n\n    // (protected) this += n << w words, this >= 0\n    function bnpDAddOffset(n,w) {\n\tif(n == 0) return;\n\twhile(this.t <= w) this[this.t++] = 0;\n\tthis[w] += n;\n\twhile(this[w] >= this.DV) {\n\t    this[w] -= this.DV;\n\t    if(++w >= this.t) this[this.t++] = 0;\n\t    ++this[w];\n\t}\n    }\n\n    // A \"null\" reducer\n    function NullExp() {}\n    function nNop(x) { return x; }\n    function nMulTo(x,y,r) { x.multiplyTo(y,r); }\n    function nSqrTo(x,r) { x.squareTo(r); }\n\n    NullExp.prototype.convert = nNop;\n    NullExp.prototype.revert = nNop;\n    NullExp.prototype.mulTo = nMulTo;\n    NullExp.prototype.sqrTo = nSqrTo;\n\n    // (public) this^e\n    function bnPow(e) { return this.bnpExp(e,new NullExp()); }\n\n    // (protected) r = lower n words of \"this * a\", a.t <= n\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyLowerTo(a,n,r) {\n\tvar i = Math.min(this.t+a.t,n);\n\tr.s = 0; // assumes a,this >= 0\n\tr.t = i;\n\twhile(i > 0) r[--i] = 0;\n\tvar j;\n\tfor(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n\tfor(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n\tr.clamp();\n    }\n\n    // (protected) r = \"this * a\" without lower n words, n > 0\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyUpperTo(a,n,r) {\n\t--n;\n\tvar i = r.t = this.t+a.t-n;\n\tr.s = 0; // assumes a,this >= 0\n\twhile(--i >= 0) r[i] = 0;\n\tfor(i = Math.max(n-this.t,0); i < a.t; ++i)\n\t    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n\tr.clamp();\n\tr.drShiftTo(1,r);\n    }\n\n    // Barrett modular reduction\n    function Barrett(m) {\n\t// setup Barrett\n\tthis.r2 = nbi();\n\tthis.q3 = nbi();\n\tBigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n\tthis.mu = this.r2.divide(m);\n\tthis.m = m;\n    }\n\n    function barrettConvert(x) {\n\tif(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n\telse if(x.compareTo(this.m) < 0) return x;\n\telse { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n    }\n\n    function barrettRevert(x) { return x; }\n\n    // x = x mod m (HAC 14.42)\n    function barrettReduce(x) {\n\tx.drShiftTo(this.m.t-1,this.r2);\n\tif(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n\tthis.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n\tthis.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n\twhile(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n\tx.subTo(this.r2,x);\n\twhile(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = x^2 mod m; x != r\n    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = x*y mod m; x,y != r\n    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Barrett.prototype.convert = barrettConvert;\n    Barrett.prototype.revert = barrettRevert;\n    Barrett.prototype.reduce = barrettReduce;\n    Barrett.prototype.mulTo = barrettMulTo;\n    Barrett.prototype.sqrTo = barrettSqrTo;\n\n    // (public) this^e % m (HAC 14.85)\n    function bnModPow(e,m) {\n\tvar i = e.bitLength(), k, r = nbv(1), z;\n\tif(i <= 0) return r;\n\telse if(i < 18) k = 1;\n\telse if(i < 48) k = 3;\n\telse if(i < 144) k = 4;\n\telse if(i < 768) k = 5;\n\telse k = 6;\n\tif(i < 8)\n\t    z = new Classic(m);\n\telse if(m.isEven())\n\t    z = new Barrett(m);\n\telse\n\t    z = new Montgomery(m);\n\n\t// precomputation\n\tvar g = [], n = 3, k1 = k-1, km = (1<<k)-1;\n\tg[1] = z.convert(this);\n\tif(k > 1) {\n\t    var g2 = nbi();\n\t    z.sqrTo(g[1],g2);\n\t    while(n <= km) {\n\t\tg[n] = nbi();\n\t\tz.mulTo(g2,g[n-2],g[n]);\n\t\tn += 2;\n\t    }\n\t}\n\n\tvar j = e.t-1, w, is1 = true, r2 = nbi(), t;\n\ti = nbits(e[j])-1;\n\twhile(j >= 0) {\n\t    if(i >= k1) w = (e[j]>>(i-k1))&km;\n\t    else {\n\t\tw = (e[j]&((1<<(i+1))-1))<<(k1-i);\n\t\tif(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n\t    }\n\n\t    n = k;\n\t    while((w&1) == 0) { w >>= 1; --n; }\n\t    if((i -= n) < 0) { i += this.DB; --j; }\n\t    if(is1) {\t// ret == 1, don't bother squaring or multiplying it\n\t\tg[w].copyTo(r);\n\t\tis1 = false;\n\t    }\n\t    else {\n\t\twhile(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n\t\tif(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n\t\tz.mulTo(r2,g[w],r);\n\t    }\n\n\t    while(j >= 0 && (e[j]&(1<<i)) == 0) {\n\t\tz.sqrTo(r,r2); t = r; r = r2; r2 = t;\n\t\tif(--i < 0) { i = this.DB-1; --j; }\n\t    }\n\t}\n\treturn z.revert(r);\n    }\n\n    // (public) gcd(this,a) (HAC 14.54)\n    function bnGCD(a) {\n\tvar x = (this.s<0)?this.negate():this.clone();\n\tvar y = (a.s<0)?a.negate():a.clone();\n\tif(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n\tvar i = x.getLowestSetBit(), g = y.getLowestSetBit();\n\tif(g < 0) return x;\n\tif(i < g) g = i;\n\tif(g > 0) {\n\t    x.rShiftTo(g,x);\n\t    y.rShiftTo(g,y);\n\t}\n\twhile(x.signum() > 0) {\n\t    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n\t    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n\t    if(x.compareTo(y) >= 0) {\n\t\tx.subTo(y,x);\n\t\tx.rShiftTo(1,x);\n\t    }\n\t    else {\n\t\ty.subTo(x,y);\n\t\ty.rShiftTo(1,y);\n\t    }\n\t}\n\tif(g > 0) y.lShiftTo(g,y);\n\treturn y;\n    }\n\n    // (protected) this % n, n < 2^26\n    function bnpModInt(n) {\n\tif(n <= 0) return 0;\n\tvar d = this.DV%n, r = (this.s<0)?n-1:0;\n\tif(this.t > 0)\n\t    if(d == 0) r = this[0]%n;\n\telse for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n\treturn r;\n    }\n\n    // (public) 1/this % m (HAC 14.61)\n    function bnModInverse(m) {\n\tvar ac = m.isEven();\n\tif((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n\tvar u = m.clone(), v = this.clone();\n\tvar a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n\twhile(u.signum() != 0) {\n\t    while(u.isEven()) {\n\t\tu.rShiftTo(1,u);\n\t\tif(ac) {\n\t\t    if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n\t\t    a.rShiftTo(1,a);\n\t\t}\n\t\telse if(!b.isEven()) b.subTo(m,b);\n\t\tb.rShiftTo(1,b);\n\t    }\n\t    while(v.isEven()) {\n\t\tv.rShiftTo(1,v);\n\t\tif(ac) {\n\t\t    if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n\t\t    c.rShiftTo(1,c);\n\t\t}\n\t\telse if(!d.isEven()) d.subTo(m,d);\n\t\td.rShiftTo(1,d);\n\t    }\n\t    if(u.compareTo(v) >= 0) {\n\t\tu.subTo(v,u);\n\t\tif(ac) a.subTo(c,a);\n\t\tb.subTo(d,b);\n\t    }\n\t    else {\n\t\tv.subTo(u,v);\n\t\tif(ac) c.subTo(a,c);\n\t\td.subTo(b,d);\n\t    }\n\t}\n\tif(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n\tif(d.compareTo(m) >= 0) return d.subtract(m);\n\tif(d.signum() < 0) d.addTo(m,d); else return d;\n\tif(d.signum() < 0) return d.add(m); else return d;\n    }\n\n    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];\n    var lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n    // (public) test primality with certainty >= 1-.5^t\n    function bnIsProbablePrime(t) {\n\tvar i, x = this.abs();\n\tif(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n\t    for(i = 0; i < lowprimes.length; ++i)\n\t\tif(x[0] == lowprimes[i]) return true;\n\t    return false;\n\t}\n\tif(x.isEven()) return false;\n\ti = 1;\n\twhile(i < lowprimes.length) {\n\t    var m = lowprimes[i], j = i+1;\n\t    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n\t    m = x.modInt(m);\n\t    while(i < j) if(m%lowprimes[i++] == 0) return false;\n\t}\n\treturn x.millerRabin(t);\n    }\n\n    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n    function bnpMillerRabin(t) {\n\tvar n1 = this.subtract(BigInteger.ONE);\n\tvar k = n1.getLowestSetBit();\n\tif(k <= 0) return false;\n\tvar r = n1.shiftRight(k);\n\tt = (t+1)>>1;\n\tif(t > lowprimes.length) t = lowprimes.length;\n\tvar a = nbi();\n\tfor(var i = 0; i < t; ++i) {\n\t    a.fromInt(lowprimes[i]);\n\t    var y = a.modPow(r,this);\n\t    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n\t\tvar j = 1;\n\t\twhile(j++ < k && y.compareTo(n1) != 0) {\n\t\t    y = y.modPowInt(2,this);\n\t\t    if(y.compareTo(BigInteger.ONE) == 0) return false;\n\t\t}\n\t\tif(y.compareTo(n1) != 0) return false;\n\t    }\n\t}\n\treturn true;\n    }\n    \n    \n\n    // protected\n    BigInteger.prototype.chunkSize = bnpChunkSize;\n    BigInteger.prototype.toRadix = bnpToRadix;\n    BigInteger.prototype.fromRadix = bnpFromRadix;\n    BigInteger.prototype.fromNumber = bnpFromNumber;\n    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n    BigInteger.prototype.changeBit = bnpChangeBit;\n    BigInteger.prototype.addTo = bnpAddTo;\n    BigInteger.prototype.dMultiply = bnpDMultiply;\n    BigInteger.prototype.dAddOffset = bnpDAddOffset;\n    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n    BigInteger.prototype.modInt = bnpModInt;\n    BigInteger.prototype.millerRabin = bnpMillerRabin;\n\n    // public\n    BigInteger.prototype.clone = bnClone;\n    BigInteger.prototype.intValue = bnIntValue;\n    BigInteger.prototype.byteValue = bnByteValue;\n    BigInteger.prototype.shortValue = bnShortValue;\n    BigInteger.prototype.signum = bnSigNum;\n    BigInteger.prototype.toByteArray = bnToByteArray;\n    BigInteger.prototype.equals = bnEquals;\n    BigInteger.prototype.min = bnMin;\n    BigInteger.prototype.max = bnMax;\n    BigInteger.prototype.and = bnAnd;\n    BigInteger.prototype.or = bnOr;\n    BigInteger.prototype.xor = bnXor;\n    BigInteger.prototype.andNot = bnAndNot;\n    BigInteger.prototype.not = bnNot;\n    BigInteger.prototype.shiftLeft = bnShiftLeft;\n    BigInteger.prototype.shiftRight = bnShiftRight;\n    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n    BigInteger.prototype.bitCount = bnBitCount;\n    BigInteger.prototype.testBit = bnTestBit;\n    BigInteger.prototype.setBit = bnSetBit;\n    BigInteger.prototype.clearBit = bnClearBit;\n    BigInteger.prototype.flipBit = bnFlipBit;\n    BigInteger.prototype.add = bnAdd;\n    BigInteger.prototype.subtract = bnSubtract;\n    BigInteger.prototype.multiply = bnMultiply;\n    BigInteger.prototype.divide = bnDivide;\n    BigInteger.prototype.remainder = bnRemainder;\n    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n    BigInteger.prototype.modPow = bnModPow;\n    BigInteger.prototype.modInverse = bnModInverse;\n    BigInteger.prototype.pow = bnPow;\n    BigInteger.prototype.expt = bnPow;\n    BigInteger.prototype.gcd = bnGCD;\n    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n    // BigInteger interfaces not implemented in jsbn:\n\n    // BigInteger(int signum, byte[] magnitude)\n    // double doubleValue()\n    // float floatValue()\n    // int hashCode()\n    // long longValue()\n    // static BigInteger valueOf(long val)\n\n\n\n    //////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////\n    // END OF copy-and-paste of jsbn.\n\n\n\n    BigInteger.NEGATIVE_ONE = BigInteger.ONE.negate();\n\n\n    // Other methods we need to add for compatibilty with js-numbers numeric tower.\n\n    // add is implemented above.\n    // subtract is implemented above.\n    // multiply is implemented above.\n    // equals is implemented above.\n    // abs is implemented above.\n    // negate is defined above.\n\n    // makeBignum: string -> BigInteger\n    var makeBignum = function(s) {\n\tif (typeof(s) === 'number') { s = s + ''; }\n\ts = expandExponent(s);\n\treturn new BigInteger(s, 10);\n    };\n\n    var zerostring = function(n) {\n\tvar buf = [];\n\tfor (var i = 0; i < n; i++) {\n\t    buf.push('0');\n\t}\n\treturn buf.join('');\n    };\n\n\n    BigInteger.prototype.level = 0;\n    BigInteger.prototype.liftTo = function(target) {\n\tif (target.level === 1) {\n\t    return new Rational(this, 1);\n\t}\n\tif (target.level === 2) {\n\t    var fixrep = this.toFixnum();\n\t    if (fixrep === Number.POSITIVE_INFINITY)\n\t\treturn TOO_POSITIVE_TO_REPRESENT;\n\t    if (fixrep === Number.NEGATIVE_INFINITY)\n\t\treturn TOO_NEGATIVE_TO_REPRESENT;\n\t    return new FloatPoint(fixrep);\n\t}\n\tif (target.level === 3) {\n\t    return new Complex(this, 0);\n\t}\n\treturn throwRuntimeError(\"invalid level for BigInteger lift\", this, target);\n    };\n\n    BigInteger.prototype.isFinite = function() {\n\treturn true;\n    };\n\n    BigInteger.prototype.isInteger = function() {\n\treturn true;\n    };\n\n    BigInteger.prototype.isRational = function() {\n\treturn true;\n    };\n\n    BigInteger.prototype.isReal = function() {\n\treturn true;\n    };\n\n    BigInteger.prototype.isExact = function() {\n\treturn true;\n    };\n\n    BigInteger.prototype.isInexact = function() {\n\treturn false;\n    };\n\n    BigInteger.prototype.toExact = function() {\n\treturn this;\n    };\n\n    BigInteger.prototype.toInexact = function() {\n\treturn FloatPoint.makeInstance(this.toFixnum());\n    };\n\n    BigInteger.prototype.toFixnum = function() {\n\tvar result = 0, str = this.toString(), i;\n\tif (str[0] === '-') {\n\t    for (i=1; i < str.length; i++) {\n\t\tresult = result * 10 + Number(str[i]);\n\t    }\n\t    return -result;\n\t} else {\n\t    for (i=0; i < str.length; i++) {\n\t\tresult = result * 10 + Number(str[i]);\n\t    }\n\t    return result;\n\t}\n    };\n\n\n    BigInteger.prototype.greaterThan = function(other) {\n\treturn this.compareTo(other) > 0;\n    };\n\n    BigInteger.prototype.greaterThanOrEqual = function(other) {\n\treturn this.compareTo(other) >= 0;\n    };\n\n    BigInteger.prototype.lessThan = function(other) {\n\treturn this.compareTo(other) < 0;\n    };\n\n    BigInteger.prototype.lessThanOrEqual = function(other) {\n\treturn this.compareTo(other) <= 0;\n    };\n\n    // divide: scheme-number -> scheme-number\n    // WARNING NOTE: we override the old version of divide.\n    BigInteger.prototype.divide = function(other) {\n\tvar quotientAndRemainder = bnDivideAndRemainder.call(this, other);\n\tif (quotientAndRemainder[1].compareTo(BigInteger.ZERO) === 0) {\n\t    return quotientAndRemainder[0];\n\t} else {\n\t    var result = add(quotientAndRemainder[0],\n\t\t\t     Rational.makeInstance(quotientAndRemainder[1], other));\n\t    return result;\n\t}\n    };\n\n    BigInteger.prototype.numerator = function() {\n\treturn this;\n    };\n\n    BigInteger.prototype.denominator = function() {\n\treturn 1;\n    };\n\n\n    (function() {\n\t// Classic implementation of Newton-Ralphson square-root search,\n\t// adapted for integer-sqrt.\n\t// http://en.wikipedia.org/wiki/Newton's_method#Square_root_of_a_number\n\t    var searchIter = function(n, guess) {\n\t\twhile(!(lessThanOrEqual(sqr(guess),n) &&\n\t\t\tlessThan(n,sqr(add(guess, 1))))) {\n\t\t    guess = floor(divide(add(guess,\n\t\t\t\t\t     floor(divide(n, guess))),\n\t\t\t\t\t 2));\n\t\t}\n\t\treturn guess;\n\t    };\n\n\t    // integerSqrt: -> scheme-number\n\t    BigInteger.prototype.integerSqrt = function() {\n\t\tvar n;\n\t\tif(sign(this) >= 0) {\n\t\t    return searchIter(this, this);\n\t\t} else {\n\t\t    n = this.negate();\n\t\t    return Complex.makeInstance(0, searchIter(n, n));\n\t\t}\n\t    };\n    })();\n\n\n    // sqrt: -> scheme-number\n    // http://en.wikipedia.org/wiki/Newton's_method#Square_root_of_a_number\n    // Produce the square root.\n    (function() {\t\n\t// Get an approximation using integerSqrt, and then start another\n\t// Newton-Ralphson search if necessary.\n\tBigInteger.prototype.sqrt = function() {\n\t    var approx = this.integerSqrt(), fix;\n\t    if (eqv(sqr(approx), this)) {\n\t\treturn approx;\n\t    }\n\t    fix = toFixnum(this);\n\t    if (isFinite(fix)) {\n\t\tif (fix >= 0) {\n\t\t    return FloatPoint.makeInstance(Math.sqrt(fix));\n\t\t} else {\n\t\t    return Complex.makeInstance(\n\t\t\t0,\n\t\t\tFloatPoint.makeInstance(Math.sqrt(-fix)));\n\t\t}\n\t    } else {\n\t\treturn approx;\n\t    }\n\t};\n    })();\n\n    // floor: -> scheme-number\n    // Produce the floor.\n    BigInteger.prototype.floor = function() {\n        return this;\n    }\n\n    // ceiling: -> scheme-number\n    // Produce the ceiling.\n    BigInteger.prototype.ceiling = function() {\n        return this;\n    }\n\n\n    // Until we have a feature-complete Big Number implementation, we'll\n    // convert BigInteger objects into FloatPoint objects and perform\n    // unsupported operations there.\n    function temporaryAccuracyLosingWorkAroundForBigNums(function_name) {\n      return function () {\n\tvar inexact = this.toInexact();\n\treturn inexact[function_name].apply(inexact, arguments);\n      }\n    }\n\n    // conjugate: -> scheme-number\n    // Produce the conjugate.\n    BigInteger.prototype.conjugate = temporaryAccuracyLosingWorkAroundForBigNums(\"conjugate\");\n\n    // magnitude: -> scheme-number\n    // Produce the magnitude.\n    BigInteger.prototype.magnitude = temporaryAccuracyLosingWorkAroundForBigNums(\"magnitude\");\n\n    // log: -> scheme-number\n    // Produce the log.\n    BigInteger.prototype.log = temporaryAccuracyLosingWorkAroundForBigNums(\"log\");\n\n    // angle: -> scheme-number\n    // Produce the angle.\n    BigInteger.prototype.angle = temporaryAccuracyLosingWorkAroundForBigNums(\"angle\");\n\n    // atan: -> scheme-number\n    // Produce the arc tangent.\n    BigInteger.prototype.atan = temporaryAccuracyLosingWorkAroundForBigNums(\"atan\");\n\n    // acos: -> scheme-number\n    // Produce the arc cosine.\n    BigInteger.prototype.acos = temporaryAccuracyLosingWorkAroundForBigNums(\"acos\");\n\n    // asin: -> scheme-number\n    // Produce the arc sine.\n    BigInteger.prototype.asin = temporaryAccuracyLosingWorkAroundForBigNums(\"asin\");\n\n    // tan: -> scheme-number\n    // Produce the tangent.\n    BigInteger.prototype.tan = temporaryAccuracyLosingWorkAroundForBigNums(\"tan\");\n\n    // cos: -> scheme-number\n    // Produce the cosine.\n    BigInteger.prototype.cos = temporaryAccuracyLosingWorkAroundForBigNums(\"cos\");\n\n    // sin: -> scheme-number\n    // Produce the sine.\n    BigInteger.prototype.sin = temporaryAccuracyLosingWorkAroundForBigNums(\"sin\");\n\n    // exp: -> scheme-number\n    // Produce e raised to the given power.\n    BigInteger.prototype.exp = temporaryAccuracyLosingWorkAroundForBigNums(\"exp\");\n\n    BigInteger.prototype.imaginaryPart = function() {\n\t    return 0;\n    }\n    BigInteger.prototype.realPart = function() {\n\t    return this;\n    }\n\n    // round: -> scheme-number\n    // Round to the nearest integer.\n    BigInteger.prototype.round = function() {\n\t    return this;\n    }\n\n\n\n\n\n    //////////////////////////////////////////////////////////////////////\n    // toRepeatingDecimal: jsnum jsnum {limit: number}? -> [string, string, string]\n    //\n    // Given the numerator and denominator parts of a rational,\n    // produces the repeating-decimal representation, where the first\n    // part are the digits before the decimal, the second are the\n    // non-repeating digits after the decimal, and the third are the\n    // remaining repeating decimals.\n    // \n    // An optional limit on the decimal expansion can be provided, in which\n    // case the search cuts off if we go past the limit.\n    // If this happens, the third argument returned becomes '...' to indicate\n    // that the search was prematurely cut off.\n    var toRepeatingDecimal = (function() {\n\tvar getResidue = function(r, d, limit) {\n\t    var digits = [];\n\t    var seenRemainders = {};\n\t    seenRemainders[r] = true;\n\t    while(true) {\t\n\t\tif (limit-- <= 0) {\n\t\t    return [digits.join(''), '...']\n\t\t}\n\n\t\tvar nextDigit = quotient(\n\t\t    multiply(r, 10), d);\n\t\tvar nextRemainder = remainder(\n\t\t    multiply(r, 10),\n\t\t    d);\n\t\tdigits.push(nextDigit.toString());\n\t\tif (seenRemainders[nextRemainder]) {\n\t\t    r = nextRemainder;\n\t\t    break;\n\t\t} else {\n\t\t    seenRemainders[nextRemainder] = true;\n\t\t    r = nextRemainder;\n\t\t}\n\t    }\n\t    \n\t    var firstRepeatingRemainder = r;\n\t    var repeatingDigits = [];\n\t    while (true) {\n\t\tvar nextDigit = quotient(multiply(r, 10), d);\n\t\tvar nextRemainder = remainder(\n\t\t    multiply(r, 10),\n\t\t    d);\n\t\trepeatingDigits.push(nextDigit.toString());\n\t\tif (equals(nextRemainder, firstRepeatingRemainder)) {\n\t\t    break;\n\t\t} else {\n\t\t    r = nextRemainder;\n\t\t}\n\t    };\n\n\t    var digitString = digits.join('');\n\t    var repeatingDigitString = repeatingDigits.join('');\n\n\t    while (digitString.length >= repeatingDigitString.length &&\n\t\t   (digitString.substring(\n\t\t       digitString.length - repeatingDigitString.length)\n\t\t    === repeatingDigitString)) {\n\t\tdigitString = digitString.substring(\n\t\t    0, digitString.length - repeatingDigitString.length);\n\t    }\n\n\t    return [digitString, repeatingDigitString];\n\n\t};\n\n\treturn function(n, d, options) {\n\t    // default limit on decimal expansion; can be overridden\n\t    var limit = 512;\n\t    if (options && typeof(options.limit) !== 'undefined') {\n\t\tlimit = options.limit;\n\t    }\n\t    if (! isInteger(n)) {\n\t\tthrowRuntimeError('toRepeatingDecimal: n ' + n.toString() +\n\t\t\t\t  \" is not an integer.\");\n\t    }\n\t    if (! isInteger(d)) {\n\t\tthrowRuntimeError('toRepeatingDecimal: d ' + d.toString() +\n\t\t\t\t  \" is not an integer.\");\n\t    }\n\t    if (equals(d, 0)) {\n\t\tthrowRuntimeError('toRepeatingDecimal: d equals 0');\n\t    }\n\t    if (lessThan(d, 0)) {\n\t\tthrowRuntimeError('toRepeatingDecimal: d < 0');\n\t    }\n \t    var sign = (lessThan(n, 0) ? \"-\" : \"\");\n \t    n = abs(n);\n \t    var beforeDecimalPoint = sign + quotient(n, d);\n \t    var afterDecimals = getResidue(remainder(n, d), d, limit);\n \t    return [beforeDecimalPoint].concat(afterDecimals);\n\t};\n    })();\n    //////////////////////////////////////////////////////////////////////\n\n\n\n\n    // External interface of js-numbers:\n\n    Numbers['fromFixnum'] = fromFixnum;\n    Numbers['fromString'] = fromString;\n    Numbers['makeBignum'] = makeBignum;\n    Numbers['makeRational'] = Rational.makeInstance;\n    Numbers['makeFloat'] = FloatPoint.makeInstance;\n    Numbers['makeComplex'] = Complex.makeInstance;\n    Numbers['makeComplexPolar'] = makeComplexPolar;\n\n    Numbers['pi'] = FloatPoint.pi;\n    Numbers['e'] = FloatPoint.e;\n    Numbers['nan'] = FloatPoint.nan;\n    Numbers['negative_inf'] = FloatPoint.neginf;\n    Numbers['inf'] = FloatPoint.inf;\n    Numbers['negative_one'] = -1;   // Rational.NEGATIVE_ONE;\n    Numbers['zero'] = 0;            // Rational.ZERO;\n    Numbers['one'] = 1;             // Rational.ONE;\n    Numbers['i'] = plusI;\n    Numbers['negative_i'] = minusI;\n    Numbers['negative_zero'] = NEGATIVE_ZERO;\n\n    Numbers['onThrowRuntimeError'] = onThrowRuntimeError;\n    Numbers['isSchemeNumber'] = isSchemeNumber;\n    Numbers['isRational'] = isRational;\n    Numbers['isReal'] = isReal;\n    Numbers['isExact'] = isExact;\n    Numbers['isInexact'] = isInexact;\n    Numbers['isInteger'] = isInteger;\n\n    Numbers['toFixnum'] = toFixnum;\n    Numbers['toExact'] = toExact;\n    Numbers['toInexact'] = toInexact;\n    Numbers['add'] = add;\n    Numbers['subtract'] = subtract;\n    Numbers['multiply'] = multiply;\n    Numbers['divide'] = divide;\n    Numbers['equals'] = equals;\n    Numbers['eqv'] = eqv;\n    Numbers['approxEquals'] = approxEquals;\n    Numbers['greaterThanOrEqual'] = greaterThanOrEqual;\n    Numbers['lessThanOrEqual'] = lessThanOrEqual;\n    Numbers['greaterThan'] = greaterThan;\n    Numbers['lessThan'] = lessThan;\n    Numbers['expt'] = expt;\n    Numbers['exp'] = exp;\n    Numbers['modulo'] = modulo;\n    Numbers['numerator'] = numerator;\n    Numbers['denominator'] = denominator;\n    Numbers['integerSqrt'] = integerSqrt;\n    Numbers['sqrt'] = sqrt;\n    Numbers['abs'] = abs;\n    Numbers['quotient'] = quotient;\n    Numbers['remainder'] = remainder;\n    Numbers['floor'] = floor;\n    Numbers['ceiling'] = ceiling;\n    Numbers['conjugate'] = conjugate;\n    Numbers['magnitude'] = magnitude;\n    Numbers['log'] = log;\n    Numbers['angle'] = angle;\n    Numbers['tan'] = tan;\n    Numbers['atan'] = atan;\n    Numbers['cos'] = cos;\n    Numbers['sin'] = sin;\n    Numbers['tan'] = tan;\n    Numbers['acos'] = acos;\n    Numbers['asin'] = asin;\n    Numbers['cosh'] = cosh;\n    Numbers['sinh'] = sinh;\n    Numbers['imaginaryPart'] = imaginaryPart;\n    Numbers['realPart'] = realPart;\n    Numbers['round'] = round;\n    Numbers['sqr'] = sqr;\n    Numbers['gcd'] = gcd;\n    Numbers['lcm'] = lcm;\n\n    Numbers['toRepeatingDecimal'] = toRepeatingDecimal;\n\n\n\n    // The following exposes the class representations for easier\n    // integration with other projects.\n    Numbers['BigInteger'] = BigInteger;\n    Numbers['Rational'] = Rational;\n    Numbers['FloatPoint'] = FloatPoint;\n    Numbers['Complex'] = Complex;   \n\n    Numbers['MIN_FIXNUM'] = MIN_FIXNUM;\n    Numbers['MAX_FIXNUM'] = MAX_FIXNUM;\n\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/runtime/js-numbers.js\n ** module id = 4\n ** module chunks = 0\n **/","\r\n/**\r\n * Copyright 2009 Tim Down.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\n//     *\r\n//       void put(Object key, Object value)\r\n\r\n//       Sets the value associated with the key supplied. If the hash table already contains the key then the old value is overwritten.\r\n//     *\r\n//       void get(Object key)\r\n\r\n//       Returns the value associated with the key supplied, or null if no value is found for that key.\r\n//     *\r\n//       Boolean containsKey(Object key)\r\n\r\n//       Returns whether the hash table contains the specified key.\r\n//     *\r\n//       Boolean containsValue(Object value)\r\n\r\n//       Returns whether the hash table contains the specified value.\r\n//     *\r\n//       void clear()\r\n\r\n//       Removes all entries from the hash table.\r\n//     *\r\n//       Boolean isEmpty()\r\n\r\n//       Returns true if the hash table contains no key/value pairs.\r\n//     *\r\n//       Array keys()\r\n\r\n//       Returns an array containing all the keys contained in the hash table.\r\n//     *\r\n//       Array values()\r\n\r\n//       Returns an array containing all the values contained in the hash table.\r\n//     *\r\n//       void remove(Object key)\r\n\r\n//       Removes the key and its corresponding value from the hash table.\r\n//     *\r\n//       Number size()\r\n\r\n//       Returns the number of key/value pairs contained in the hash table.\r\n\r\n\r\nvar _Hashtable=(function(){function _1(_2){return(typeof _2===\"undefined\");};function _3(_4){return(typeof _4===\"function\");};function _5(_6){return(typeof _6===\"string\");};function _7(_8,_9){return _3(_8[_9]);};function _a(_b){return _7(_b,\"equals\");};function _c(_d){return _7(_d,\"hashCode\");};function _e(_f){if(_5(_f)){return _f;}else{if(_c(_f)){var _10=_f.hashCode();if(!_5(_10)){return _e(_10);}\r\nreturn _10;}else{if(_7(_f,\"toString\")){return _f.toString();}else{return String(_f);}}}};function _11(_12,_13){return _12.equals(_13);};function _14(_15,_16){if(_a(_16)){return _16.equals(_15);}else{return _15===_16;}};function _17(o1,o2){return o1===o2;};function _1a(arr,_1c,_1d,_1e,_1f){var _20;for(var i=0,len=arr.length;i<len;i++){_20=arr[i];if(_1f(_1c,_1d(_20))){return _1e?[i,_20]:true;}}\r\nreturn false;};function _23(arr,idx){if(_7(arr,\"splice\")){arr.splice(idx,1);}else{if(idx===arr.length-1){arr.length=idx;}else{var _26=arr.slice(idx+1);arr.length=idx;for(var i=0,len=_26.length;i<len;i++){arr[idx+i]=_26[i];}}}};function _29(kv,_2b){if(kv===null){throw new Error(\"null is not a valid \"+_2b);}else{if(_1(kv)){throw new Error(_2b+\" must not be undefined\");}}};var _2c=\"key\",_2d=\"value\";function _2e(key){_29(key,_2c);};function _30(_31){_29(_31,_2d);};function _32(_33,_34,_35){this.entries=[];this.addEntry(_33,_34);if(_35!==null){this.getEqualityFunction=function(){return _35;};}};function _36(_37){return _37[0];};function _38(_39){return _39[1];};_32.prototype={getEqualityFunction:function(_3a){if(_a(_3a)){return _11;}else{return _14;}},searchForEntry:function(key){return _1a(this.entries,key,_36,true,this.getEqualityFunction(key));},getEntryForKey:function(key){return this.searchForEntry(key)[1];},getEntryIndexForKey:function(key){return this.searchForEntry(key)[0];},removeEntryForKey:function(key){var _3f=this.searchForEntry(key);if(_3f){_23(this.entries,_3f[0]);return true;}\r\nreturn false;},addEntry:function(key,_41){this.entries[this.entries.length]=[key,_41];},size:function(){return this.entries.length;},keys:function(_42){var _43=_42.length;for(var i=0,len=this.entries.length;i<len;i++){_42[_43+i]=this.entries[i][0];}},values:function(_46){var _47=_46.length;for(var i=0,len=this.entries.length;i<len;i++){_46[_47+i]=this.entries[i][1];}},containsKey:function(key){return _1a(this.entries,key,_36,false,this.getEqualityFunction(key));},containsValue:function(_4b){return _1a(this.entries,_4b,_38,false,_17);}};function _4c(){};_4c.prototype=[];function _4d(_4e){return _4e[0];};function _4f(_50,_51,_52){return _1a(_50,_51,_4d,true,_52);};function _53(_54,_55){var _56=_54[_55];if(_56&&(_56 instanceof _4c)){return _56[1];}\r\nreturn null;};function _57(_58,_59){var _5a=[];var _5b={};_58=_3(_58)?_58:_e;_59=_3(_59)?_59:null;this.put=function(key,_5d){_2e(key);_30(_5d);var _5e=_58(key);var _5f=_53(_5b,_5e);if(_5f){var _60=_5f.getEntryForKey(key);if(_60){_60[1]=_5d;}else{_5f.addEntry(key,_5d);}}else{var _61=new _4c();_61[0]=_5e;_61[1]=new _32(key,_5d,_59);_5a[_5a.length]=_61;_5b[_5e]=_61;}};this.get=function(key){_2e(key);var _63=_58(key);var _64=_53(_5b,_63);if(_64){var _65=_64.getEntryForKey(key);if(_65){return _65[1];}}\r\nreturn null;};this.containsKey=function(key){_2e(key);var _67=_58(key);var _68=_53(_5b,_67);if(_68){return _68.containsKey(key);}\r\nreturn false;};this.containsValue=function(_69){_30(_69);for(var i=0,len=_5a.length;i<len;i++){if(_5a[i][1].containsValue(_69)){return true;}}\r\nreturn false;};this.clear=function(){_5a.length=0;_5b={};};this.isEmpty=function(){return _5a.length===0;};this.keys=function(){var _6c=[];for(var i=0,len=_5a.length;i<len;i++){_5a[i][1].keys(_6c);}\r\nreturn _6c;};this.values=function(){var _6f=[];for(var i=0,len=_5a.length;i<len;i++){_5a[i][1].values(_6f);}\r\nreturn _6f;};this.remove=function(key){_2e(key);var _73=_58(key);var _74=_53(_5b,_73);if(_74){if(_74.removeEntryForKey(key)){if(_74.size()===0){var _75=_4f(_5a,_73,_74.getEqualityFunction(key));_23(_5a,_75[0]);delete _5b[_73];}}}};this.size=function(){var _76=0;for(var i=0,len=_5a.length;i<len;i++){_76+=_5a[i][1].size();}\r\nreturn _76;};};return _57;})();\r\n\r\nmodule.exports = _Hashtable;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/runtime/jshashtable.js\n ** module id = 5\n ** module chunks = 0\n **/","\n// if not defined, declare the compiler object as part of plt\nwindow.plt   = window.plt   || {};\nplt.compiler = require('./structures');\nvar types = require('./runtime/types');\n\n/*\n \n //////////////////////////////////////////////////////////////////////////////\n ///////////////////////////////// PARSER OBJECT //////////////////////////////\n //////////////////////////////////////////////////////////////////////////////\n \n Parser for http://docs.racket-lang.org/htdp-langs/intermediate-lam.html\n \n * Given an Array of SExps, produce an array of Programs or a structured error\n * see structures.js for Program Objects and Error throwing\n \n TODO\n - Perf: give location information to all AST nodes as constructor argument\n - JSLint\n */\n\n(function () {\n 'use strict';\n \n // import frequently-used bindings\n var literal          = plt.compiler.literal;\n var symbolExpr       = plt.compiler.symbolExpr;\n var Program          = plt.compiler.Program;\n var couple           = plt.compiler.couple;\n var ifExpr           = plt.compiler.ifExpr;\n var beginExpr        = plt.compiler.beginExpr;\n var letExpr          = plt.compiler.letExpr;\n var letStarExpr      = plt.compiler.letStarExpr;\n var letrecExpr       = plt.compiler.letrecExpr;\n var localExpr        = plt.compiler.localExpr;\n var andExpr          = plt.compiler.andExpr;\n var orExpr           = plt.compiler.orExpr;\n var condExpr         = plt.compiler.condExpr;\n var caseExpr         = plt.compiler.caseExpr;\n var lambdaExpr       = plt.compiler.lambdaExpr;\n var quotedExpr       = plt.compiler.quotedExpr;\n var unquotedExpr     = plt.compiler.unquotedExpr;\n var quasiquotedExpr  = plt.compiler.quasiquotedExpr;\n var unquoteSplice    = plt.compiler.unquoteSplice;\n var callExpr         = plt.compiler.callExpr;\n var whenUnlessExpr   = plt.compiler.whenUnlessExpr;\n var defFunc          = plt.compiler.defFunc;\n var defVar           = plt.compiler.defVar;\n var defVars          = plt.compiler.defVars;\n var defStruct        = plt.compiler.defStruct;\n var requireExpr      = plt.compiler.requireExpr;\n var provideStatement = plt.compiler.provideStatement;\n var unsupportedExpr  = plt.compiler.unsupportedExpr;\n var throwError       = plt.compiler.throwError;\n \n //////////////////////////////////// UTILITY FUNCTIONS //////////////////////////////\n function isVector(x) { return types.isVector(x.val); }\n function isString(x) { return types.isString(x.val); }\n function isSymbol(x) { return x instanceof symbolExpr; }\n function isLiteral(x){ return x instanceof literal; }\n function isUnsupported(x){ return x instanceof unsupportedExpr;}\n \n // isSymbolEqualTo : symbolExpr symbolExpr -> Boolean\n // are these all symbols of the same value?\n function isSymbolEqualTo(x, y) {\n    x = (x instanceof symbolExpr)? x.val : x;\n    y = (y instanceof symbolExpr)? y.val : y;\n    return x === y;\n }\n \n function isCons(x)  { return x instanceof Array && x.length>=1;}\n function rest(ls)   { return ls.slice(1); }\n \n  // PARSING ///////////////////////////////////////////\n \n   // parse* : sexp list -> Program list\n  function parseStar(sexps) {\n   function parseSExp(sexp) {\n     return isDefinition(sexp) ? parseDefinition(sexp) :\n     isExpr(sexp) ? parseExpr(sexp) :\n     isRequire(sexp) ? parseRequire(sexp) :\n     isProvide(sexp) ? parseProvide(sexp) :\n     throwError(new types.Message([\"Not a Definition, Expression, Library Require, or Provide\"]),\n                                  sexp.location);\n    }\n    return sexps.map(parseSExp);\n  }\n \n  // parse : sexp list -> Program list\n  function parse(sexp) {\n    return (sexp.length === 0) ? [] :\n    (!isCons(sexp)) ? throwError(new types.Message([\"The sexp is not a list of definitions or expressions: \"+sexp]),\n                                sexp.location):\n    parseStar(sexp);\n  }\n\n\n  //////////////////////////////////////// DEFINITION PARSING ////////////////////////////////\n  // (define-struct ...)\n  function isStructDefinition(sexp) {\n    return ((isCons(sexp)) && (isSymbol(sexp[0])) && (isSymbolEqualTo(\"define-struct\", sexp[0])));\n  }\n  // (define ...)\n  function isValueDefinition(sexp) {\n    return (isCons(sexp) && isSymbol(sexp[0]) && isSymbolEqualTo(\"define\", sexp[0]));\n  }\n  // (define-values ...)\n  function isMultiValueDefinition(sexp) {\n    return (isCons(sexp) && isSymbol(sexp[0]) && isSymbolEqualTo(\"define-values\", sexp[0]));\n  }\n  // is it any kind of definition?\n  function isDefinition(sexp) {\n    return isStructDefinition(sexp) || isValueDefinition(sexp) || isMultiValueDefinition(sexp);\n  }\n \n  // : parseDefinition : SExp -> AST (definition)\n  function parseDefinition(sexp) {\n    function parseDefStruct(sexp) {\n      // is it just (define-struct)?\n      if(sexp.length < 2){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected the structure name after define-struct, but nothing's there\"])\n                   , sexp.location);\n      }\n      // is the structure name there?\n      if(!(sexp[1] instanceof symbolExpr)){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected the structure name after define-struct, but found \"\n                                      , new types.ColoredPart(\"something else\", sexp[1].location)])\n                   , sexp.location);\n      }\n      // is it just (define-struct <name>)?\n      if(sexp.length < 3){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected at least one field name (in parentheses) after the \"\n                                      , new types.ColoredPart(\"structure name\", sexp[1].location)\n                                      , \", but nothing's there\"])\n                   , sexp.location);\n      }\n      // is the structure name followed by a list?\n      if(!(sexp[2] instanceof Array)){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected at least one field name (in parentheses) after the \"\n                                      , new types.ColoredPart(\"structure name\", sexp[1].location)\n                                      , \", but found \"\n                                      , new types.ColoredPart(\"something else\", sexp[2].location)])\n                   , sexp.location);\n      }\n      // is it a list of not-all-symbols?\n      sexp[2].forEach(function(arg){\n        if (!(arg instanceof symbolExpr)){\n          throwError(new types.Message([new types.ColoredPart(sexp[0]. val,sexp[0].location)\n                                      , \": expected a field name, but found \"\n                                      , new types.ColoredPart(\"something else\", arg.location)])\n                   , sexp.location);\n        }\n      });\n      // too many expressions?\n      if(sexp.length > 3){\n          var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n              wording1 = (sexp[2].length === 1)? \"field name\" : \"field names\",\n              wording2 = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected nothing after the \"\n                                      , new types.ColoredPart(wording1, sexp[2].location)\n                                      , \", but found \"\n                                      , new types.MultiPart(wording2, extraLocs, false)])\n                     , sexp.location);\n      }\n      return new defStruct(parseIdExpr(sexp[1]), sexp[2].map(parseIdExpr), sexp);\n    }\n    function parseMultiDef(sexp){\n      // is it just (define-values)?\n      if(sexp.length < 2){\n          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expects a list of variables and a body, but found neither\"])\n                     , sexp.location);\n      }\n      // is it just (define-values ... )?\n      if(sexp.length < 3){\n          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expects a list of variables and a body, but found only \"\n                                      , new types.ColoredPart(\"one part\", sexp[1].location)])\n                     , sexp.location);\n      }\n      // is it (define-values <not a list> )?\n      if(!(sexp[1] instanceof Array)){\n          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expects a list of variables and a body, but found \"\n                                      , new types.ColoredPart(\"something else\", sexp[1].location)])\n                     , sexp.location);\n      }\n      // too many parts?\n      if(sexp.length > 3){\n          var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n              wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\"),\n              msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                       , \": expects a list of variables and a body\"\n                                        + \", but found \"\n                                       , new types.MultiPart(wording, extraLocs, false)]);\n          throwError(msg, sexp.location);\n      }\n      return new defVars(sexp[1].map(parseIdExpr), parseExpr(sexp[2]), sexp);\n    }\n    function parseDef(sexp) {\n      // is it just (define)?\n      if(sexp.length < 2){\n          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a variable, or a function name and its variables \"\n                                      + \"(in parentheses), after define, but nothing's there\"])\n                     , sexp.location);\n      }\n      // If it's (define (...)...)\n      if(sexp[1] instanceof Array){\n          // is there at least one element?\n          if(sexp[1].length === 0){\n            throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a name for the function within \"\n                                      , new types.ColoredPart(\"the parentheses\", sexp[1].location)])\n                       , sexp.location);\n          }\n          // is the first element in the list a symbol?\n          if(!(sexp[1][0] instanceof symbolExpr)){\n            throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a function name after the open parenthesis but found \"\n                                      , new types.ColoredPart(\"something else\", sexp[1][0].location)])\n                       , sexp.location);\n          }\n          // is the next element a list of not-all-symbols?\n          sexp[1].forEach(function(arg){\n            if (!(arg instanceof symbolExpr)){\n              throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a variable but found \"\n                                      , new types.ColoredPart(\"something else\", arg.location)])\n                         , sexp.location);\n            }\n          });\n          // is it just (define (<name> <args>))?\n          if(sexp.length < 3){\n              throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                            , \": expected an expression for the function body, but nothing's there\"])\n                         , sexp.location);\n          }\n          // too many parts?\n          if(sexp.length > 3){\n              var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n                  wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n              throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                            , \": expected only one expression for the function body\"\n                                            + \", but found \"\n                                            , new types.MultiPart(wording, extraLocs, false)])\n                         , sexp.location);\n          }\n          var args = rest(sexp[1]).map(parseIdExpr);\n          args.location = sexp[1].location;\n          return new defFunc(parseIdExpr(sexp[1][0]), args, parseExpr(sexp[2]), sexp);\n      }\n      // If it's (define x ...)\n      if(sexp[1] instanceof symbolExpr){\n          // is it just (define x)?\n          if(sexp.length < 3){\n              throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                            , \": expected an expression after the variable \"\n                                            , new types.ColoredPart(sexp[1].val, sexp[1].location)\n                                            , \" but nothing's there\"])\n                         , sexp.location);\n          }\n          // too many parts?\n          if(sexp.length > 3){\n              var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n                  wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n              throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                            , \": expected only one expression after the variable \"\n                                            , new types.ColoredPart(sexp[1].val, sexp[1].location)\n                                            , \", but found \"\n                                            , new types.MultiPart(wording, extraLocs, false)])\n                         , sexp.location);\n          }\n          return new defVar(parseIdExpr(sexp[1]), parseExpr(sexp[2]), sexp);\n      }\n      // If it's (define <invalid> ...)\n      throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                    , \": expected a variable but found \"\n                                    , new types.ColoredPart(\"something else\", sexp[1].location)])\n                         , sexp.location);\n    }\n    var def = isStructDefinition(sexp) ? parseDefStruct(sexp) :\n              isValueDefinition(sexp)  ? parseDef(sexp) :\n              isMultiValueDefinition   ? parseMultiDef(sexp) :\n              throwError(new types.Message([\": expected to find a definition, but found: \"+ sexp]),\n                         sexp.location);\n    def.location = sexp.location;\n   return def;\n  }\n\n\n  //////////////////////////////////////// EXPRESSION PARSING ////////////////////////////////\n  function isExpr(sexp) {\n    return ((!(isDefinition(sexp))) && (!(isRequire(sexp))) && (!(isProvide(sexp))));\n  }\n\n  function parseExpr(sexp) {\n    return isCons(sexp) ? parseExprList(sexp) :\n    parseExprSingleton(sexp);\n  }\n\n  // parseExprList : SExp -> AST\n  // predicates and parsers for call, lambda, local, letrec, let, let*, if, and, or, quote and quasiquote exprs\n  function parseExprList(sexp) {\n    function parseFuncCall(sexp) {\n      if(isSymbolEqualTo(sexp[0], \"unquote\")){\n        throwError(new types.Message([\"misuse of a comma or 'unquote, not under a quasiquoting backquote\"])\n                   , sexp.location\n                   , \"Error-GenericSyntacticError\");\n      }\n      if(isSymbolEqualTo(sexp[0], \"unquote-splicing\")){\n        throwError(new types.Message([\"misuse of a ,@ or unquote-splicing, not under a quasiquoting backquote\"])\n                   , sexp.location\n                   , \"Error-GenericSyntacticError\");\n      }\n      if(isSymbolEqualTo(sexp[0], \"else\")){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp.location)\n                                      , \": not allowed \"\n                                      , new types.ColoredPart(\"here\", sexp.location)\n                                      , \", because this is not a question in a clause\"])\n                   , sexp.location);\n      }\n      return isCons(sexp)? new callExpr(parseExpr(sexp[0]), rest(sexp).map(parseExpr), sexp[0]) :\n                            throwError(new types.Message([\"function call sexp\"]), sexp.location);\n    }\n    function parseLambdaExpr(sexp) {\n      // is it just (lambda)?\n      if(sexp.length === 1){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected at least one variable (in parentheses) after lambda, but nothing's there\"]),\n                    sexp.location);\n      }\n      // is it just (lambda <not-list>)?\n      if(!(sexp[1] instanceof Array)){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected at least one variable (in parentheses) after lambda, but found \"\n                                      , new types.ColoredPart(\"something else\", sexp[1].location)]),\n                    sexp.location);\n      }\n      // is it a list of not-all-symbols?\n      sexp[1].forEach(function(arg){\n        if (!(arg instanceof symbolExpr)){\n          var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                       , \": expected a list of variables after lambda, but found \"\n                                       , new types.ColoredPart(\"something else\", arg.location)]);\n          throwError(msg, sexp.location);\n        }\n      });\n      // is it just (lambda (x))?\n      if(sexp.length === 2){\n          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                        , \": expected an expression for the function body, but nothing's there\"]),\n                    sexp.location);\n      }\n      // too many expressions?\n      if(sexp.length > 3){\n        var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n            wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\"),\n            msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected only one expression for the function body, but found \"\n                                     , new types.MultiPart(wording, extraLocs, false)]);\n        throwError(msg, sexp.location);\n      }\n      var args = sexp[1].map(parseIdExpr);\n      args.location = sexp[1].location;\n      return new lambdaExpr(args, parseExpr(sexp[2]), sexp[0]);\n    }\n    function parseLocalExpr(sexp) {\n      // is it just (local)?\n      if(sexp.length === 1){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                        , \": expected at least one definition (in square brackets) after local,\"\n                                        + \" but nothing's there\"]),\n                    sexp.location);\n      }\n      // is it just (local <not-list>)?\n      if(!(sexp[1] instanceof Array)){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                        , \": expected a collection of definitions, but given \"\n                                        , new types.ColoredPart(\"something else\", sexp[1].location)]),\n                    sexp[1].location);\n      }\n      // is it a list of not-all-definitions?\n      sexp[1].forEach(function(def){\n        if (!isDefinition(def)){\n          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                        , \": expected a definition, but given \"\n                                        , new types.ColoredPart(\"something else\", def.location)]),\n                     def.location);\n        }\n      });\n      // is it just (local [...defs...] ))?\n      if(sexp.length === 2){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a single body, but found none\"]),\n                     sexp.location);\n      }\n      // too many expressions?\n      if(sexp.length > 3){\n        var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n            wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a single body, but found \"\n                                      , new types.MultiPart(wording, extraLocs, false)]),\n                     sexp.location);\n      }\n      return new localExpr(sexp[1].map(parseDefinition), parseExpr(sexp[2]), sexp[0]);\n    }\n    function parseLetrecExpr(sexp) {\n      // is it just (letrec)?\n      if(sexp.length < 3){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected an expression after the bindings, but nothing's there\"]),\n                     sexp.location);\n      }\n      // is it just (letrec <not-list>)?\n      if(!(sexp[1] instanceof Array)){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a key/value pair, but given \"\n                                      , new types.ColoredPart(\"something else\", sexp[1].location)]),\n                     sexp.location);\n      }\n      // is it a list of not-all-bindings?\n      sexp[1].forEach(function(binding){\n        if (!sexpIsCouple(binding)){\n          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                        , \": expected a key/value pair, but given \"\n                                        , new types.ColoredPart(\"something else\", binding.location)]),\n                     binding.location);\n        }\n      });\n      // is it just (letrec (...bindings...) ))?\n      if(sexp.length === 2){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected an expression after the bindings, but nothing's there\"]),\n                     sexp.location);\n      }\n      // too many expressions?\n      if(sexp.length > 3){\n        var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n            wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a single body, but found \"\n                                      , new types.MultiPart(wording, extraLocs, false)]),\n                     sexp.location);\n      }\n      return new letrecExpr(sexp[1].map(parseBinding), parseExpr(sexp[2]), sexp[0]);\n    }\n    function parseLetExpr(sexp) {\n      // is it just (let)?\n      if(sexp.length === 1){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected at least one binding (in parentheses) after let, but nothing's there\"]),\n                     sexp.location);\n      }\n      // is it just (let <not-list>)?\n      if(!(sexp[1] instanceof Array)){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected sequence of key value pairs, but given \"\n                                      , new types.ColoredPart(\"something else\", sexp[1].location)]),\n                     sexp[1].location);\n      }\n      // is it a list of not-all-bindings?\n      sexp[1].forEach(function(binding){\n        if (!sexpIsCouple(binding)){\n          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                        , \": expected a key/value pair, but given \"\n                                      , new types.ColoredPart(\"something else\", binding.location)]),\n                     binding.location);\n        }\n      });\n      // too many expressions?\n      if(sexp.length > 3){\n        var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n            wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a single body, but found \"\n                                      , new types.MultiPart(wording, extraLocs, false)]),\n                     sexp.location);\n      }\n      // is it just (let (...bindings...) ))?\n      if(sexp.length === 2){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a single body, but found none\"]),\n                     sexp.location);\n      }\n      return new letExpr(sexp[1].map(parseBinding), parseExpr(sexp[2]), sexp);\n    }\n    function parseLetStarExpr(sexp) {\n      // is it just (let*)?\n      if(sexp.length === 1){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected an expression after the bindings, but nothing's there\"]),\n                     sexp.location);\n      }\n      // is it just (let* <not-list>)?\n      if(!(sexp[1] instanceof Array)){\n        var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                     , \": expected sequence of key/value pairs, but given \"\n                                     , new types.ColoredPart(\"something else\", sexp[1].location)]);\n        throwError(msg, sexp.location);\n      }\n      // is it a list of not-all-bindings?\n      sexp[1].forEach(function(binding){\n        if (!sexpIsCouple(binding)){\n          throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a key/value pair, but given \"\n                                      , new types.ColoredPart(\"something else\", binding.location)]),\n                     binding.location);\n        }\n      });\n      // is it just (let* (...bindings...) ))?\n      if(sexp.length === 2){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a single body, but found none\"]),\n                     sexp.location);\n      }\n      // too many expressions?\n      if(sexp.length > 3){\n        var extraLocs = sexp.slice(3).map(function(sexp){ return sexp.location; }),\n            wording = extraLocs.length+\" extra \"+((extraLocs.length === 1)? \"part\" : \"parts\");\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a single body, but found \"\n                                      , new types.MultiPart(wording, extraLocs, false)]),\n                    sexp.location);\n      }\n      var bindings = sexp[1].map(parseBinding);\n      bindings.location = sexp[1].location;\n      return new letStarExpr(bindings, parseExpr(sexp[2]), sexp[0]);\n    }\n    function parseIfExpr(sexp) {\n      // Does it have too few parts?\n      if(sexp.length < 4){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a test, a consequence, and an alternative, but all three were not found\"]),\n                    sexp.location);\n      }\n      // Does it have too many parts?\n      if(sexp.length > 4){\n        var extraLocs = sexp.slice(1).map(function(sexp){ return sexp.location; });\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected only a test, a consequence, and an alternative, \"\n                                      , \"but found \"\n                                      , new types.MultiPart(\"more than three of these\", extraLocs, false)]),\n                    sexp.location);\n      }\n      return new ifExpr(parseExpr(sexp[1]), parseExpr(sexp[2]), parseExpr(sexp[3]), sexp[0]);\n    }\n    function parseBeginExpr(sexp) {\n      // is it just (begin)?\n      if(sexp.length < 2){\n        var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                     , \": Inside a begin, expected to find a body, but nothing was found.\"]);\n        throwError(msg, sexp.location);\n      }\n      return new beginExpr(rest(sexp).map(parseExpr), sexp[0]);\n    }\n    function parseAndExpr(sexp) {\n      // and must have 2+ arguments\n      if(sexp.length < 3){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected at least 2 arguments, but given \"\n                                      , (sexp.length===1)? \"0\" : new types.ColoredPart((sexp.length-1).toString(),\n                                                                                       sexp[1].location)]),\n                    sexp.location);\n      }\n      return new andExpr(rest(sexp).map(parseExpr), sexp[0]);\n    }\n    function parseOrExpr(sexp) {\n      // or must have 2+ arguments\n      if(sexp.length < 3){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected at least 2 arguments, but given \"\n                                      , (sexp.length===1)? \"0\" : new types.ColoredPart((sexp.length-1).toString(),\n                                                                                       sexp[1].location)]),\n                    sexp.location);\n      }\n      var orEx = new orExpr(rest(sexp).map(parseExpr), sexp[0]);\n      return orEx;\n    }\n    function parseQuotedExpr(sexp) {\n\n      function parseQuotedItem(sexp) {\n        return isCons(sexp) ? sexp.map(parseQuotedItem)\n          :  (sexp instanceof Array && sexp.length === 0)? sexp // the empty list is allowed inside quotes\n          : /* else */ parseExprSingleton(sexp);\n      }\n      // quote must have exactly one argument\n      if(sexp.length < 2){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a single argument, but did not find one.\"]),\n                    sexp.location);\n      }\n      if(sexp.length > 2){\n        var extraLocs = sexp.slice(1).map(function(sexp){ return sexp.location; });\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a single argument, but found \"\n                                      , new types.MultiPart(\"more than one.\", extraLocs, false)]),\n                    sexp.location);\n      }\n      return new quotedExpr(parseQuotedItem(sexp[1]));\n    }\n\n    return (function () {\n        var peek = sexp[0];\n        var expr = !(isSymbol(peek)) ? parseFuncCall(sexp) :\n                    isSymbolEqualTo(\"λ\", peek)       ? parseLambdaExpr(sexp) :\n                    isSymbolEqualTo(\"lambda\", peek)  ? parseLambdaExpr(sexp) :\n                    isSymbolEqualTo(\"local\", peek)   ? parseLocalExpr(sexp) :\n                    isSymbolEqualTo(\"letrec\", peek)  ? parseLetrecExpr(sexp) :\n                    isSymbolEqualTo(\"let\", peek)     ? parseLetExpr(sexp) :\n                    isSymbolEqualTo(\"let*\", peek)    ? parseLetStarExpr(sexp) :\n                    isSymbolEqualTo(\"cond\", peek)    ? parseCondExpr(sexp) :\n                    isSymbolEqualTo(\"case\", peek)    ? parseCaseExpr(sexp) :\n                    isSymbolEqualTo(\"if\", peek)      ? parseIfExpr(sexp) :\n                    isSymbolEqualTo(\"begin\", peek)   ? parseBeginExpr(sexp) :\n                    isSymbolEqualTo(\"and\", peek)     ? parseAndExpr(sexp) :\n                    isSymbolEqualTo(\"or\", peek)      ? parseOrExpr(sexp) :\n                    isSymbolEqualTo(\"when\", peek)    ? parseWhenUnlessExpr(sexp) :\n                    isSymbolEqualTo(\"unless\", peek)  ? parseWhenUnlessExpr(sexp) :\n                    isSymbolEqualTo(\"quote\", peek)   ? parseQuotedExpr(sexp) :\n                    isSymbolEqualTo(\"quasiquote\", peek)       ? parseQuasiQuotedExpr(sexp) :\n                    isSymbolEqualTo(\"unquote\", peek)          ? parseUnquoteExpr(sexp) :\n                    isSymbolEqualTo(\"unquote-splicing\", peek) ? parseUnquoteSplicingExpr(sexp) :\n                    parseFuncCall(sexp);\n          expr.location = sexp.location;\n          return expr;\n   })();\n  }\n \n  function parseWhenUnlessExpr(sexp){\n    // is it just (when)?\n    if(sexp.length < 3){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected at a test and at least one result after \"+sexp[0]+\", but nothing's there\"]),\n                    sexp.location);\n    }\n    var exprs = sexp.slice(2), result = new whenUnlessExpr(parseExpr(sexp[1]), parse(exprs), sexp[0]);\n    exprs.location = exprs[0].location; // FIXME: merge the locations\n    result.location = sexp.location;\n    return result;\n  }\n\n  function parseCondExpr(sexp) {\n    // is it just (cond)?\n    if(sexp.length === 1){\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected at least one clause after cond, but nothing's there\"]),\n                    sexp.location);\n    }\n    var condLocs = [sexp[0].location, sexp.location.start(), sexp.location.end()];\n \n    function isElseClause(couple){ return isSymbol(couple[0]) && isSymbolEqualTo(couple[0], \"else\"); }\n \n    function checkCondCouple(clause) {\n      var clauseLocations = [clause.location.start(), clause.location.end()];\n      // is it (cond ...<not-a-clause>..)?\n      if(!(clause instanceof Array)){\n        throwError(new types.Message([new types.MultiPart(sexp[0].val, condLocs, true)\n                                      , \": expected a clause with a question and an answer, but found \"\n                                      , new types.ColoredPart(\"something else\", clause.location)]),\n                    clause.location);\n      }\n      if(clause.length === 0){\n        throwError(new types.Message([new types.MultiPart(sexp[0].val, condLocs, true)\n                                      , \": expected a clause with a question and an answer, but found an \"\n                                      , new types.MultiPart(\"empty part\", clauseLocations, true)]),\n                    clause.location);\n      }\n      if(clause.length === 1){\n        throwError(new types.Message([new types.MultiPart(sexp[0].val, condLocs, true)\n                                      , \": expected a clause with a question and an answer, but found a \"\n                                      , new types.MultiPart(\"clause\", clauseLocations, true)\n                                      , \" with only \"\n                                      , new types.MultiPart(\"one part\", [clause[0].location], false)]),\n                    clause.location);\n      }\n      if(clause.length > 2){\n        var extraLocs = clause.map(function(sexp){ return sexp.location; }),\n            wording = extraLocs.length+\" parts\";\n        throwError(new types.Message([new types.MultiPart(sexp[0].val, condLocs, true)\n                                      , \": expected a clause with a question and an answer, but found \"\n                                      , new types.MultiPart(\"a clause\", clauseLocations, true)\n                                      , \" with \"\n                                      , new types.MultiPart(wording, extraLocs, false)]),\n                    clause.location);\n      }\n    }\n \n \n    function parseCondCouple(clause) {\n        var test = parseExpr(clause[0]), result = parseExpr(clause[1]), cpl = new couple(test, result);\n        // the only un-parenthesized keyword allowed in the first slot is 'else'\n        if((plt.compiler.keywords.indexOf(test.val) > -1) && (test.val !== \"else\")){\n          throwError(new types.Message([new types.ColoredPart(test.val, test.location)\n                                        , \": expected an open parenthesis before \"\n                                        , test.val\n                                        , \", but found none\"]),\n                     test.location);\n        }\n        test.isClause = true; // used to determine appropriate \"else\" use during desugaring\n        cpl.location = clause.location;\n        return cpl;\n    }\n\n    // first check the couples, then parse if there's no problem\n    rest(sexp).forEach(checkCondCouple);\n    var numClauses = rest(sexp).length,\n        parsedClauses = rest(sexp).map(parseCondCouple);\n    // if we see an else and we haven't seen all other clauses first\n    // throw an error that points to the next clause (rst + the one we're looking at + \"cond\")\n    rest(sexp).forEach(function(couple, idx){\n     if(isElseClause(couple) && (idx < (numClauses-1))){\n       throwError(new types.Message([new types.MultiPart(\"cond\", condLocs, true)\n                                     , \": \", \"found an \"\n                                     , new types.ColoredPart(\"else clause\", couple.location)\n                                     , \" that isn't the last clause in its cond expression; there is \"\n                                     , new types.ColoredPart(\"another clause\", sexp[idx+2].location)\n                                     , \" after it\"]),\n                  couple.location);\n      }\n    });\n    return new condExpr(parsedClauses, sexp[0]);\n  }\n\n  function parseCaseExpr(sexp) {\n    // is it just (case)?\n    if(sexp.length === 1){\n        var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                     , \": expected at least one clause after case, but nothing's there\"]);\n        throwError(msg, sexp.location);\n    }\n    var caseLocs = [sexp[0].location, sexp.location.start(), sexp.location.end()];\n    if(sexp.length === 2){\n        var msg = new types.Message([new types.MultiPart(sexp[0].val, caseLocs, true)\n                                    , \": expected a clause with at least one choice (in parentheses)\"\n                                     + \" and an answer after the expression, but nothing's there\"]);\n        throwError(msg, sexp.location);\n    }\n \n    function checkCaseCouple(clause) {\n      var clauseLocations = [clause.location.start(), clause.location.end()];\n      if(!(clause instanceof Array)){\n        var msg = new types.Message([new types.MultiPart(sexp[0].val, caseLocs, true)\n                                     , \": expected a clause with at least one choice (in parentheses), but found \"\n                                     , new types.ColoredPart(\"something else\", clause.location)]);\n        throwError(msg, sexp.location);\n      }\n      if(clause.length === 0){\n        var msg = new types.Message([new types.MultiPart(sexp[0].val, caseLocs, true)\n                                     , \": expected at least one choice (in parentheses) and an answer, but found an \"\n                                     , new types.ColoredPart(\"empty part\", clause.location)]);\n        throwError(msg, sexp.location);\n      }\n      if(!( (clause[0] instanceof Array) ||\n            ((clause[0] instanceof symbolExpr) && isSymbolEqualTo(clause[0], \"else\")))){\n        var msg = new types.Message([new types.MultiPart(sexp[0].val, caseLocs, true)\n                                     , \": expected 'else', or at least one choice in parentheses, but found \"\n                                     , new types.ColoredPart(\"something else\", clause.location)]);\n        throwError(msg, sexp.location);\n      }\n      if(clause.length === 1){\n        var msg = new types.Message([new types.MultiPart(sexp[0].val, caseLocs, true)\n                                     , \": expected a clause with a question and an answer, but found a \"\n                                     , new types.MultiPart(\"clause\", clauseLocations, true)\n                                     , \" with only \"\n                                     , new types.ColoredPart(\"one part\", clause[0].location)]);\n        throwError(msg, sexp.location);\n      }\n      if(clause.length > 2){\n        var extraLocs = clause.map(function(sexp){ return sexp.location; }),\n            wording = extraLocs.length+\" parts\",\n            msg = new types.Message([new types.MultiPart(sexp[0].val, caseLocs, true)\n                                     , \": expected only one expression for the answer in the case clause, but found a \"\n                                     , new types.MultiPart(\"clause\", clauseLocations, true)\n                                     , \" with \"\n                                     , new types.MultiPart(wording, extraLocs, false)]);\n        throwError(msg, sexp.location);\n      }\n    }\n \n    // is this sexp actually an else clause?\n    function isElseClause(sexp){ return isSymbol(sexp[0]) && (sexp[0].val===\"else\");}\n\n    // read the first item in the clause as a quotedExpr, and parse the second\n    // if it's an else clause, however, leave it alone\n    function parseCaseCouple(sexp) {\n        var test = isElseClause(sexp)? sexp[0] : new quotedExpr(sexp[0]),\n            result = parseExpr(sexp[1]), cpl = new couple(test, result);\n        test.isClause = true; // used to determine appropriate \"else\" use during desugaring\n        cpl.location = sexp.location;\n        return cpl;\n    }\n \n    var clauses = sexp.slice(2);\n    // first check the couples, then parse if there's no problem\n    clauses.forEach(checkCaseCouple);\n    var numClauses = clauses.length,\n        parsedClauses = clauses.map(parseCaseCouple);\n\n    // if we see an else and we haven't seen all other clauses first\n    // throw an error that points to the next clause (rst + the one we're looking at + \"cond\")\n    clauses.forEach(function(couple, idx){\n     if(isElseClause(couple) && (idx < (numClauses-1))){\n        var msg = new types.Message([new types.MultiPart(\"case\", caseLocs, true)\n                                     , \": found an \"\n                                     , new types.ColoredPart(\"else clause\", couple.location)\n                                     , \"that isn't the last clause in its case expression; there is \"\n                                     , new types.ColoredPart(\"another clause\", sexp[idx+2].location)\n                                     , \" after it\"]);\n        throwError(msg, sexp.location);\n      }\n    });\n    return new caseExpr(parseExpr(sexp[1]), parsedClauses, sexp[0]);\n  }\n \n  function parseBinding(sexp) {\n    if(sexpIsCouple(sexp)){\n        var binding = new couple(parseIdExpr(sexp[0]), parseExpr(sexp[1]));\n        binding.location = sexp.location;\n        binding.stx = sexp;\n        return binding;\n    } else {\n        throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected a sequence of key/value pairs, but given \"\n                                      , new types.ColoredPart(\"something else\", sexp[0].location)]),\n                   sexp.location);\n    }\n  }\n\n  function parseUnquoteExpr(sexp, depth) {\n    if (typeof depth === 'undefined') {\n      throwError( new types.Message([\"misuse of a comma or 'unquote, not under a quasiquoting backquote\"])\n                , sexp.location\n                , \"Error-GenericSyntacticError\");\n    } else if((sexp.length !== 2)){\n     throwError( new types.Message([\"Inside an unquote, expected to find a single argument, but found \"+(sexp.length-1)])\n               , sexp.location);\n   } else if (depth === 1) {\n     var result = new unquotedExpr(parseExpr(sexp[1]))\n     result.location = sexp[1].location\n     return result;\n   } else if (depth > 1) {\n     var result = new unquotedExpr(parseQuasiQuotedItem(sexp[1], depth-1))\n     result.location = sexp[1].location\n     return result;\n   } else {\n     throwError( new types.Message([\"ASSERTION FAILURE: depth should have been undefined, or a natural number\"])\n               , sexp.location);\n   }\n  }\n\n  function parseUnquoteSplicingExpr(sexp, depth) {\n    if (typeof depth === 'undefined') {\n      throwError( new types.Message([\"misuse of a ,@ or unquote-splicing, not under a quasiquoting backquote\"])\n                , sexp.location\n                , \"Error-GenericSyntacticError\");\n    } else if((sexp.length !== 2)){\n      throwError(new types.Message([\"Inside an unquote-splicing, expected to find a single argument, but found \"+(sexp.length-1)])\n                 , sexp.location);\n    } else if (depth === 1) {\n      var result =  new unquoteSplice(parseExpr(sexp[1]))\n      result.location = sexp[1].location\n      return result;\n    } else if (depth > 1) {\n      var result =  new unquoteSplice(parseQuasiQuotedItem(sexp[1], depth-1))\n      result.location = sexp[1].location\n      return result;\n    } else {\n     throwError( new types.Message([\"ASSERTION FAILURE: depth should have been undefined, or a natural number\"])\n               , sexp.location);\n    }\n  }\n\n  /* This is what we use in place of `parseExpr` when we're in \"data-mode\",  */\n  /* i.e. there's an active quasiquote. Active is a bit awkward to describe, */\n  /* but basically it's an unmatch quasiquote, if we think of unquotes as    */\n  /* matching quasiquotes, so:                                               */\n  /*   ``,(+ 1 2)                                                            */\n  /* has an active quasiquote while reading (+ 1 2), whereas:                */\n  /*   ``,,(+ 1 2)                                                           */\n  /* does not.                                                               */\n  function parseQuasiQuotedItem(sexp, depth) {\n    if (isCons(sexp) && sexp[0].val === 'unquote'){\n      return parseUnquoteExpr(sexp, depth);\n    } else if(isCons(sexp) && sexp[0].val === 'unquote-splicing'){\n      return parseUnquoteSplicingExpr(sexp, depth);\n    } else if(isCons(sexp) && sexp[0].val === 'quasiquote'){\n      return parseQuasiQuotedExpr(sexp, depth);\n    } else if(isCons(sexp)){\n       var res = sexp.map(function (x) {return parseQuasiQuotedItem(x, depth)});\n       res.location = sexp.location;\n       return res;\n    } else if( depth === 0){\n      return parseExpr(sexp);\n    } else {\n      return (function () {\n              var res = new quotedExpr(sexp);\n              res.location=sexp.location;\n              return res;})()\n    }\n\n  }\n\n  function parseQuasiQuotedExpr(sexp, depth) {\n    depth = (typeof depth === 'undefined') ? 0 : depth;\n    // quasiquote must have exactly one argument\n    if(sexp.length < 2){\n      throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                    , \": expected a single argument, but did not find one \"]),\n                  sexp.location);\n    }\n    if(sexp.length > 2){\n      var extraLocs = sexp.slice(1).map(function(sexp){ return sexp.location; });\n      throwError(new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                    , \": expected a single argument, but found \"\n                                    , new types.MultiPart(\"more than one.\", extraLocs, false)]),\n                  sexp.location);\n    }\n    // if the argument is (unquote-splicing....), throw an error\n    if(isCons(sexp[1]) && isSymbolEqualTo(sexp[1][0], \"unquote-splicing\")){\n      throwError(new types.Message([\"misuse of ,@ or `unquote-splicing' within a quasiquoting backquote\"]), sexp.location);\n    }\n\n    var quoted = parseQuasiQuotedItem(sexp[1], depth+1);\n    quoted.location = sexp[1].location;\n    var result = new quasiquotedExpr(quoted);\n    result.location = sexp.location;\n    return result;\n  }\n \n  // replace all undefineds with the last sexp, and convert to a function call\n  function parseVector(sexp){\n    function buildZero(){\n      var lit = new literal(0);\n      lit.location = sexp.location;\n      return lit;\n    }\n    var unParsedVector = sexp.val,\n        vals = parseStar(unParsedVector.elts.filter(function(e){return e!==undefined;})),\n        last = (vals.length===0)? buildZero() : vals[vals.length-1], // if they're all undefined, use 0\n        elts = unParsedVector.elts.map(function(v){return (v===undefined)? last : parseExpr(v);});\n    var vectorFunc = new symbolExpr(\"vector\"),\n        buildVector = new callExpr(vectorFunc, elts);\n    vectorFunc.location = buildVector.location = sexp.location;\n    return buildVector;\n  }\n  \n  function parseExprSingleton(sexp) {\n    var singleton = isUnsupported(sexp) ? sexp :\n                    isVector(sexp)  ? parseVector(sexp) :\n                    isSymbol(sexp) ? sexp :\n                    isLiteral(sexp) ? sexp :\n                    isSymbolEqualTo(\"quote\", sexp) ? new quotedExpr(sexp) :\n                    isSymbolEqualTo(\"empty\", sexp) ? new callExpr(new symbolExpr(\"list\"), []) :\n      throwError(new types.Message([new types.ColoredPart(\"( )\", sexp.location)\n                                    , \": expected a function, but nothing's there\"])\n                 , sexp.location);\n   singleton.location = sexp.location;\n   return singleton;\n  }\n\n  function parseIdExpr(sexp) {\n    return isSymbol(sexp) ? sexp :\n    throwError(new types.Message([\"ID\"]), sexp.location);\n  }\n\n  function isTupleStartingWithOfLength(sexp, symbol, n) {\n    return ((isCons(sexp)) && (sexp.length === n) && (isSymbol(sexp[0])) && (isSymbolEqualTo(sexp[0], symbol)));\n  }\n\n  function sexpIsCouple(sexp) {\n    return ((isCons(sexp)) && ((sexp.length === 2)));\n  }\n\n  function sexpIsCondListP(sexp) {\n    return ((isCons(sexp)) && (sexp.length >= 2) && (isSymbol(sexp[0])) && (isSymbolEqualTo(sexp[0], \"cond\")));\n  }\n\n  //////////////////////////////////////// REQUIRE PARSING ////////////////////////////////\n  function isRequire(sexp) {\n    return isCons(sexp) && isSymbol(sexp[0]) && isSymbolEqualTo(sexp[0], \"require\");\n  }\n\n  function parseRequire(sexp) {\n    // is it (require)?\n    if(sexp.length < 2){\n      var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                   , \": expected a module name after `require', but found nothing\"]);\n      throwError(msg, sexp.location);\n    }\n    // if it's (require (lib...))\n    if((sexp[1] instanceof Array) && isSymbolEqualTo(sexp[1][0], \"lib\")){\n        // is it (require (lib)) or (require (lib <string>))\n        if(sexp[1].length < 3){\n          var partsNum = sexp[1].slice(1).length,\n              partsStr = partsNum + ((partsNum===1)? \" part\" : \" parts\"),\n              msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                      , \": expected at least two strings after \"\n                                      , new types.ColoredPart(\"lib\", sexp[1][0].location)\n                                      , \" but found only \"\n                                      , partsStr]);\n           throwError(msg, sexp.location);\n        }\n        // is it (require (lib not-strings))?\n        rest(sexp[1]).forEach(function(lit){\n          if (!(isString(lit))){\n            var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                        , \": expected a string for a library collection, but found \"\n                                        , new types.ColoredPart(\"something else\", str.location)]);\n            throwError(msg, sexp.location);\n          }\n         });\n    // if it's (require (planet...))\n    } else if((sexp[1] instanceof Array) && isSymbolEqualTo(sexp[1][0], \"planet\")){\n      var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                   , \": Importing PLaneT pacakges is not supported at this time\"]);\n      throwError(msg, sexp.location);\n    // if it's (require <not-a-string-or-symbol>)\n    } else if(!((sexp[1] instanceof symbolExpr) || isString(sexp[1]))){\n      var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                   , \": expected a module name as a string or a `(lib ...)' form, but found \"\n                                   , new types.ColoredPart(\"something else\", sexp[1].location)]);\n      throwError(msg, sexp.location);\n    }\n    var req = new requireExpr(sexp[1], sexp[0]);\n    req.location = sexp.location;\n    return req;\n  }\n\n  //////////////////////////////////////// PROVIDE PARSING ////////////////////////////////\n function isProvide(sexp) {\n    return isCons(sexp) && isSymbol(sexp[0]) && isSymbolEqualTo(sexp[0], \"provide\");\n }\n function parseProvide(sexp) {\n    var clauses = rest(sexp).map(function(p){\n        // symbols are ok\n        if(p instanceof symbolExpr){ return p;}\n        // (struct-out sym) is ok\n        if((p instanceof Array) && (p.length == 2)\n           && (p[0] instanceof symbolExpr) && isSymbolEqualTo(p[0], \"struct-out\")\n           && (p[1] instanceof symbolExpr)){\n          return p;\n        }\n        // everything else is NOT okay\n        var msg = new types.Message([new types.ColoredPart(sexp[0].val, sexp[0].location)\n                                     , \": I don't recognize the syntax of this \"\n                                     , new types.ColoredPart(\"clause\", p.location)]);\n        throwError(msg, sexp.location);\n    });\n    var provide = new provideStatement(clauses, sexp[0]);\n    provide.location = sexp.location;\n    return provide;\n  }\n\n  /////////////////////\n  /* Export Bindings */\n  /////////////////////\n plt.compiler.parse = function(sexp, debug){\n      var start = new Date().getTime();\n      try{ var AST = parse(sexp); AST.location = sexp.location; }   // do the actual work\n      catch(e) { console.log(\"PARSING ERROR\"); throw e; }\n      var end = new Date().getTime();\n      if(debug){\n        console.log(\"Parsed in \"+(Math.floor(end-start))+\"ms\");\n        console.log(AST);\n      }\n      return AST;\n  };\n})();\n\nmodule.exports = plt.compiler;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/parser.js\n ** module id = 6\n ** module chunks = 0\n **/","require('./structures');\nrequire('./modules');\n// if not defined, declare the compiler object as part of plt\nwindow.plt   = window.plt   || {};\nplt.compiler = plt.compiler || {};\nvar types = require('./runtime/types');\n\n/*\n TODO\n - stop using synchronous XmlHttpRequests -> probably only after the compiler is folded into the evaluator\n*/\n\n(function () {\n 'use strict';\n \n // import frequently-used bindings\n var literal          = plt.compiler.literal;\n var symbolExpr       = plt.compiler.symbolExpr;\n var Program          = plt.compiler.Program;\n var couple           = plt.compiler.couple;\n var ifExpr           = plt.compiler.ifExpr;\n var beginExpr        = plt.compiler.beginExpr;\n var letExpr          = plt.compiler.letExpr;\n var letStarExpr      = plt.compiler.letStarExpr;\n var letrecExpr       = plt.compiler.letrecExpr;\n var localExpr        = plt.compiler.localExpr;\n var andExpr          = plt.compiler.andExpr;\n var orExpr           = plt.compiler.orExpr;\n var condExpr         = plt.compiler.condExpr;\n var caseExpr         = plt.compiler.caseExpr;\n var lambdaExpr       = plt.compiler.lambdaExpr;\n var quotedExpr       = plt.compiler.quotedExpr;\n var unquotedExpr     = plt.compiler.unquotedExpr;\n var quasiquotedExpr  = plt.compiler.quasiquotedExpr;\n var unquoteSplice    = plt.compiler.unquoteSplice;\n var callExpr         = plt.compiler.callExpr;\n var whenUnlessExpr   = plt.compiler.whenUnlessExpr;\n var defFunc          = plt.compiler.defFunc;\n var defVar           = plt.compiler.defVar;\n var defVars          = plt.compiler.defVars;\n var defStruct        = plt.compiler.defStruct;\n var requireExpr      = plt.compiler.requireExpr;\n var provideStatement = plt.compiler.provideStatement;\n var unsupportedExpr  = plt.compiler.unsupportedExpr;\n \n var throwError       = plt.compiler.throwError;\n var structBinding    = plt.compiler.structBinding;\n var constantBinding  = plt.compiler.constantBinding;\n var functionBinding  = plt.compiler.functionBinding;\n var moduleBinding    = plt.compiler.moduleBinding;\n var knownModules     = plt.compiler.knownModules;\n \n  // checkDuplicateIdentifiers : [listof SymbolExprs], Program -> Void\n  // sort the array, and throw errors for non-symbols, keywords or duplicates\n  function checkDuplicateIdentifiers(lst, stx, loc){\n    var visitedIds = {}; // initialize a dictionary of ids we've seen\n    lst.forEach(function(id){\n        if(!(id instanceof symbolExpr)){\n          throwError(\"expected identifier \"+id.val, id.location);\n        } else if(visitedIds[id.val]) { // if we've seen this variable before, throw an error\n          throwError(new types.Message([new types.ColoredPart(stx.toString(), stx.location),\n                                    \": found \",\n                                    new types.ColoredPart(\"a variable\", id.location),\n                                    \" that is already used \",\n                                    new types.ColoredPart(\"here\", visitedIds[id.val].location)])\n                     , id.location);\n        } else {\n          visitedIds[id.val] = id; // otherwise, record the identifier as being visited\n        }\n                         \n    });\n  }\n \n // tag-application-operator/module: Stx module-name -> Stx\n // Adjust the lexical context of the func so it refers to the environment of a particular module.\n function tagApplicationOperator_Module(application, moduleName){\n    // get the module's env\n    var module = plt.compiler.defaultModuleResolver(moduleName),\n        env = new plt.compiler.emptyEnv().extendEnv_moduleBinding(module);\n    // assign it as the context of the function, and each of the arguments\n    [application.func].concat(application.args).forEach(function(expr){expr.context = env;});\n    return application;\n }\n\n // forceBooleanContext: stx, loc, bool -> stx\n // Force a boolean runtime test on the given expression.\n function forceBooleanContext(stx, loc, boolExpr){\n    stx = new literal(new types.string(stx.toString())); // turn the stx object into a string literal\n    var verifyCall  = new symbolExpr(\"verify-boolean-branch-value\"),\n        stxQuote    = new quotedExpr(stx),\n        locQuote    = new quotedExpr(new literal(loc.toVector())),\n        boolLocQuote= new quotedExpr(new literal(boolExpr.location.toVector())),\n        runtimeCall = new callExpr(verifyCall, [stxQuote, locQuote, boolExpr, boolLocQuote]);\n    runtimeCall.location = verifyCall.location = boolExpr.location;\n    stxQuote.location=locQuote.location=boolLocQuote.location = boolExpr.location;\n    tagApplicationOperator_Module(runtimeCall, 'moby/runtime/kernel/misc');\n    return runtimeCall;\n }\n \n //////////////////////////////////////////////////////////////////////////////\n // DESUGARING ////////////////////////////////////////////////////////////////\n\n // desugarProgram : Listof Programs null/pinfo -> [Listof Programs, pinfo]\n // desugar each program, appending those that desugar to multiple programs\n function desugarProgram(programs, pinfo, isTopLevelExpr){\n      var acc = [ [], (pinfo || new plt.compiler.pinfo())];\n      var res = programs.reduce((function(acc, p){\n            var desugaredAndPinfo = p.desugar(acc[1]);\n            // if it's an expression, insert a print-values call so it shows up in the repl\n            if(plt.compiler.isExpression(p) && isTopLevelExpr){\n              var printValues = new symbolExpr(\"print-values\"),\n                  printCall = new callExpr(printValues, [desugaredAndPinfo[0]]);\n               // set the location of the print-values call to that of the expression\n              printValues.location = printCall.location = desugaredAndPinfo[0].location;\n              desugaredAndPinfo[0] = printCall;\n              tagApplicationOperator_Module(printCall,'moby/runtime/kernel/misc');\n            }\n            if(desugaredAndPinfo[0].length){\n              acc[0] = acc[0].concat(desugaredAndPinfo[0]);\n            } else {\n              acc[0].push(desugaredAndPinfo[0]);\n            }\n            return [acc[0], desugaredAndPinfo[1]];\n        }), acc);\n      res[0].location = programs.location;\n      return res;\n }\n \n // Program.prototype.desugar: pinfo -> [Program, pinfo]\n Program.prototype.desugar = function(pinfo){ return [this, pinfo]; };\n defFunc.prototype.desugar = function(pinfo){\n    // check for duplicate arguments\n    checkDuplicateIdentifiers([this.name].concat(this.args), this.stx[0], this.location);\n    // check for non-symbol arguments\n    this.args.forEach(function(arg){\n       if(!(arg instanceof symbolExpr)){\n        throwError(new types.Message([new types.ColoredPart(this.stx.val, this.stx.location)\n                                , \": expected a variable but found \"\n                                , new types.ColoredPart(\"something else\", arg.location)])\n                   , sexp.location);\n      }\n    });\n    var bodyAndPinfo = this.body.desugar(pinfo),\n        newDefFunc = new defFunc(this.name, this.args, bodyAndPinfo[0], this.stx);\n    newDefFunc.location = this.location;\n    return [newDefFunc, bodyAndPinfo[1]];\n };\n defVar.prototype.desugar = function(pinfo){\n    // convert (define f (lambda (x) x)) into (define (f x) x)\n    if(this.expr instanceof lambdaExpr){\n      var newDefFunc = new defFunc(this.name, this.expr.args, this.expr.body, this.stx);\n      newDefFunc.location = this.location;\n      return newDefFunc.desugar(pinfo);\n    } else {\n      var exprAndPinfo = this.expr.desugar(pinfo),\n          newDefVar = new defVar(this.name, exprAndPinfo[0], this.stx);\n      newDefVar.location = this.location;\n      return [newDefVar, exprAndPinfo[1]];\n    }\n };\n defVars.prototype.desugar = function(pinfo){\n    var exprAndPinfo = this.expr.desugar(pinfo),\n        newDefVars = new defVars(this.names, exprAndPinfo[0], this.stx);\n    newDefVars.location = this.location;\n    return [newDefVars, exprAndPinfo[1]];\n };\n defStruct.prototype.desugar = function(pinfo){\n    var that = this,\n        ids = ['make-'+this.name.val, this.name.val+'?', this.name.val+'-ref', this.name.val+'-set!'],\n        idSymbols = ids.map(function(id){return new symbolExpr(id);}),\n        makeStructTypeFunc = new symbolExpr('make-struct-type'),\n        makeStructTypeArgs = [new quotedExpr(new symbolExpr(this.name.val)),\n                              new literal(false),\n                              new literal(this.fields.length),\n                              new literal(0)],\n        makeStructTypeCall = new callExpr(makeStructTypeFunc, makeStructTypeArgs);\n    // set location for all of these nodes\n    [makeStructTypeCall, makeStructTypeFunc].concat(idSymbols, makeStructTypeArgs).forEach(function(p){p.location = that.location});\n \n    // make the define-values stx object, but store the original stx for define-struct\n    var defineValuesStx = new defVars([this.name].concat(idSymbols), makeStructTypeCall, this.stx),\n        stxs = [defineValuesStx];\n    defineValuesStx.location = this.location;\n    // given a field, make a definition that binds struct-field to the result of\n    // a make-struct-field accessor call in the runtime\n    function makeAccessorDefn(f, i){\n      var makeFieldFunc = new symbolExpr('make-struct-field-accessor'),\n          makeFieldArgs = [new symbolExpr(that.name.val+'-ref'), new literal(i), new quotedExpr(new symbolExpr(f.val))],\n          makeFieldCall = new callExpr(makeFieldFunc, makeFieldArgs),\n          accessorSymbol= new symbolExpr(that.name.val+'-'+f.val),\n          defineVar = new defVar(accessorSymbol, makeFieldCall);\n      // set location for all of these nodes\n      [defineVar, makeFieldFunc, makeFieldCall, accessorSymbol].concat(makeFieldArgs).forEach(function(p){p.location = f.location});\n      stxs.push(defineVar);\n    }\n    this.fields.forEach(makeAccessorDefn);\n    return [stxs, pinfo];\n };\n beginExpr.prototype.desugar = function(pinfo){\n    var exprsAndPinfo = desugarProgram(this.exprs, pinfo),\n        newBeginExpr = new beginExpr(exprsAndPinfo[0], this.stx);\n    newBeginExpr.location = this.location;\n    return [newBeginExpr, exprsAndPinfo[1]];\n };\n lambdaExpr.prototype.desugar = function(pinfo){\n    // if this was parsed from raw syntax, check for duplicate arguments\n    if(this.stx) checkDuplicateIdentifiers(this.args, this.stx, this.location);\n    var bodyAndPinfo = this.body.desugar(pinfo),\n        newLambdaExpr = new lambdaExpr(this.args, bodyAndPinfo[0], this.stx);\n    newLambdaExpr.location = this.location;\n    return [newLambdaExpr, bodyAndPinfo[1]];\n };\n localExpr.prototype.desugar = function(pinfo){\n    var defnsAndPinfo = desugarProgram(this.defs, pinfo),\n        exprAndPinfo = this.body.desugar(defnsAndPinfo[1]),\n        newLocalExpr = new localExpr(defnsAndPinfo[0], exprAndPinfo[0], this.stx);\n    newLocalExpr.location = this.location;\n    return [newLocalExpr, exprAndPinfo[1]];\n };\n callExpr.prototype.desugar = function(pinfo){\n    var exprsAndPinfo = desugarProgram([this.func].concat(this.args), pinfo),\n        newCallExpr = new callExpr(exprsAndPinfo[0][0], exprsAndPinfo[0].slice(1), this.stx);\n    newCallExpr.location = this.location;\n    return [newCallExpr, exprsAndPinfo[1]];\n };\n ifExpr.prototype.desugar = function(pinfo){\n    var exprsAndPinfo = desugarProgram([this.predicate,\n                                        this.consequence,\n                                        this.alternative],\n                                       pinfo),\n        predicate = forceBooleanContext(this.stx, this.stx.location, exprsAndPinfo[0][0]),\n        consequence = exprsAndPinfo[0][1],\n        alternative = exprsAndPinfo[0][2],\n        newIfExpr = new ifExpr(predicate, consequence, alternative, this.stx);\n    newIfExpr.location = this.location;\n    return [newIfExpr, exprsAndPinfo[1]];\n };\n whenUnlessExpr.prototype.desugar = function(pinfo){\n    var begin_exp = new beginExpr(this.exprs, this.stx),\n        void_exp = new symbolExpr('void'),\n        call_exp = new callExpr(void_exp, [], this.stx),\n        consequence = (this.stx.val===\"when\")? begin_exp : call_exp,\n        alternative = (this.stx.val===\"when\")? call_exp : begin_exp;\n    begin_exp.location = this.exprs.location;\n    void_exp.location = call_exp.location = this.location;\n    // desugar each expression and construct an ifExpr\n    var exprsAndPinfo = desugarProgram([this.predicate,\n                                        consequence,\n                                        alternative],\n                                       pinfo),\n        if_exp = new ifExpr(exprsAndPinfo[0][0], exprsAndPinfo[0][1], exprsAndPinfo[0][2], this.stx);\n    if_exp.location = this.location;\n    // DON'T desugar the ifExpr -- we don't forceBooleanContext on when/unless!\n    return [if_exp, exprsAndPinfo[1]];\n };\n // letrecs become locals\n letrecExpr.prototype.desugar = function(pinfo){\n    function bindingToDefn(b){\n      var def = new defVar(b.first, b.second, b.stx);\n      def.location = b.location;\n      return def\n    };\n    var localAndPinfo = new localExpr(this.bindings.map(bindingToDefn), this.body, this.stx).desugar(pinfo);\n    localAndPinfo[0].location = this.location;\n    return localAndPinfo;\n };\n // lets become calls\n letExpr.prototype.desugar = function(pinfo){\n    // utility functions for accessing first and second\n    function coupleFirst(x) { return x.first; };\n    function coupleSecond(x) { return x.second; };\n\n    var ids   = this.bindings.map(coupleFirst),\n        exprs = this.bindings.map(coupleSecond),\n        lambda= new lambdaExpr(ids, this.body, this.stx),\n        call  = new callExpr(lambda, exprs);\n    lambda.location = call.location = this.location;\n    return call.desugar(pinfo);\n };\n // let*s become nested lets\n letStarExpr.prototype.desugar = function(pinfo){\n    function bindingToLet(body, binding){\n      var let_exp = new letExpr([binding], body, binding.stx);\n      let_exp.location = binding.location;\n      return let_exp;\n    }\n    // if there are no bindings, desugar the body. Otherwise, reduce to nested lets first\n    if(this.bindings.length === 0) return this.body.desugar(pinfo);\n    else return this.bindings.reduceRight(bindingToLet, this.body).desugar(pinfo);\n };\n // conds become nested ifs\n condExpr.prototype.desugar = function(pinfo){\n    // base case is all-false\n    var condExhausted = new symbolExpr(\"throw-cond-exhausted-error\"),\n        exhaustedLoc = new quotedExpr(new literal(this.location.toVector())),\n        expr = tagApplicationOperator_Module(new callExpr(condExhausted, [exhaustedLoc])\n                                             , \"moby/runtime/kernel/misc\");\n    var ifStx = new symbolExpr(\"if\");\n    ifStx.location = this.stx.location;\n \n    expr.location = condExhausted.location = exhaustedLoc.location = this.location;\n    for(var i=this.clauses.length-1; i>-1; i--){\n      // desugar else to true\n      if(this.clauses[i].first instanceof symbolExpr && this.clauses[i].first.val === \"else\"){\n        this.clauses[i].first.val = \"true\";\n      }\n      expr = new ifExpr(this.clauses[i].first, this.clauses[i].second, expr, this.stx);\n      expr.location = this.location;\n    }\n    return expr.desugar(pinfo);\n };\n // case become nested ifs, with ormap as the predicate\n caseExpr.prototype.desugar = function(pinfo){\n    var that = this,\n        caseStx = new symbolExpr(\"if\"); // TODO: The server returns \"if\" here, but I am almost certain it should be \"case\"\n    caseStx.location = that.location;\n\n    var pinfoAndValSym = pinfo.gensym('val'),      // create a symbol 'val'\n        updatedPinfo1 = pinfoAndValSym[0],        // generate pinfo containing 'val'\n        valStx = pinfoAndValSym[1];               // remember the symbolExpr for 'val'\n    var pinfoAndXSym = updatedPinfo1.gensym('x'), // create another symbol 'x' using pinfo1\n        updatedPinfo2 = pinfoAndXSym[0],          // generate pinfo containing 'x'\n        xStx = pinfoAndXSym[1],                   // remember the symbolExpr for 'x'\n        voidStx = new symbolExpr('void');         // make the void symbol\n\n    // track all the syntax we've created so far...\n    var stxs = [valStx, xStx, voidStx];\n    // if there's an 'else', pop off the clause and use the result as the base\n    var expr, clauses = this.clauses, lastClause = clauses[this.clauses.length-1];\n    if((lastClause.first instanceof symbolExpr) && (lastClause.first.val === 'else')){\n      expr = lastClause.second;\n      clauses.pop();\n    } else {\n      expr = new callExpr(voidStx,[], that.stx);\n      expr.location = that.location;\n    }\n    // This is the predicate we'll be applying using ormap: (lambda (x) (equal? x val))\n    var equalStx = new symbolExpr('equal?'),\n        equalTestStx = new callExpr(equalStx, [xStx, valStx], caseStx),\n        predicateStx = new lambdaExpr([xStx], equalTestStx, caseStx);\n    // track the syntax that will need location information reset\n    stxs = stxs.concat([equalStx, equalTestStx, predicateStx]);\n \n    // generate (if (ormap <predicate> clause.first) clause.second base)\n    function processClause(base, clause){\n      var ormapStx = new symbolExpr('ormap'),\n          callStx = new callExpr(ormapStx, [predicateStx, clause.first], that.stx),\n          ifStx = new ifExpr(callStx, clause.second, base, caseStx);\n      // track the syntax that will need location information reset\n      stxs = stxs.concat([ormapStx, callStx, clause.first, ifStx]);\n      return ifStx;\n    }\n\n    // build the body of the let by decomposing cases into nested ifs\n    var binding = new couple(valStx, this.expr),\n        body = clauses.reduceRight(processClause, expr),\n        letExp = new letExpr([binding], body, caseStx);\n    // track the syntax that will need location information reset\n    stxs = stxs.concat([binding, letExp]);\n \n    // assign location to every stx element we created\n    stxs.forEach(function(stx){stx.location = that.location;});\n \n    return letExp.desugar(updatedPinfo2);\n };\n \n // ands become nested ifs\n andExpr.prototype.desugar = function(pinfo){\n    var that = this, ifStx = new symbolExpr(\"if\"),\n        exprsAndPinfo = desugarProgram(this.exprs, pinfo),\n        exprs = exprsAndPinfo[0],\n        pinfo = exprsAndPinfo[1];\n \n    // recursively walk through the exprs\n    function desugarAndExprs(exprs){\n      var predicate = forceBooleanContext(that.stx, that.stx.location, exprs[0]),\n          // if there only two exprs in the chain, force a boolean ctx on the second expr and make it the consequence\n          // otherwise, desugar the rest of the chain before adding it\n          consequence = (exprs.length > 2)? desugarAndExprs(exprs.slice(1))\n                                          : forceBooleanContext(that.stx, that.stx.location, exprs[1]),\n          alternative = new literal(false),\n          ifLink = new ifExpr(predicate, consequence, alternative, ifStx),\n          stxs = [alternative, ifStx, ifLink];\n \n      // assign location information to everything\n      stxs.forEach(function(stx){return stx.location = that.location;});\n      return ifLink;\n    }\n \n    var ifChain = desugarAndExprs(exprs);\n    ifChain.location = that.location;\n    return [ifChain, pinfo];\n };\n // ors become nested lets-with-if-bodies\n orExpr.prototype.desugar = function(pinfo){\n    var that = this, orStx = new symbolExpr(\"or\"),\n        exprsAndPinfo = desugarProgram(this.exprs, pinfo),\n        exprs = exprsAndPinfo[0],\n        pinfo = exprsAndPinfo[1];\n \n    // recursively walk through the exprs\n    function desugarOrExprs(exprs, pinfo){\n      var firstExpr = exprs[0], exprLoc = firstExpr.location,\n          pinfoAndTempSym = pinfo.gensym('tmp'),\n          firstExprSym = pinfoAndTempSym[1],\n          ifStx = new symbolExpr(\"if\");\n      firstExprSym.notOriginalSource = true;\n \n      // to match Racket's behavior, we override any expression's\n      // stx to be \"if\", with the location of the whole expression\n      if(firstExpr.stx && (firstExpr.stx.val !== \"if\")){\n          ifStx.location = firstExpr.location;\n          firstExpr.stx = ifStx;\n      }\n      var pinfo = pinfoAndTempSym[0],\n          tmpBinding = new couple(firstExprSym, forceBooleanContext(that.stx, that.stx.location, firstExpr)),\n          secondExpr;\n \n      // if there are only two exprs in the chain, force a boolean ctx on the second expr before adding\n      // otherwise, desugar the rest of the chain before adding it\n      if(exprs.length == 2){\n        secondExpr = forceBooleanContext(orStx, that.stx.location, exprs[1]);\n      } else  {\n        var secondExprAndPinfo = desugarOrExprs(exprs.slice(1), pinfo);\n        secondExpr = secondExprAndPinfo[0];\n        pinfo = secondExprAndPinfo[1];\n      }\n\n      // create if and let expressions, using these new symbols and bindings\n      var if_exp = new ifExpr(firstExprSym, firstExprSym, secondExpr, new symbolExpr(\"if\")),\n          let_exp = new letExpr([tmpBinding], if_exp, orStx),\n          stxs = [orStx, firstExprSym, tmpBinding, if_exp, if_exp.stx, let_exp];\n      // assign location information to everything\n      stxs.forEach(function(stx){return stx.location = that.location; });\n      return let_exp.desugar(pinfo);\n    }\n \n    return desugarOrExprs(exprs, pinfo);\n };\n\n quotedExpr.prototype.desugar = function (pinfo) {\n   if (typeof this.location === 'undefined') {\n     throwError( new types.Message([\"ASSERTION ERROR: Every quotedExpr should have a location\"])\n               , loc)\n   }\n   // Sexp-lists (arrays) become lists\n   // literals and symbols stay themselves\n   // everything else gets desugared\n   function desugarQuotedItem(pinfo, loc){\n     return function (x) {\n       if (  x instanceof callExpr\n          || x instanceof quotedExpr\n          || x instanceof unsupportedExpr\n          ) {\n         return x.desugar(pinfo);\n       } else if (  x instanceof symbolExpr\n                 || x instanceof literal\n                 || x instanceof Array\n                 ) {\n         var res = new quotedExpr(x);\n         res.location = loc;\n         return [res, pinfo];\n       } else {\n         throwError(new types.Message([\"ASSERTION ERROR: Found an unexpected item in a quotedExpr\"])\n                   , loc);\n       }\n     }\n   }\n \n   return desugarQuotedItem(pinfo, this.location)(this.val);\n };\n\n unquotedExpr.prototype.desugar = function (pinfo, depth) {\n   if (typeof depth === 'undefined') {\n     throwError( new types.Message([\"misuse of a ', not under a quasiquoting backquote\"])\n               , this.location);\n   } else if (depth === 1) {\n     return this.val.desugar(pinfo);\n   } else if (depth > 1) {\n     if (this.val instanceof Array) {\n       return desugarQuasiQuotedList(element, pinfo, depth-1);\n     } else {\n       var uSym = new quotedExpr(new symbolExpr('unquote')),\n           listSym = new symbolExpr('list'),\n           listArgs = [uSym, this.val.desugar(pinfo, depth-1)[0]],\n           listCall = new callExpr(listSym, listArgs);\n       uSym.location = this.location;\n       uSym.parent = listArgs;\n       listSym.location = this.location;\n       listSym.parent = listCall;\n       listCall.location = this.location;\n       return [listCall, pinfo];\n     }\n   } else {\n     throwError( new types.Message([\"ASSERTION FAILURE: depth should have been undefined, or a natural number\"])\n               , this.location);\n   }\n };\n\n unquoteSplice.prototype.desugar = function (pinfo, depth) {\n   if (typeof depth === 'undefined') {\n     throwError( new types.Message([\"misuse of a ,@, not under a quasiquoting backquote\"])\n               , this.location);\n   } else if (depth === 1) {\n     return this.val.desugar(pinfo);\n   } else if (depth > 1) {\n     if (this.val instanceof Array) {\n       return desugarQuasiQuotedList(element, pinfo, depth-1);\n     } else {\n       var usSym = new quotedExpr(new symbolExpr('unquote-splicing')),\n           listSym = new symbolExpr('list'),\n           listArgs = [usSym, this.val.desugar(pinfo, depth-1)[0]],\n           listCall = new callExpr(listSym, listArgs);\n       usSym.location = this.location;\n       usSym.parent = listArgs;\n       listSym.location = this.location;\n       listSym.parent = listCall;\n       listCall.location = this.location;\n       return [listCall, pinfo];\n     }\n   } else {\n     throwError( new types.Message([\"ASSERTION FAILURE: depth should have been undefined, or a natural number\"])\n               , this.location);\n   }\n };\n\n function desugarQuasiQuotedList(qqlist, pinfo, depth) {\n \n    // helper function for a single QQ-list element\n    function desugarQuasiQuotedListElement(element, pinfo, depth, loc) {\n     if (depth === 0 && element instanceof unquoteSplice) {\n       return element.desugar(pinfo, depth);\n     } else {\n       var argument = (element instanceof Array) ?\n            desugarQuasiQuotedList(element, depth, depth)[0] :\n            element.desugar(pinfo, depth)[0],\n           listSym = new symbolExpr('list'),\n           listCall = new callExpr(listSym, [argument]);\n       listSym.parent = listCall;\n       listCall.location = listSym.location = loc;\n       return [listCall, pinfo];\n     }\n   }\n \n   var loc = (typeof qqlist.location != 'undefined') ? qqlist.location :\n              ((qqlist instanceof Array) && (typeof qqlist[0].location != 'undefined')) ? qqlist[0].location :\n              (throwError( types.Message([\"ASSERTION FAILURE: couldn't find a usable location\"])\n                          , new Location(0,0,0,0))),\n       appendArgs = qqlist.map(function(x){ return desugarQuasiQuotedListElement(x, pinfo, depth, loc)[0]; }),\n       appendSym = new symbolExpr('append');\n   appendSym.location = loc\n   var appendCall = new callExpr(appendSym, appendArgs);\n   appendCall.location = loc;\n   return [appendCall, pinfo];\n }\n\n // go through each item in search of unquote or unquoteSplice\n quasiquotedExpr.prototype.desugar = function(pinfo, depth){\n   depth = (typeof depth === 'undefined') ? 0 : depth;\n   if (depth >= 0) {\n     var result;\n     if(this.val instanceof Array){\n       result = desugarQuasiQuotedList(this.val, pinfo, depth+1)[0];\n     } else {\n       result = this.val.desugar(pinfo, depth+1)[0];\n     }\n   } else {\n     throwError( new types.Message([\"ASSERTION FAILURE: depth should have been undefined, or a natural number\"])\n               , this.location);\n   }\n\n   if (depth == 0) {\n     return [result, pinfo];\n   } else {\n     var qqSym = new quotedExpr(new symbolExpr('quasiquote')),\n         listArgs = [qqSym, result],\n         listSym = new symbolExpr('list'),\n         listCall = new callExpr(listSym, listArgs);\n     qqSym.parent = listArgs;\n     qqSym.location = this.location;\n     result.parent = listArgs;\n     listSym.parent = listCall;\n     listSym.location = this.location;\n     listCall.location = this.location;\n     return [listCall, pinfo]\n   }\n };\n \n symbolExpr.prototype.desugar = function(pinfo){\n    // if we're not in a clause, we'd better not see an \"else\"...\n    if(!this.isClause && (this.val === \"else\")){\n        var loc = (this.parent && this.parent[0] === this)? this.parent.location : this.location;\n        throwError(new types.Message([new types.ColoredPart(this.val, loc)\n                                      , \": not allowed \"\n                                      , new types.ColoredPart(\"here\", loc)\n                                      , \", because this is not a question in a clause\"]),\n                   loc);\n    }\n    // if this is a define without a parent, or if it's not the first child of the parent\n    if((this.parent && this.parent[0] !== this) && (this.val === \"define\")){\n        var msg = new types.Message([new types.ColoredPart(this.val, this.location)\n                                     , \": not allowed inside an expression\"]);\n        throwError(msg, this.location);\n    }\n    // if this is a keyword without a parent, or if it's not the first child of the parent\n    if(!this.parent &&\n       (plt.compiler.keywords.indexOf(this.val) > -1) && (this.val !== \"else\")){\n        throwError(new types.Message([new types.ColoredPart(this.val, this.location)\n                                      , \": expected an open parenthesis before \"\n                                      , this.val\n                                      , \", but found none\"]),\n                    this.location);\n    }\n    // the dot operator is not supported by WeScheme\n    if(this.val === \".\"){\n     var msg = new types.Message([this.location.source, \":\",\n                                   this.location.startRow.toString(), \":\",\n                                   this.location.startCol.toString()\n                                  , \": read: '.' is not supported as a symbol in WeScheme\"]);\n     throwError(msg\n                 , this.location\n                 , \"Error-GenericReadError\");\n    }\n    return [this, pinfo];\n };\n unsupportedExpr.prototype.desugar = function(pinfo){\n    this.location.span = this.errorSpan;\n    throwError(this.errorMsg, this.location, \"Error-GenericReadError\");\n }\n \n //////////////////////////////////////////////////////////////////////////////\n // COLLECT DEFINITIONS ///////////////////////////////////////////////////////\n\n // extend the Program class to collect definitions\n // Program.collectDefnitions: pinfo -> pinfo\n Program.prototype.collectDefinitions = function(pinfo){ return pinfo; };\n\n // bf: symbol path number boolean string -> binding:function\n // Helper function.\n function bf(name, modulePath, arity, vararity, loc){\n    return new functionBinding(name, modulePath, arity, vararity, [], false, loc);\n }\n defFunc.prototype.collectDefinitions = function(pinfo){\n    this.args.forEach(function(arg){\n      if(plt.compiler.keywords.indexOf(arg.val) > -1){\n          throwError(new types.Message([new types.ColoredPart(arg.val, arg.location),\n                                        \": this is a reserved keyword and cannot be used\"+\n                                        \" as a variable or function name\"])\n                     , arg.location);\n           \n               }\n      });\n \n    var binding = bf(this.name.val, false, this.args.length, false, this.name.location);\n    return pinfo.accumulateDefinedBinding(binding, this.location);\n };\n defVar.prototype.collectDefinitions = function(pinfo){\n    var binding = (this.expr instanceof lambdaExpr)?\n                    bf(this.name.val, false, this.expr.args.length, false, this.name.location)\n                  : new constantBinding(this.name.val, false, [], this.name.location);\n    return pinfo.accumulateDefinedBinding(binding, this.location);\n };\n defVars.prototype.collectDefinitions = function(pinfo){\n    var that = this,\n        fieldToAccessor = function(f){return that.stx[1].val+\"-\"+f.val;},\n        fieldToMutator = function(f){return \"set-\"+that.stx[1].val+\"-\"+f.val+\"!\";};\n    // if it's define-struct, create a struct binding\n    if(that.stx[0].val === \"define-struct\"){\n      var id      = that.stx[1].val,\n          fields  = that.stx[2],\n          constructorId = \"make-\"+id,\n          predicateId   = id+\"?\",\n          selectorIds   = fields.map(fieldToAccessor),\n          mutatorIds    = fields.map(fieldToMutator),\n          structNameLoc = that.stx[1].location,  // location of <name> in (define-struct <name> (..))\n          // build bindings out of these ids\n          structureBinding = new structBinding(id, false, fields, constructorId, predicateId,\n                                               selectorIds, mutatorIds, null, that.stx[1].location),\n          constructorBinding = bf(constructorId, false, fields.length, false, structNameLoc),\n          predicateBinding   = bf(predicateId, false, 1, false, structNameLoc),\n          mutatorBinding     = bf(id+\"-set!\", false, 1, false, structNameLoc),\n          refBinding         = bf(id+\"-ref\", false, 1, false, structNameLoc),\n // COMMENTED OUT ON PURPOSE:\n // these symbols are provided by separate definitions that result from desugaring, in keeping with the original compiler's behavior\n //        selectorBindings   = selectorIds.map(function(id){return bf(id, false, 1, false, that.location)}),\n // AND WOULD YOU BELIEVE IT:\n //  these symbols aren't exposed by the compiler either (maybe since set! isn't supported?)\n //        mutatorBindings    = mutatorIds.map(function(id){return bf(id, false, 2, false, that.location)}),\n          // assemble all the bindings together\n          bindings = [structureBinding, refBinding, constructorBinding, predicateBinding, mutatorBinding];\n      return pinfo.accumulateDefinedBindings(bindings, that.location);\n    } else {\n      return this.names.reduce(function(pinfo, id){\n        var binding = new constantBinding(id.val, false, [], id.location);\n        return pinfo.accumulateDefinedBinding(binding, that.location);\n      }, pinfo);\n    }\n };\n\n // When we hit a require, we have to extend our environment to include the list of module\n // bindings provided by that module.\n // FIXME: we currently override moduleName, which SHOULD just give us the proper name\n requireExpr.prototype.collectDefinitions = function(pinfo){\n    // if it's a literal, pull out the actual value. if it's a symbol use it as-is\n    var moduleName = (this.spec instanceof literal)? this.spec.val.toString() : this.spec.toString(),\n        resolvedModuleName = pinfo.modulePathResolver(moduleName, pinfo.currentModulePath),\n        that = this,\n        newPinfo;\n \n    // is this a shared WeScheme program?\n    function getWeSchemeModule(name){\n      var m = name.match(/^wescheme\\/(\\w+)$/);\n      return m? m[1] : false;\n    }\n \n    function throwModuleError(moduleName){\n      var bestGuess = plt.compiler.moduleGuess(that.spec.toString());\n      var msg = new types.Message([\"Found require of the module \"\n                                   , new types.ColoredPart(that.spec.toString(), that.spec.location)\n                                   , \", but this module is unknown.\"\n                                   , ((bestGuess.name===that.spec.toString())? \"\": \" Did you mean '\"+bestGuess.name+\"'?\")]);\n      throwError(msg, that.spec.location, \"Error-UnknownModule\");\n    }\n \n    // if it's an invalid moduleName, throw an error\n    if(!(resolvedModuleName || getWeSchemeModule(moduleName))){ throwModuleError(moduleName); }\n \n    // processModule : JS -> pinfo\n    // assumes the module has been assigned to window.COLLECTIONS.\n    // pull out the bindings, and then add them to pinfo\n    function processModule(moduleName){\n      var provides = window.COLLECTIONS[moduleName].provides;\n      var strToBinding = function(p){\n                            var b = new constantBinding(p, new symbolExpr(moduleName), false);\n                            b.imported = true; // WTF: Moby treats imported bindings differently, so we need to identify them\n                            return b;\n                          },\n          provideBindings = provides.map(strToBinding),\n          modulebinding = new moduleBinding(moduleName, provideBindings);\n      newPinfo = pinfo.accumulateModule(modulebinding).accumulateModuleBindings(provideBindings);\n    }\n \n    // open a *synchronous* GET request -- FIXME to use callbacks?\n    var url = window.location.protocol+\"//\"+window.location.host\n              + (getWeSchemeModule(moduleName)?  \"/loadProject?publicId=\"+(getWeSchemeModule(moduleName))\n                                              : \"/js/mzscheme-vm/collects/\"+moduleName+\".js\");\n \n    // if the module is already loaded, we can just process without loading\n    if(window.COLLECTIONS && window.COLLECTIONS[moduleName]){\n      processModule(moduleName);\n    } else {\n      jQuery.ajax({\n           url:    url,\n           success: function(result) {\n                      // if it's not a native module, manually assign it to window.COLLECTIONS\n                      if(getWeSchemeModule(moduleName)){\n                        var program = (0,eval)('(' + result + ')');\n                        // Create the COLLECTIONS array, if it doesn't exist\n                        if(window.COLLECTIONS === undefined){ window.COLLECTIONS = []; }\n                        // extract the sourcecode\n                        var lexemes     = plt.compiler.lex(program.source.src, moduleName),\n                            AST         = plt.compiler.parse(lexemes),\n                            desugared   = plt.compiler.desugar(AST)[0],  // includes [AST, pinfo]\n                            pinfo       = plt.compiler.analyze(desugared),\n                            objectCode  = plt.compiler.compile(desugared, pinfo);\n                        window.COLLECTIONS[moduleName] = {\n                                    'name': moduleName,\n                                    'bytecode' : (0,eval)('(' + objectCode.bytecode + ')'),\n                                    'provides' : objectCode.provides\n                                };\n                      // otherwise, simply evaluate the raw JS\n                      } else {\n                        eval(result);\n                      }\n                  if(result){ processModule(moduleName); }\n                  else { throwModuleError(moduleName); }\n                },\n           error: function (error) { throwModuleError(moduleName); },\n           async: false\n      });\n    }\n    return newPinfo;\n };\n // BINDING STRUCTS ///////////////////////////////////////////////////////\n function provideBindingId(symbl){ this.symbl = symbl;}\n function provideBindingStructId(symbl){ this.symbl = symbl; }\n\n //////////////////////////////////////////////////////////////////////////////\n // COLLECT PROVIDES //////////////////////////////////////////////////////////\n\n // extend the Program class to collect provides\n // Program.collectProvides: pinfo -> pinfo\n Program.prototype.collectProvides = function(pinfo){ return pinfo; };\n provideStatement.prototype.collectProvides = function(pinfo){\n    var that = this;\n \n    function addProvidedName(id){ pinfo.providedNames.put(id, new provideBindingId(id)); }\n \n    // collectProvidesFromClause : pinfo clause -> pinfo\n    function collectProvidesFromClause(pinfo, clause){\n      // if it's a symbol, make sure it's defined (otherwise error)\n      if (clause instanceof symbolExpr){\n        if(pinfo.definedNames.containsKey(clause.val)){\n          addProvidedName(clause.val);\n          return pinfo;\n        } else {\n          var msg = new types.Message([\"The name '\"\n                                       , new types.ColoredPart(clause.toString(), clause.location)\n                                       , \"', is not defined in the program, and cannot be provided.\"]);\n          throwError(msg, clause.location);\n        }\n      // if it's an array, make sure the struct is defined (otherwise error)\n      // NOTE: ONLY (struct-out id) IS SUPPORTED AT THIS TIME\n      } else if(clause instanceof Array){\n          if(pinfo.definedNames.containsKey(clause[1].val) &&\n             (pinfo.definedNames.get(clause[1].val) instanceof structBinding)){\n              // add the entire structBinding to the provided binding, so we\n              // can access fieldnames, predicates, and permissions later\n              var b = pinfo.definedNames.get(clause[1].val),\n                  fns = [b.name, b.constructor, b.predicate].concat(b.accessors, b.mutators);\n                  fns.forEach(addProvidedName);\n              return pinfo;\n          } else {\n            throwError(new types.Message([\"The struct '\"\n                                          , new types.ColoredPart(clause[1].toString(), clause[1].location)\n                                          , \"', is not defined in the program, and cannot be provided\"])\n                       , clause.location);\n          }\n      // anything with a different format throws an error\n      } else {\n        throw \"Impossible: all invalid provide clauses should have been filtered out!\";\n      }\n    }\n    return this.clauses.reduce(collectProvidesFromClause, pinfo);\n  };\n \n //////////////////////////////////////////////////////////////////////////////\n // ANALYZE USES //////////////////////////////////////////////////////////////\n\n // extend the Program class to analyzing uses\n // Program.analyzeUses: pinfo -> pinfo\n Program.prototype.analyzeUses = function(pinfo, env){ return pinfo; };\n defVar.prototype.analyzeUses = function(pinfo){\n    // extend the environment with the value or function, then analyze the expression\n    pinfo.env.extend((this.expr instanceof lambdaExpr)?\n                     bf(this.name.val, false, this.expr.args.length, false, this.location)\n                     :  new constantBinding(this.name.val, false, [], this.name.location));\n    return this.expr.analyzeUses(pinfo, pinfo.env);\n };\n defVars.prototype.analyzeUses = function(pinfo){\n    this.names.forEach(function(id){\n        pinfo.env.extend(new constantBinding(id.val, false, [], id.location));\n      });\n    return this.expr.analyzeUses(pinfo, pinfo.env);\n };\n // analyzeClosureUses : expr pinfo -> pinfo\n // given the body of a lambda, an environment and a pinfo, analyze the body\n function analyzeClosureUses(funcExpr, pinfo){\n    // 1) make a copy of all the bindings\n    var oldEnv = pinfo.env,\n        oldKeys = oldEnv.bindings.keys(),\n        newBindings = types.makeLowLevelEqHash();\n    oldKeys.forEach(function(k){newBindings.put(k, oldEnv.bindings.get(k));});\n \n    // 2) make a copy of the environment, using the newly-copied bindings, and\n    //    add the args to this environment\n    var newEnv = new plt.compiler.env(newBindings),\n        newEnv = funcExpr.args.reduce(function(env, arg){\n                                  return env.extend(new constantBinding(arg.val, false, [], arg.location));\n                                }, newEnv);\n    // 3) install the post-arg env into pinfo, analyze the body, and\n    //    install the original environment\n    pinfo.env = newEnv;\n    pinfo = funcExpr.body.analyzeUses(pinfo, newEnv);\n    pinfo.env = oldEnv;\n    return pinfo;\n }\n defFunc.prototype.analyzeUses = function(pinfo){\n    // extend the env to include the function binding, then analyze the body as if it's a lambda\n    pinfo.env = pinfo.env.extend(bf(this.name.val, false, this.args.length, false, this.name.location));\n    return analyzeClosureUses(this, pinfo);\n };\n lambdaExpr.prototype.analyzeUses = function(pinfo, env){\n    return analyzeClosureUses(this, pinfo);\n };\n beginExpr.prototype.analyzeUses = function(pinfo, env){\n    return this.exprs.reduce(function(p, expr){return expr.analyzeUses(p, env);}, pinfo);\n };\n localExpr.prototype.analyzeUses = function(pinfo, env){\n    var pinfoAfterDefs = this.defs.reduce(function(pinfo, d){ return d.analyzeUses(pinfo, env); }, pinfo);\n    return this.body.analyzeUses(pinfoAfterDefs, pinfoAfterDefs.env);\n };\n callExpr.prototype.analyzeUses = function(pinfo, env){\n    return [this.func].concat(this.args).reduce(function(p, arg){\n                            return (arg instanceof Array)?\n                                    // if arg is a subexpression, reduce THAT\n                                    arg.reduce((function(pinfo, p){return p.analyzeUses(pinfo, pinfo.env);})\n                                               , pinfo)\n                                    // otherwise analyze and return\n                                    : arg.analyzeUses(p, env);\n                            }, pinfo);\n }\n ifExpr.prototype.analyzeUses = function(pinfo, env){\n    var exps = [this.predicate, this.consequence, this.alternative];\n    return exps.reduce(function(p, exp){\n                            return exp.analyzeUses(p,env);\n                            }, pinfo);\n };\n symbolExpr.prototype.analyzeUses = function(pinfo, env){\n    // if this is a keyword without a parent, or if it's not the first child of the parent\n    if((plt.compiler.keywords.indexOf(this.val) > -1) &&\n       (!this.parent || this.parent[0]!== this) || (this.parent instanceof couple)){\n        throwError(new types.Message([new types.ColoredPart(this.val, this.location)\n                                      , \": expected an open parenthesis before \"\n                                      , this.val\n                                      , \", but found none\"]),\n                    this.location);\n    }\n    var binding = env.lookup_context(this.val);\n    if(binding){\n      this.bindingLoc = binding.loc; //  keep track of where this symbol was bound\n      return pinfo.accumulateBindingUse(binding, pinfo);\n    } else {\n      return pinfo.accumulateFreeVariableUse(this.val, pinfo);\n    }\n };\n\n\n/////////////////////////////////////////////////////////////\n function analyze(programs){\n    return programAnalyzeWithPinfo(programs, plt.compiler.getBasePinfo(\"base\"));\n }\n \n // programAnalyzerWithPinfo : [listof Programs], pinfo -> pinfo\n // build up pinfo by looking at definitions, provides and uses\n function programAnalyzeWithPinfo(programs, pinfo){\n   // collectDefinitions: [listof Programs] pinfo -> pinfo\n   // Collects the definitions either imported or defined by this program.\n   function collectDefinitions(programs, pinfo){\n     return programs.reduce((function(pinfo, p){ return p.collectDefinitions(pinfo); })\n                            , pinfo);\n   }\n   // collectProvides: [listof Programs] pinfo -> pinfo\n   // Walk through the program and collect all the provide statements.\n   function collectProvides(programs, pinfo){\n      return programs.reduce((function(pinfo, p){ return p.collectProvides(pinfo); })\n                             , pinfo);\n   }\n   // analyzeUses: [listof Programs] pinfo -> pinfo\n   // Collects the uses of bindings that this program uses.\n    function analyzeUses(programs, pinfo){\n      return programs.reduce((function(pinfo, p){ return p.analyzeUses(pinfo, pinfo.env); })\n                             , pinfo);\n    }\n    var pinfo1 = collectDefinitions(programs, pinfo);\n    var pinfo2 = collectProvides(programs, pinfo1);\n    return analyzeUses(programs, pinfo2);\n }\n \n /////////////////////\n /* Export Bindings */\n /////////////////////\n plt.compiler.desugar = function(p, pinfo, debug){\n    var start       = new Date().getTime();\n    try {\n      var ASTandPinfo = desugarProgram(p, pinfo, true), // do the actual work\n          program     = ASTandPinfo[0],\n          pinfo       = ASTandPinfo[1];\n    } catch (e) { console.log(\"DESUGARING ERROR\"); throw e; }\n    var end = new Date().getTime();\n    if(debug){\n      console.log(\"Desugared in \"+(Math.floor(end-start))+\"ms\");\n      console.log(program);\n      console.log(program.toString());\n    }\n    return ASTandPinfo;\n  };\n plt.compiler.analyze = function(program, debug){\n    var start       = new Date().getTime();\n    try { var pinfo       = analyze(program); }             // do the actual work\n    catch (e) { console.log(\"ANALYSIS ERROR\"); throw e; }\n    var end         = new Date().getTime();\n    if(debug){\n      console.log(\"Analyzed in \"+(Math.floor(end-start))+\"ms\");\n//      console.log(pinfo.toString());\n    }\n    return pinfo;\n  };\n plt.compiler.provideBindingId = provideBindingId;\n plt.compiler.provideBindingStructId = provideBindingStructId;\n})();\n\nmodule.exports = plt.compiler;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/analyzer.js\n ** module id = 7\n ** module chunks = 0\n **/","// if not defined, declare the compiler object as part of plt\nwindow.plt   = window.plt   || {};\nplt.compiler = require('./structures');\n/*\n TODO\n -\n */\n\n//////////////////////////////////////////////////////////////////////////////\n/////////////////// MODULE BINDINGS //////////////////////////\n(function (){\n \n  var moduleBinding   = plt.compiler.moduleBinding;\n  var functionBinding = plt.compiler.functionBinding;\n  var constantBinding = plt.compiler.constantBinding;\n \n  // given a moduleName, return a function that converts binding specs into function bindings\n  function makeFunctionBinding(modulePath){\n    return function(binding){\n            binding[3] = binding[3] || [];      // permissions default to none\n            binding[4] = binding[4] || false;   // isCps defaults to false\n            binding[5] = binding[5] || false;   // loc defaults to false\n            return new functionBinding(binding[0], modulePath, binding[1], binding[2], binding[3], binding[4], binding[5]);\n           };\n  }\n  \n  // kernel-misc-module\n  var kernelMiscModule  = new moduleBinding(\"moby/runtime/kernel/misc\",\n                                           [[\"verify-boolean-branch-value\", 2]\n                                            ,[\"throw-cond-exhausted-error\", 1 ]\n                                            ,[\"'check-operator-is-function\", 3]\n                                            ,[\"print-values\", 0]\n                                           ].map(makeFunctionBinding('\"moby/runtime/kernel/misc\"'))\n  );\n  \n  // foreign-module\n  var foreignModule     = new moduleBinding(\"moby/foreign\",\n                                           [[\"get-js-object\", 2, false, [\"android.permission.FOREIGN-FUNCTION-INTERFACE\"]]\n                                           ].map(makeFunctionBinding('\"moby/foreign\"'))\n  );\n  \n  // world-effects-module\n  var worldEffectsModule= new moduleBinding(\"world-effects\",\n                                            [[\"make-effect:none\", 0, false]\n                                             ,[\"make-effect:beep\", 0, false, [\"android.permission.VIBRATE\"]]\n                                             ,[\"make-effect:play-dtmf-tone\", 2, false]\n                                             ,[\"make-effect:send-sms\", 2, false, [\"android.permission.SEND-SMS\"]]\n                                             ,[\"make-effect:play-sound\", 1, false, [\"android.permission.INTERNET\"]]\n                                             ,[\"make-effect:stop-sound\", 1, false]\n                                             ,[\"make-effect:pause-sound\", 1, false]\n                                             ,[\"make-effect:set-sound-volume\", 1, false]\n                                             ,[\"make-effect:set-beep-volume\", 1, false]\n                                             ,[\"make-effect:raise-sound-volume\", 0, false]\n                                             ,[\"make-effect:lower-sound-volume\", 1, false]\n                                             ,[\"make-effect:set-wake-lock\", 1, false, [\"android.permission.WAKE-LOCK\"]]\n                                             ,[\"make-effect:release-wake-lock\", 1, false, [\"android.permission.WAKE-LOCK\"]]\n                                             ,[\"make-effect:pick-playlist\", 1, false]\n                                             ,[\"make-effect:pick-random\", 2, false]\n                                             ].map(makeFunctionBinding('\"moby/world-effects\"'))\n  );\n  \n  // world-handlers-module\n  var worldHandlersModule=new moduleBinding(\"world-config\",\n                                           [[\"on-tick\", 1, true]\n                                            ,[\"initial-effect\", 1, false]\n                                            ,[\"on-key\", 1, false]\n                                            ,[\"on-key!\", 2, false]\n                                            ,[\"on-mouse\", 1, false]\n                                            ,[\"on-tap\", 1, false]\n                                            ,[\"on-tilt\", 1, false]\n                                            ,[\"on-redraw\", 1, false]\n                                            ,[\"to-draw\", 1, false]\n                                            ,[\"on-draw\", 2, false]\n                                            ,[\"stop-when\", 1, false]\n                                           ].map(makeFunctionBinding('\"moby/world-handlers\"'))\n  );\n  \n  // bootstrap-teachpack\n  var bootstrapTeachpackFunctions = [[\"START\", 14, false] ,[\"test-frame\", 1, false] ,[\"sine\", 1, false]\n                                     ,[\"cosine\", 1, false] ,[\"tangent\", 1, false]];\n  var bootstrapTeachpack = new moduleBinding(\"bootstrap/bootstrap-teachpack\",\n                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap/bootstrap-teachpack\"'))),\n      bootstrapTeachpack2011 = new moduleBinding(\"bootstrap2011/bootstrap-teachpack\",\n                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2011/bootstrap-teachpack\"'))),\n      bootstrapTeachpack2012 = new moduleBinding(\"bootstrap2012/bootstrap-teachpack\",\n                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2012/bootstrap-teachpack\"'))),\n      bootstrapTiltTeachpack2012 = new moduleBinding(\"bootstrap2012/bootstrap-tilt-teachpack\",\n                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2012/bootstrap-tilt-teachpack\"'))),\n      bootstrapTeachpack2014 = new moduleBinding(\"bootstrap2014/bootstrap-teachpack\",\n                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2014/bootstrap-teachpack\"'))),\n      bootstrapTiltTeachpack2014 = new moduleBinding(\"bootstrap2014/bootstrap-tilt-teachpack\",\n                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2014/bootstrap-tilt-teachpack\"'))),\n      bootstrapTeachpack2015 = new moduleBinding(\"bootstrap2015/bootstrap-teachpack\",\n                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2015/bootstrap-teachpack\"'))),\n      bootstrapTiltTeachpack2015 = new moduleBinding(\"bootstrap2015/bootstrap-tilt-teachpack\",\n                                             bootstrapTeachpackFunctions.map(makeFunctionBinding('\"bootstrap2015/bootstrap-tilt-teachpack\"')));\n \n  // cage-teachpack\n  var cageTeachpack = new moduleBinding(\"bootstrap/cage-teachpack\",[[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap/cage-teachpack\"'))),\n      cageTeachpack2011 = new moduleBinding(\"bootstrap2011/cage-teachpack\",\n                                            [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2011/cage-teachpack\"'))),\n      cageTeachpack2012 = new moduleBinding(\"bootstrap2012/cage-teachpack\",\n                                            [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2012/cage-teachpack\"'))),\n      cageTeachpack2014 = new moduleBinding(\"bootstrap2014/cage-teachpack\",\n                                            [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2014/cage-teachpack\"')));\n \n  // function-teachpack\n  var functionTeachpack = new moduleBinding(\"bootstrap/function-teachpack\",\n                                            [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap/function-teachpack\"'))),\n      functionTeachpack2011 = new moduleBinding(\"bootstrap2011/function-teachpack\",\n                                                [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2011/function-teachpack\"'))),\n      functionTeachpack2012 = new moduleBinding(\"bootstrap2012/function-teachpack\",\n                                                [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2012/function-teachpack\"'))),\n      functionTeachpack2014 = new moduleBinding(\"bootstrap2014/function-teachpack\",\n                                                [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2014/function-teachpack\"'))),\n      functionTeachpack2015 = new moduleBinding(\"bootstrap2015/function-teachpack\",\n                                                [[\"start\", 1, false]].map(makeFunctionBinding('\"bootstrap2015/function-teachpack\"')));\n  \n  // location module\n  var locationModule     = new moduleBinding(\"location\",\n                                             [[\"get-latitude\",      0, false, [\"android.permission.LOCATION\"]]\n                                              ,[\"get-longitude\",    0, false, [\"android.permission.LOCATION\"]]\n                                              ,[\"get-altitude\",     0, false, [\"android.permission.LOCATION\"]]\n                                              ,[\"get-bearing\",      0, false, [\"android.permission.LOCATION\"]]\n                                              ,[\"get-speed\",        0, false, [\"android.permission.LOCATION\"]]\n                                              ,[\"location-distance\", 0, false, [\"android.permission.LOCATION\"]]\n                                              ].map(makeFunctionBinding('\"moby/geolocation\"'))\n  );\n\n  // accelerometer library\n  var tiltModule        = new moduleBinding(\"tilt\",\n                                             [[\"get-x-acceleration\",  0, false, [\"android.permission.TILT\"]]\n                                              ,[\"get-y-acceleration\", 0, false, [\"android.permission.TILT\"]]\n                                              ,[\"get-z-acceleration\", 0, false, [\"android.permission.TILT\"]]\n                                              ,[\"get-azimuth\",        0, false, [\"android.permission.TILT\"]]\n                                              ,[\"get-pitch\",          0, false, [\"android.permission.TILT\"]]\n                                              ,[\"get-roll\",           0, false, [\"android.permission.TILT\"]]\n                                              ].map(makeFunctionBinding('\"moby/tilt\"'))\n  );\n\n  // telephony module\n  var telephonyModule    = new moduleBinding(\"telephony\",\n                                             [[\"get-signal-strength\",  0, false, [\"android.permission.TELEPHONY\"]]\n                                             ].map(makeFunctionBinding('\"moby/net\"'))\n  );\n\n  // net module\n  var netModule         = new moduleBinding(\"net\",\n                                             [[\"get-url\",  1, false, [\"android.permission.INTERNET\"]]\n                                             ].map(makeFunctionBinding('\"moby/net\"'))\n  );\n                                              \n  // parser module\n  var parserModule      = new moduleBinding(\"parser\",\n                                             [[\"xml->s-sexp\",  1, false]\n                                             ].map(makeFunctionBinding('\"moby/parser\"'))\n  );\n\n  // js-world module\n  var jsWorldModule     = new moduleBinding(\"jsworld\",\n                                            [[\"js-big-bang\",  1, false]\n                                             ,[\"big-bang\",    1, false]\n                                             ,[\"js-div\",      0, false]\n                                             ,[\"js-p\",        0, false]\n                                             ,[\"js-button\",   2, false]\n                                             ,[\"js-button!\",  2, false]\n                                             ,[\"js-node\",     1, false]\n                                             ,[\"js-text\",    1, false]\n                                             ,[\"js-select\",   2, false]\n                                             ,[\"js-img\",      1, false, [\"android.permission.INTERNET\"]]\n                                             ].map(makeFunctionBinding('\"moby/jsworld\"'))\n  );\n  \n  // world\n  var worldModule       = new moduleBinding(\"world\",\n                                           worldHandlersModule.bindings.concat(worldEffectsModule.bindings,\n                                           [\"key=?\"\n                                            ,\"play-sound\"\n                                            ,\"animate\"\n                                            ,\"big-bang\"\n                                            // colors\n                                            ,\"make-color\"\n                                            ,\"color?\"\n                                            ,\"color-red\"\n                                            ,\"color-green\"\n                                            ,\"color-blue\"\n                                            ,\"color-alpha\"\n                                            \n                                            ,\"empty-scene\"\n                                            ,\"empty-image\"\n                                            ,\"scene+line\"\n                                            ,\"put-image\"\n                                            ,\"place-image\"\n                                            ,\"place-image/align\"\n                                            ,\"put-pinhole\"\n                                            ,\"circle\"\n                                            ,\"star\"\n                                            ,\"polygon\"\n                                            ,\"radial-star\"\n                                            ,\"star-polygon\"\n                                            ,\"nw:rectangle\"\n                                            ,\"rectangle\"\n                                            ,\"regular-polygon\"\n                                            ,\"rhombus\"\n                                            ,\"square\"\n                                            ,\"triangle\"\n                                            ,\"triangle/sas\"\n                                            ,\"triangle/sss\"\n                                            ,\"triangle/ass\"\n                                            ,\"triangle/ssa\"\n                                            ,\"triangle/aas\"\n                                            ,\"triangle/asa\"\n                                            ,\"triangle/saa\"\n                                            ,\"right-triangle\"\n                                            ,\"isosceles-triangle\"\n                                            ,\"ellipse\"\n                                            ,\"line\"\n                                            ,\"add-line\"\n                                            ,\"overlay\"\n                                            ,\"overlay/xy\"\n                                            ,\"overlay/align\"\n                                            ,\"underlay\"\n                                            ,\"underlay/xy\"\n                                            ,\"underlay/align\"\n                                            ,\"beside\"\n                                            ,\"beside/align\"\n                                            ,\"above\"\n                                            ,\"above/align\"\n                                            ,\"rotate\"\n                                            ,\"scale\"\n                                            ,\"scale/xy\"\n                                            ,\"crop\"\n                                            ,\"frame\"\n                                            ,\"flip-horizontal\"\n                                            ,\"flip-vertical\"\n                                            ,\"text\"\n                                            ,\"text/font\"\n                                            ,\"video-url\"       // needs network\n                                            ,\"video/url\"       // needs network\n                                            ,\"bitmap/url\"      // needs network\n                                            ,\"image-url\"       // needs network\n                                            ,\"open-image-url\"  // needs network\n                                            ,\"image?\"\n                                            ,\"image=?\"\n                                            ,\"image-width\"\n                                            ,\"image-height\"\n                                            \n                                            // mouse-events\n                                            ,\"mouse-event?\"\n                                            ,\"mouse=?\"\n                                            \n                                            ,\"image->color-list\"\n                                            ,\"color-list->image\"\n                                            ,\"color-list->bitmap\"\n                                            \n                                            ,\"image-baseline\"\n                                            ,\"mode?\"\n                                            ,\"image-color?\"\n                                            ,\"name->color\"\n                                            ,\"x-place?\"\n                                            ,\"y-place?\"\n                                            ,\"angle?\"\n                                            ,\"side-count?\"\n                                            ,\"step-count?\"\n                                            ].map(function(binding){\n                                                    var needsPermission = [\"video/url\", \"bitmap/url\", \"image-url\", \"open-image-url\"];\n                                                    var permissions = (needsPermission.indexOf(binding) > -1)? [\"android.permission.INTERNET\"] : [];\n                                                    return new constantBinding(binding, '\"moby/world\"', permissions, false);\n                                                  }))\n  );\n\n  // top-level\n  var topLevelModule = new moduleBinding(\"moby/topLevel\",\n                                         [[\"<\", 2, true] // Numerics\n                                         ,[\"<=\", 2, true]\n                                         ,[\"=\", 2, true]\n                                         ,[\">\", 2, true]\n                                         ,[\">=\", 2, true]\n                                         \n                                         ,[\"=~\", 3]\n                                         ,[\"number->string\", 1]\n                                         ,[\"even?\", 1]\n                                         ,[\"odd?\", 1]\n                                         ,[\"positive?\", 1]\n                                         ,[\"negative?\", 1]\n                                         ,[\"number?\", 1]\n                                         ,[\"rational?\", 1]\n                                         ,[\"quotient\", 2]\n                                         ,[\"remainder\", 2]\n                                         ,[\"numerator\", 1]\n                                         ,[\"denominator\", 1]\n                                         ,[\"integer?\", 1]\n                                         ,[\"real?\", 1]\n                                         ,[\"abs\", 1]\n                                         ,[\"acos\", 1]\n                                         ,[\"add1\", 1]\n                                         ,[\"angle\", 1]\n                                         ,[\"asin\", 1]\n                                         ,[\"atan\", 1, true]           // arity is either 1 or 2\n                                         ,[\"ceiling\", 1]\n                                         ,[\"complex?\", 1]\n                                         ,[\"conjugate\", 1]\n                                         ,[\"cos\", 1]\n                                         ,[\"cosh\", 1]\n                                         ,[\"denominator\", 1]\n                                         ,[\"even?\", 1]\n                                         ,[\"exact->inexact\", 1]\n                                         ,[\"exact?\", 1]               // *\n                                         ,[\"exp\", 1]\n                                         ,[\"expt\", 2]\n                                         ,[\"floor\", 1]\n                                         ,[\"gcd\", 1, true]\n                                         ,[\"imag-part\", 1]\n                                         ,[\"inexact->exact\", 1]\n                                         ,[\"inexact?\", 1]\n                                         ,[\"integer->char\", 1]\n                                         ,[\"integer-sqrt\", 1]         // *\n                                         ,[\"integer?\", 1]\n                                         ,[\"lcm\", 1, true]\n                                         ,[\"log\", 1]\n                                         ,[\"magnitude\", 1]\n                                         ,[\"make-polar\", 2]           // *\n                                         ,[\"make-rectangular\", 2]     // *\n                                         ,[\"max\", 1, true]\n                                         ,[\"min\", 1, true]\n                                         ,[\"modulo\", 2]\n                                         ,[\"negative?\", 1]\n                                         ,[\"number?\", 1]\n                                         ,[\"numerator\", 1]\n                                         ,[\"odd?\", 1]\n                                         ,[\"positive?\", 1]\n                                         ,[\"random\", 1]\n                                         ,[\"rational?\", 1]\n                                         ,[\"real-part\", 1]\n                                         ,[\"real?\", 1]\n                                         ,[\"round\", 1]\n                                         ,[\"sgn\", 1]\n                                         ,[\"sin\", 1]\n                                         ,[\"sinh\", 1]\n                                         //,[\"sq\", 1]\n                                         ,[\"sqr\", 1]\n                                         ,[\"sqrt\", 1]\n                                         ,[\"sub1\", 1]\n                                         ,[\"tan\", 1]\n                                         ,[\"zero?\", 1]\n                                         \n                                         ,[\"+\", 0, true]\n                                         ,[\"-\", 1, true]\n                                         ,[\"*\", 0, true]\n                                         ,[\"/\", 1, true]\n                                         \n                                         // Logic\n                                         ,[\"not\", 1]\n                                         ,[\"false?\", 1]\n                                         ,[\"boolean?\", 1]\n                                         ,[\"boolean=?\", 2]\n                                         \n                                         // Symbols\n                                         ,[\"symbol->string\", 1]\n                                         ,[\"symbol=?\", 2]\n                                         ,[\"symbol?\", 1]\n                                         \n                                         // Lists\n                                         ,[\"append\", 0, true]\n                                         ,[\"assq\", 2]                 // *\n                                         ,[\"assv\", 2]                 // *\n                                         ,[\"assoc\", 2]                 // *\n                                         ,[\"caaar\", 1]\n                                         ,[\"caadr\", 1]\n                                         ,[\"caar\", 1]\n                                         ,[\"cadar\", 1]\n                                         ,[\"cadddr\", 1]\n                                         ,[\"caddr\", 1]\n                                         ,[\"cadr\", 1]\n                                         ,[\"car\", 1]\n                                         ,[\"cddar\", 1]\n                                         ,[\"cdddr\", 1]\n                                         ,[\"cddr\", 1]\n                                         ,[\"cdr\", 1]\n                                         ,[\"cdaar\", 1]\n                                         ,[\"cdadr\", 1]\n                                         ,[\"cdar\", 1]\n                                         ,[\"cons?\", 1]\n                                         ,[\"list?\", 1]\n                                         ,[\"cons\", 2]\n                                         ,[\"empty?\", 1]\n                                         ,[\"length\", 1]\n                                         ,[\"list\", 0, true]\n                                         ,[\"list*\", 1, true]\n                                         ,[\"list-ref\", 2]\n                                         ,[\"remove\", 2]\n                                         ,[\"member\", 2]\n                                         ,[\"member?\", 2]\n                                         ,[\"memq\", 2]\n                                         ,[\"memv\", 2]\n                                         ,[\"null?\", 1]\n                                         ,[\"pair?\", 1]\n                                         ,[\"rest\", 1]\n                                         ,[\"reverse\", 1]\n                                         ,[\"first\", 1]\n                                         ,[\"second\", 1]\n                                         ,[\"third\", 1]\n                                         ,[\"fourth\", 1]\n                                         ,[\"fifth\", 1]\n                                         ,[\"sixth\", 1]\n                                         ,[\"seventh\", 1]\n                                         ,[\"eighth\", 1]\n                                         \n                                         // We're commenting out the mutation operation on pairs\n                                         // because they're not supported in ISL/ASL anymore.\n                                         //;,[\"set-car! 2]\n                                         //;,[\"set-cdr! 2]\n                                         \n                                         // Box\n                                         ,[\"box\", 1]\n                                         ,[\"unbox\", 1]\n                                         ,[\"set-box!\", 2]\n                                         ,[\"box?\", 1]\n                                         \n                                         // Posn\n                                         ,[\"make-posn\", 2]\n                                         ,[\"posn-x\", 1]\n                                         ,[\"posn-y\", 1]\n                                         ,[\"posn?\", 1]\n                                         \n                                         // Characters\n                                         ,[\"char->integer\", 1]\n                                         ,[\"char-alphabetic?\", 1]\n                                         ,[\"char-ci<=?\", 2, true]\n                                         ,[\"char-ci<?\", 2, true]\n                                         ,[\"char-ci=?\", 2, true]\n                                         ,[\"char-ci>=?\", 2, true]\n                                         ,[\"char-ci>?\", 2, true]\n                                         ,[\"char-downcase\", 1]\n                                         ,[\"char-lower-case?\", 1]\n                                         ,[\"char-numeric?\", 1]\n                                         ,[\"char-upcase\", 1]\n                                         ,[\"char-upper-case?\", 1]\n                                         ,[\"char-whitespace?\", 1]\n                                         ,[\"char<=?\", 2, true]\n                                         ,[\"char<?\", 2, true]\n                                         ,[\"char=?\", 2, true]\n                                         ,[\"char>=?\", 2, true]\n                                         ,[\"char>?\", 2, true]\n                                         ,[\"char?\", 1]\n                                         \n                                         // Strings\n                                         ,[\"format\", 1, true]\n                                         ,[\"list->string\", 1]\n                                         ,[\"make-string\", 2]\n                                         ,[\"replicate\", 2]\n                                         ,[\"string\", 0, true]\n                                         ,[\"string->list\", 1]\n                                         ,[\"string->number\", 1]\n                                         ,[\"string->symbol\", 1]\n                                         ,[\"string-alphabetic?\", 1]\n                                         ,[\"string-append\", 0, true]\n                                         ,[\"string-ci<=?\", 2, true]\n                                         ,[\"string-ci<?\", 2, true]\n                                         ,[\"string-ci=?\", 2, true]\n                                         ,[\"string-ci>=?\", 2, true]\n                                         ,[\"string-ci>?\", 2, true]\n                                         ,[\"string-copy\", 1]\n                                         ,[\"string-length\", 1]\n                                         ,[\"string-lower-case?\", 1]   // *\n                                         ,[\"string-numeric?\", 1]      // *\n                                         ,[\"string-ref\", 2]\n                                         ,[\"string-upper-case?\", 1]   // *\n                                         ,[\"string-whitespace?\", 1]   // *\n                                         ,[\"string<=?\", 2, true]\n                                         ,[\"string<?\", 2, true]\n                                         ,[\"string=?\", 2, true]\n                                         ,[\"string>=?\", 2, true]\n                                         ,[\"string>?\", 2, true]\n                                         ,[\"string?\", 1]\n                                         ,[\"substring\", 3 ]\n                                         ,[\"string-ith\", 2]\n                                         ,[\"int->string\", 1]\n                                         ,[\"string->int\", 1]\n                                         ,[\"explode\", 1]\n                                         ,[\"implode\", 1]\n                                         \n                                         // Eof\n                                         ,[\"eof-object?\", 1]\n                                         \n                                         // Misc\n                                         ,[\"=~\", 3]\n                                         ,[\"eq?\", 2]\n                                         ,[\"equal?\", 2]\n                                         ,[\"equal~?\", 3]\n                                         ,[\"eqv?\", 2]\n                                         ,[\"error\", 2]\n                                         \n                                         ,[\"identity\", 1]\n                                         ,[\"struct?\", 1]\n                                         ,[\"current-seconds\", 0]\n                                         \n                                         // Higher-Order Functions\n                                         ,[\"andmap\", 1, true]\n                                         ,[\"apply\", 2, true]           // *\n                                         ,[\"argmax\", 2]               // *\n                                         ,[\"argmin\", 2]               // *\n                                         ,[\"build-list\", 2]\n                                         ,[\"build-string\", 2]         // *\n                                         ,[\"compose\", 0, true]         // *\n                                         ,[\"filter\", 2]               // *\n                                         ,[\"foldl\", 2, true]\n                                         ,[\"foldr\", 2, true]                // *\n                                         ,[\"map\", 1, true]\n                                         ,[\"for-each\", 1, true]\n                                         ,[\"memf\", 2]                 // *\n                                         ,[\"ormap\", 1, true]                // *\n                                         ,[\"procedure?\", 1]           // *\n                                         ,[\"quicksort\", 2]            // *\n                                         ,[\"sort\", 2]                 // *\n                                         \n                                         ,[\"void\", 0, true]\n                                           \n                                         // Parsing\n                                         ,[\"xml->s-exp\", 1]\n                                         \n                                         // Vectors\n                                         ,[\"build-vector\", 2]\n                                         // FIXME: should only take one or two arguments\", not vararity\n                                         ,[\"make-vector\", 1, true]\n                                         ,[\"vector\", 0, true]\n                                         ,[\"vector-length\", 1]\n                                         ,[\"vector-ref\", 2]\n                                         ,[\"vector-set!\", 3]\n                                         ,[\"vector->list\", 1]\n                                         ,[\"list->vector\", 1]\n                                         ,[\"vector?\", 1]\n                                         \n                                         ,[\"printf\", 1, true]\n                                         ,[\"display\", 1]\n                                         ,[\"write\", 1]\n                                         ,[\"newline\", 0]\n                                         ,[\"call/cc\", 1]\n                                         ,[\"procedure-arity\", 1]\n                                         \n                                         \n                                         // Testing functions.\n                                         // NOTE: the desugar.ss module converts use of check-expect into ones that\n                                         // thunk its arguments\", and pass an additional location argument.\n                                         ,[\"check-expect\", 2]\n                                         ,[\"EXAMPLE\", 2]\n                                         ,[\"check-within\", 3]\n                                         ,[\"check-error\", 2]\n                                         ,[\"make-hasheq\", 0]\n                                         ,[\"make-hash\", 0]\n                                         ,[\"hash-set!\", 3 ]\n                                         ,[\"hash-ref\", 3]\n                                         ,[\"hash-remove!\", 2]\n                                         ,[\"hash-map\", 2]\n                                         ,[\"hash-for-each\", 2]\n                                         ,[\"hash?\", 1]\n                                         \n                                         // Exception raising\n                                         ,[\"raise\", 1]\n                                         \n                                         // Checking for undefined\n                                         ,[\"undefined?\", 1]\n                                         \n                                         // values for multiple value definition\n                                         ,[\"values\", 0, true]\n                                         \n                                         // structures\n                                         ,[\"make-struct-type\", 4, true]\n                                         ,[\"make-struct-field-accessor\", 2, true]\n                                         ,[\"make-struct-field-mutator\", 2, true]\n                                         \n                                         // continuation mark stuff\n                                         // FIXME: add support for prompt optional argument\n                                         ,[\"current-continuation-marks\", 0, false]\n                                         ,[\"continuation-mark-set->list\", 2, false]\n                                         \n                                         // Things for javascript FFI and world\n                                         ,[\"scheme->prim-js\", 1, false]\n                                         ,[\"prim-js->scheme\", 1, false]\n                                         ,[\"procedure->cps-js-fun\", 1, false]\n                                         ,[\"procedure->void-js-fun\", 1, false]\n                                         ,[\"js-===\", 2, false]\n                                         ,[\"js-get-named-object\", 1, false]\n                                         ,[\"js-get-field\", 2, true]\n                                         //,[\"get-js-array-field\", 2, false]\n                                         ,[\"js-set-field!\", 3, false]\n                                         //,[\"js-set-array-field!\", 3, false]\n                                         ,[\"js-typeof\", 1, false]\n                                         ,[\"js-instanceof\", 2, false]\n                                         ,[\"js-call\", 2, true]\n                                         ,[\"js-new\", 1, true]\n                                         ,[\"js-make-hash\", 0, true]\n                                         \n                                         ,[\"make-world-config\", 2, true]\n                                         ,[\"make-bb-info\", 2, false]\n                                         ,[\"bb-info?\", 1, false]\n                                         ,[\"bb-info-change-world\", 1, false]\n                                         ,[\"bb-info-toplevel-node\", 1, false]\n                                         \n                                         ,[\"make-effect-type\", 4, true]\n                                         ,[\"effect?\", 1, false]\n                                         ,[\"world-with-effects\", 2, false]\n                                         //,[\"coerce-world-handler\", 1, false]\n                                         ,[\"make-render-effect-type\", 4, true]\n                                         ,[\"render-effect-type?\", 1]\n                                         ,[\"render-effect?\", 1]\n                                         \n                                         //,[\"make-effect:do-nothing 0, false]\n                                         //,[\"effect:do-nothing? 1, false]\n                                         \n                                         ,[\"make-render-effect-type\", 4, true]\n                                         //,[\"render-effect-name 1, false]\n                                         //,[\"render-effect-dom-node 1, false]\n                                         //,[\"render-effect-effects 1, false]\n                                         //,[\"render-effect? 1, false]\n                                         \n                                         ,[\"values\", 0, true]\n                                         ,[\"sleep\", 0, true]\n                                         ,[\"current-inexact-milliseconds\", 0, false]\n                                         \n                                         ,[\"make-exn\", 2, false]\n                                         ,[\"exn-message\", 1, false]\n                                         ,[\"exn-continuation-marks\", 1, false]\n                                        ].map(makeFunctionBinding('\"moby/toplevel\"'))\n  );\n\n  // The core environment includes the baseConstants, the topLevel bindings, and the world bindings\n  // NOTE: worldModule *includes* worldEffects and worldHandlers, according to Danny's modules.ss file\n plt.compiler.topLevelModules = [topLevelModule, kernelMiscModule, , jsWorldModule, worldModule];\n plt.compiler.knownCollections = [\"bootstrap\", \"bootstrap2011\", \"bootstrap2012\", \"bootstrap2014\", \"bootstrap2015\"];\n \n \n plt.compiler.knownModules = [kernelMiscModule\n                              , jsWorldModule\n                              , foreignModule\n                              , worldModule\n                              , bootstrapTeachpack\n                              , bootstrapTeachpack2011\n                              , bootstrapTeachpack2012\n                              , bootstrapTeachpack2014\n                              , bootstrapTeachpack2015\n                              , bootstrapTiltTeachpack2012\n                              , bootstrapTiltTeachpack2014\n                              , bootstrapTiltTeachpack2015\n                              , cageTeachpack\n                              , cageTeachpack2011\n                              , cageTeachpack2012\n                              , cageTeachpack2014\n                              , functionTeachpack\n                              , functionTeachpack2011\n                              , functionTeachpack2012\n                              , functionTeachpack2014\n                              , functionTeachpack2015\n                              , locationModule\n                              , tiltModule\n                              , telephonyModule\n                              , netModule\n                              , parserModule\n                              , topLevelModule];\n})();\n\nmodule.exports = plt.compiler;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/modules.js\n ** module id = 8\n ** module chunks = 0\n **/","require('./structures');\nvar jsnums = require('./runtime/js-numbers');\nvar types = require('./runtime/types');\n\n// if not defined, declare the compiler object as part of plt\nwindow.plt   = window.plt   || {};\nplt.compiler = plt.compiler || {};\n\n/*\n TODO\n - compiled-indirects\n - someday, get rid of convertToBytecode()\n - PERF: Switch from array to hashtable for freeVariables search\n - fix uniqueGlobalNames hack!\n - deal with more complex module resolution (e.g. - rename-out, etc)\n */\n\n(function (){\n \n   // import frequently-used bindings\n   var literal          = plt.compiler.literal;\n   var symbolExpr       = plt.compiler.symbolExpr;\n   var Program          = plt.compiler.Program;\n   var ifExpr           = plt.compiler.ifExpr;\n   var beginExpr        = plt.compiler.beginExpr;\n   var localExpr        = plt.compiler.localExpr;\n   var andExpr          = plt.compiler.andExpr;\n   var orExpr           = plt.compiler.orExpr;\n   var lambdaExpr       = plt.compiler.lambdaExpr;\n   var quotedExpr       = plt.compiler.quotedExpr;\n   var callExpr         = plt.compiler.callExpr;\n   var defFunc          = plt.compiler.defFunc;\n   var defVar           = plt.compiler.defVar;\n   var defVars          = plt.compiler.defVars;\n   var defStruct        = plt.compiler.defStruct;\n   var requireExpr      = plt.compiler.requireExpr;\n   var provideStatement = plt.compiler.provideStatement;   \n\n   // Inheritance from pg 168: Javascript, the Definitive Guide.\n    var heir = function(p) {\n      var f = function() {};\n      f.prototype = p;\n      return new f();\n    };\n\n \n \n    literal.prototype.toBytecode = function(){\n      var str = this.val.toBytecode? this.val.toBytecode()\n              : this.val===true? \"true\"\n              : this.val===false? \"false\"\n              : this.toString();\n      return '{\"$\":\"constant\",\"value\":'+str+'}';\n    };\n    symbolExpr.prototype.toBytecode = function(){\n      return 'types.symbol(\"'+escapeSym(this.val)+'\")';\n    };\n    Vector.prototype.toBytecode = function(){\n      return 'types.vector(['+this.elts.join(',')+'])';\n    };\n    Array.prototype.toBytecode = function(quoted){\n      return 'types.'+(this.length===0? 'EMPTY':'list(['+this.map(convertToBytecode).join(',')+'])');\n    };\n    // Bytecode generation for jsnums types\n    jsnums.Rational.prototype.toBytecode = function(){\n      return 'types.rational('+convertToBytecode(this.n)+', '+convertToBytecode(this.d)+')';\n    };\n    jsnums.BigInteger.prototype.toBytecode = function(){\n      return 'types.bignum(\"'+this.toString()+'\")';\n    };\n    jsnums.FloatPoint.prototype.toBytecode = function(){\n      var num = this.toString();\n      if(num===\"+nan.0\") num = \"NaN\";\n      if(num===\"+inf.0\") num = \"Infinity\";\n      if(num===\"-inf.0\") num = \"-Infinity\";\n      return 'types[\"float\"]('+num+')';\n    };\n    jsnums.Complex.prototype.toBytecode = function(){\n      return 'types.complex('+convertToBytecode(this.r)+', '+convertToBytecode(this.i)+')';\n    };\n    Char.prototype.toBytecode = function(){\n      return 'types[\\'char\\'](String.fromCharCode('+this.val.charCodeAt(0)+'))';\n    };\n    // STACKREF STRUCTS ////////////////////////////////////////////////////////////////\n    function stackReference(){}\n    function localStackReference(name, isBoxed, depth){\n      stackReference.call(this);\n      this.name = name;\n      this.isBoxed = isBoxed;\n      this.depth = depth;\n    }\n    localStackReference.prototype = heir(stackReference.prototype);\n    function globalStackReference(name, depth, pos){\n      stackReference.call(this);\n      this.name = name;\n      this.pos = pos;\n      this.depth = depth;\n    }\n    globalStackReference.prototype = heir(stackReference.prototype);\n    function unboundStackReference(name){\n      stackReference.call(this);\n      this.name = name;\n    }\n    unboundStackReference.prototype = heir(stackReference.prototype);\n\n\n    /**************************************************************************\n     *\n     *    BYTECODE STRUCTS -\n     *    (see https://github.com/bootstrapworld/wescheme-compiler2012/blob/master/js-runtime/src/bytecode-structs.ss)\n     *\n     **************************************************************************/\n \n \n    // all Programs, by default, print out their values and have no location\n    // anything that behaves differently must provide their own toBytecode() function\n    var Bytecode = function() {\n      // -> JSON\n      this.toBytecode = function(){ console.log(this); throw \"IMPOSSIBLE - generic bytecode toBytecode method was called\"; };\n    };\n\n    // for mapping JSON conversion over an array\n    function convertToBytecode(bc){\n       if(types.isString(bc) && bc.chars!==undefined) return '\"'+bc.toString()+'\"';\n       return (bc.toBytecode)? bc.toBytecode() : bc;\n    }\n \n    // convert a symbol-name into bytecode string\n    function escapeSym(symName){\n      var str = symName.toString().replace(/\\|/g,''),  bcStr = \"\";\n      // possible characters that need to be escaped\n      var escapes = [\"{\", \"}\", \"[\", \"]\", \",\", \"'\", \"`\", \" \", \"\\\\\", '\"'];\n      for(var j=0; j<str.length; j++){\n        bcStr += ((escapes.indexOf(str.charAt(j)) > -1)? '\\\\' : '') + str.charAt(j);\n      }\n      // special-case for newline characters\n      bcStr= bcStr.replace(/\\n/g,\"\\\\n\");\n      return bcStr;\n    }\n \n    // Global bucket\n    function globalBucket(name) {\n      Bytecode.call(this);\n      this.name = name;  // symbol\n      this.toBytecode = function(){\n        return '{\"$\":\"global-bucket\",\"value\":\"'+escapeSym(this.name)+'\"}';\n      };\n    };\n    globalBucket.prototype = heir(Bytecode.prototype);\n\n    // Module variable\n    function moduleVariable(modidx, sym, pos, phase) {\n      Bytecode.call(this);\n      this.$    = 'module-variable';\n      this.modidx = modidx; // module-path-index\n      this.sym    = sym;    // symbol\n      this.pos    = pos;    // exact integer\n      this.phase  = phase;  // 1/0 - direct access to exported id\n      this.toBytecode = function(){\n        return '{\"$\":\"module-variable\",\"sym\":'+this.sym.toBytecode()\n                +',\"modidx\":'+this.modidx.toBytecode()+',\"pos\":'+this.pos\n                +',\"phase\":'+this.phase+'}';\n      };\n    };\n    moduleVariable.prototype = heir(Bytecode.prototype);\n\n    // Wrap syntax object\n    function wrap() {\n      Bytecode.call(this);\n    };\n    wrap.prototype = heir(Bytecode.prototype);\n\n    // Wrapped syntax object\n    function wrapped(datum, wraps, certs) {\n      Bytecode.call(this);\n      this.datum  = datum;  // any\n      this.wraps  = wraps;  // list of wrap\n      this.certs = certs;   // list or false\n    };\n    wrapped.prototype = heir(Bytecode.prototype);\n\n    // Stx\n    function stx(encoded) {\n      this.encoded  = encoded;  // wrapped\n      Bytecode.call(this);\n    };\n    stx.prototype = heir(Bytecode.prototype);\n\n    // prefix\n    function prefix(numLifts, topLevels, stxs) {\n      Bytecode.call(this);\n      this.numLifts   = numLifts;  // exact, non-negative integer\n      this.topLevels  = topLevels; // list of (false, symbol, globalBucket or moduleVariable)\n      this.stxs       = stxs;      // list of stxs\n      this.toBytecode = function(){\n        return '{\"$\":\"prefix\",\"num-lifts\":'+this.numLifts+',\"toplevels\":['\n                +this.topLevels.map(function(v){return convertToBytecode(v);}).join(',')\n                +'],\"stxs\":['\n                +this.stxs.map(convertToBytecode)+']}';\n      };\n    };\n    prefix.prototype = heir(Bytecode.prototype);\n\n    // form\n    function form() {\n      Bytecode.call(this);\n    };\n    form.prototype = heir(Bytecode.prototype);\n\n    // expr\n    function expr(form) {\n      Bytecode.call(this);\n    };\n    expr.prototype = heir(Bytecode.prototype);\n\n    // Indirect\n    function indirect(v) {\n      Bytecode.call(this);\n      this.v  = v; // ??\n      this.toBytecode = function(){\n        return '{\"$\":\"indirect\",\"v\":'+this.v.toBytecode()+'}';\n      };\n    };\n    indirect.prototype = heir(Bytecode.prototype);\n\n    // compilationTop\n    function compilationTop(maxLetDepth, prefix, code) {\n      Bytecode.call(this);\n      this.maxLetDepth= maxLetDepth;  // exact non-negative integer\n      this.prefix     = prefix;       // prefix\n      this.code       = code;         // form, indirect, or any\n      this.toBytecode = function(){\n        return '{\"$\":\"compilation-top\",\"max-let-depth\":'+this.maxLetDepth+',\"prefix\":'\n              + this.prefix.toBytecode()+',\"compiled-indirects\":[],\"code\":'\n              + this.code.toBytecode()+'}';\n      };\n    };\n    compilationTop.prototype = heir(Bytecode.prototype);\n\n    // provided\n    function provided(name, src, srcName, nomSrc, srcPhase, isProtected, insp) {\n      Bytecode.call(this);\n      this.name     = name;      // symbol\n      this.src      = src;       // false or modulePathIndex\n      this.srcName  = srcName;   // symbol\n      this.nomSrc   = nomSrc;    // false or modulePathIndex\n      this.srcPhase = srcPhase;  // 0/1\n      this.insp     = insp;      // boolean or void\n      this.isProtected=isProtected; // boolean\n    };\n    provided.prototype = heir(Bytecode.prototype);\n\n    // topLevel\n    function topLevel(depth, pos, constant, ready, loc) {\n      Bytecode.call(this);\n      this.depth    = depth;    // exact, non-negative integer\n      this.pos      = pos;      // exact, non-negative integer\n      this.constant = constant; // boolean\n      this.ready    = ready;    // boolean\n      this.loc      = loc;      // false or Location\n      this.toBytecode = function(){\n        return '{\"$\":\"toplevel\",\"depth\":'+this.depth.toString()+',\"pos\":'+this.pos.toString()\n                +',\"const?\":'+this.constant+',\"ready?\":'+this.ready+',\"loc\":'\n                + (this.loc && this.loc.toVector().toBytecode())+'}';\n      };\n    };\n    topLevel.prototype = heir(Bytecode.prototype);\n\n    // seq\n    function seq(forms) {\n      Bytecode.call(this);\n      this.forms    = forms;  // list of form, indirect, any\n      this.toBytecode = function(){\n        return '{\"$\":\"seq\",\"forms\":['+this.forms.map(convertToBytecode).join(',')+']}';\n      };\n    };\n    seq.prototype = heir(Bytecode.prototype);\n\n    // defValues\n    function defValues(ids, rhs) {\n      Bytecode.call(this);\n      this.ids  = ids;  // list of toplevel or symbol\n      this.rhs  = rhs;  // expr, indirect, seq, any\n      this.toBytecode = function(){\n        return '{\"$\":\"def-values\",\"ids\":['+this.ids.map(convertToBytecode).join(',')\n                +'],\"body\":'+this.rhs.toBytecode()+'}';\n      };\n    };\n    defValues.prototype = heir(Bytecode.prototype);\n\n    // defSyntaxes\n    function defSyntaxes(ids, rhs, prefix, maxLetDepth) {\n      Bytecode.call(this);\n      this.$          = 'def-values';\n      this.ids        = ids;      // list of toplevel or symbol\n      this.rhs        = rhs;      // expr, indirect, seq, any\n      this.prefix     = prefix;   // prefix\n      this.maxLetDepth= maxLetDepth; // exact, non-negative integer\n      this.toBytecode = function(){\n        return '{\"$\":\"def-values\",\"ids\":['+this.ids.toBytecode().join(',')\n                +'],\"rhs\":'+this.rhs.toBytecode()\n                +',\"prefix\":'+this.prefix.toBytecode()+',\"max-let-depth\":'+this.maxLetDepth.toBytecode()+'}';\n      };\n    };\n    defSyntaxes.prototype = heir(Bytecode.prototype);\n\n    // defForSyntax\n    function defForSyntax(ids, rhs, prefix, maxLetDepth) {\n      Bytecode.call(this);\n      this.ids        = ids;      // list of toplevel or symbol\n      this.rhs        = rhs;      // expr, indirect, seq, any\n      this.prefix     = prefix;   // prefix\n      this.maxLetDepth= maxLetDepth; // exact, non-negative integer\n    };\n    defForSyntax.prototype = heir(Bytecode.prototype);\n\n    // mod\n    function mod(name, selfModidx, prefix, provides, requires, body,\n                 syntaxBody, unexported, maxLetDepth, dummy, langInfo,\n                 internalContext) {\n      Bytecode.call(this);\n      this.name       = name;         // exact, non-negative integer\n      this.selfModidx = selfModidx;   // exact, non-negative integer\n      this.prefix     = prefix;       // boolean\n      this.provides   = provides;     // boolean\n      this.requires   = requires;     // false or Location\n      this.body       = body;         // exact, non-negative integer\n      this.syntaxBody = syntaxBody;   // exact, non-negative integer\n      this.unexported = unexported;   // boolean\n      this.maxLetDepth= maxLetDepth;  // exact, non-negative integer\n      this.dummy      = dummy;        // false or Location\n      this.langInfo   = langInfo;     // false or (vector modulePath symbol any)\n      this.internalContext = internalContext;\n      this.toBytecode = function(){\n        return '{\"$\":\"mod\",\"name\":'+this.name.toBytecode()+',\"self-modidx\":'+this.selfModidx.toBytecode()\n                +',\"prefix\":'+this.prefix.toBytecode()+',\"provides\":'+this.provides.toBytecode()\n                +',\"requires\":'+(this.requires && this.requires.toVector().toBytecode())+',\"body\":'\n                +this.body.toBytecode()+',\"stx-body\":'+this.syntaxBody.toBytecode()+',\"max-let-depth\":'\n                +this.maxLetDepth.toBytecode()+'}';\n      };\n    };\n    mod.prototype = heir(Bytecode.prototype);\n\n    // lam\n    function lam(name, operatorAndRandLocs, flags, numParams, paramTypes,\n                 rest, closureMap, closureTypes, maxLetDepth, body) {\n \n      Bytecode.call(this);\n      this.name       = name;         // symbol, vector, empty\n      this.flags      = flags;        // (list of ('preserves-marks 'is-method 'single-result))\n      this.numParams  = numParams;    // exact, non-negative integer\n      this.paramTypes = paramTypes;   // list of ('val 'ref 'flonum)\n      this.rest       = rest;         // boolean\n      this.body       = body;         // expr, seq, indirect\n      this.closureMap = closureMap;   // vector of exact, non-negative integers\n      this.maxLetDepth= maxLetDepth;  // exact, non-negative integer\n      this.closureTypes=closureTypes; // list of ('val/ref or 'flonum)\n      this.operatorAndRandLocs = operatorAndRandLocs; // list of Vectors\n      // operator+rand-locs includes a list of vectors corresponding to the location\n      // of the operator, operands, etc if we can pick them out.  If we can't get\n      // this information, it's false\n      this.toBytecode = function(){\n        return '{\"$\":\"lam\",\"name\":'+this.name.toBytecode()+',\"locs\":['\n                +this.operatorAndRandLocs.map(convertToBytecode).join(',')+'],\"flags\":['\n                +this.flags.map(convertToBytecode).join(',')+'],\"num-params\":'+this.numParams\n                +',\"param-types\":['+this.paramTypes.map(convertToBytecode).join(',')+'],\"rest?\":'+this.rest\n                +',\"closure-map\":['+this.closureMap.map(convertToBytecode).join(',')+'],\"closure-types\":['\n                +this.closureTypes.map(convertToBytecode).join(',')+'],\"max-let-depth\":'+this.maxLetDepth\n                +',\"body\":'+this.body.toBytecode()+'}';\n      };\n    };\n    lam.prototype = heir(Bytecode.prototype);\n\n\n    // closure: a static closure (nothing to close over)\n    function closure(code, genId) {\n      Bytecode.call(this);\n      this.code     = code;  // lam\n      this.genId    = genId; // symbol\n      this.toBytecode = function(){\n        return '{\"$\":\"closure\",\"code\":'+this.code.toBytecode()+',\"gen-id\":'+this.genId.toBytecode()+'}';\n      };\n    };\n    closure.prototype = heir(Bytecode.prototype);\n\n    // caseLam: each clause is a lam (added indirect)\n    function caseLam(name, clauses) {\n      Bytecode.call(this);\n      this.name     = name;  // symbol, vector, empty\n      this.clauses  = clauses; // list of (lambda or indirect)\n      this.toBytecode = function(){\n        return '{\"$\":\"case-lam\",\"name\":'+this.name.toBytecode()+',\"clauses\":'+this.clauses.toBytecode()+'}';\n      };\n    };\n    caseLam.prototype = heir(Bytecode.prototype);\n\n    // letOne\n    function letOne(rhs, body, flonum) {\n      Bytecode.call(this);\n      this.rhs     = rhs;   // expr, seq, indirect, any\n      this.body    = body;  // expr, seq, indirect, any\n      this.flonum  = flonum;// boolean\n      this.toBytecode = function(){\n        return '{\"$\": \"let-one\",\"rhs\":'+this.rhs.toBytecode()+',\"body\":'+this.body.toBytecode()\n                +',\"flonum\":'+this.flonum.toBytecode()+'}';\n      };\n    };\n    letOne.prototype = heir(Bytecode.prototype);\n\n    // letVoid\n    function letVoid(count, boxes, body) {\n      Bytecode.call(this);\n      this.count   = count;   // exact, non-negative integer\n      this.boxes   = boxes;   // boolean\n      this.body    = body;    // expr, seq, indirect, any\n      this.toBytecode = function(){\n        return '{\"$\":\"let-void\",\"count\":'+convertToBytecode(this.count)+',\"boxes?\":'\n                +convertToBytecode(this.boxes)+',\"body\":'+this.body.toBytecode()+'}';\n      };\n    };\n    letVoid.prototype = heir(Bytecode.prototype);\n\n    // letRec: put `letrec'-bound closures into existing stack slots\n    function letRec(procs, body) {\n      Bytecode.call(this);\n      this.procs   = procs;   // list of lambdas\n      this.body    = body;    // expr, seq, indirect, any\n      this.toBytecode = function(){\n        return '{\"$\":\"let-rec\",\"procs\":'+this.procs.toBytecode()+',\"body\":'+this.body.toBytecode()+'}';\n      };\n    };\n    letRec.prototype = heir(Bytecode.prototype);\n\n    // installValue\n    function installValue(count, pos, boxes, rhs, body) {\n      Bytecode.call(this);\n      this.count   = count;   // exact, non-negative integer\n      this.pos     = pos;     // exact, non-negative integer\n      this.boxes   = boxes;   // boolean\n      this.rhs     = rhs;     // expr, seq, indirect, any\n      this.body    = body;    // expr, seq, indirect, any -- set existing stack slot(s)\n      this.toBytecode = function(){\n        return '{\"$\":\"install-value\",\"count\":'+convertToBytecode(this.count)+',\"pos\":'+convertToBytecode(this.pos)\n                +',\"boxes?\":'+convertToBytecode(this.boxes)+',\"rhs\":'+this.rhs.toBytecode()\n                +',\"body\":'+this.body.toBytecode()+'}';\n      };\n    };\n    installValue.prototype = heir(Bytecode.prototype);\n\n    // boxEnv: box existing stack element\n    function boxEnv(pos, body) {\n      Bytecode.call(this);\n      this.pos     = pos;     // exact, non-negative integer\n      this.body    = body;    // expr, seq, indirect, any\n      this.toBytecode = function(){\n        return '{\"$\":\"boxenv\",\"pos\":'+this.pos.toBytecode()+',\"body\":'+this.body.toBytecode()+'}';\n      };\n    };\n    boxEnv.prototype = heir(Bytecode.prototype);\n\n    // localRef: access local via stack\n    function localRef(unbox, pos, clear, otherClears, flonum) {\n      Bytecode.call(this);\n      this.unbox   = unbox || false;   // boolean\n      this.pos     = pos;     // exact, non-negative integer\n      this.clear   = clear;   // boolean\n      this.flonum  = flonum;  // boolean\n      this.otherClears= otherClears; // boolean\n      this.toBytecode = function(){\n        return '{\"$\":\"localref\",\"unbox?\":'+this.unbox+',\"pos\":'+this.pos+',\"clear\":'+this.clear\n                +',\"other-clears?\":'+this.otherClears+',\"flonum?\":'+this.flonum+'}';\n      };\n    };\n    localRef.prototype = heir(Bytecode.prototype);\n\n    // topSyntax : access syntax object via prefix array (which is on stack)\n    function topSyntax(depth, pos, midpt) {\n      Bytecode.call(this);\n      this.depth   = depth;   // exact, non-negative integer\n      this.pos     = pos;     // exact, non-negative integer\n      this.midpt   = midpt;   // exact, non-negative integer\n    };\n    topSyntax.prototype = heir(Bytecode.prototype);\n\n    // application: function call\n    function application(rator, rands) {\n      Bytecode.call(this);\n      this.rator   = rator;   // expr, seq, indirect, any\n      this.rands   = rands;   // list of (expr, seq, indirect, any)\n      this.toBytecode = function(){\n        return '{\"$\":\"application\",\"rator\":'+this.rator.toBytecode()+',\"rands\":['\n                +this.rands.map(convertToBytecode).join(',')+']}';\n      };\n    };\n    application.prototype = heir(Bytecode.prototype);\n\n    // branch\n    function branch(testExpr, thenExpr, elseExpr) {\n      Bytecode.call(this);\n      this.testExpr = testExpr;   // expr, seq, indirect, any\n      this.thenExpr = thenExpr;   // expr, seq, indirect, any\n      this.elseExpr = elseExpr;   // expr, seq, indirect, any\n      this.toBytecode = function(){\n        return '{\"$\":\"branch\",\"test\":'+this.testExpr.toBytecode()\n                +',\"then\":'+this.thenExpr.toBytecode()\n                +',\"else\":'+this.elseExpr.toBytecode()+'}';\n      };\n    };\n    branch.prototype = heir(Bytecode.prototype);\n\n    // withContMark:'with-cont-mark'\n    function withContMark(key, val, body) {\n      Bytecode.call(this);\n      this.$    = 'with-cont-mark';\n      this.key  = key;   // expr, seq, indirect, any\n      this.val  = val;   // expr, seq, indirect, any\n      this.body = body;  // expr, seq, indirect, any\n      this.toBytecode = function(){\n        return '{\"$\":\"with-cont-mark\",\"key\":'+new literal(new symbolExpr(this.key)).toBytecode()\n                +',\"val\":'+new literal(this.val).toBytecode()\n                +',\"body\":'+this.body.toBytecode()+'}';\n      };\n    };\n    withContMark.prototype = heir(Bytecode.prototype);\n\n    // beg0: begin0\n    function beg0(seq) {\n      Bytecode.call(this);\n      this.seq  = seq;   // list  of (expr, seq, indirect, any)\n      this.toBytecode = function(){ return '{\"$\":\"beg0\",\"seq\":'+this.seq.toBytecode()+'}';  };\n    };\n    beg0.prototype = heir(Bytecode.prototype);\n\n    // splice: top-level 'begin'\n    function splice(forms) {\n      Bytecode.call(this);\n      this.forms  = forms;   // list  of (expr, seq, indirect, any)\n      this.toBytecode = function(){ return '{\"$\":\"splice\",\"forms\":'+this.forms.toBytecode()+'}';  };\n    };\n    splice.prototype = heir(Bytecode.prototype);\n\n    // varRef: `#%variable-reference'\n    function varRef(topLevel) {\n      Bytecode.call(this);\n      this.topLevel  = topLevel;   // topLevel\n      this.toBytecode = function(){ return '{\"$\":\"varref\",\"top-level\":'+this.topLevel.toBytecode()+'}';  };\n    };\n    varRef.prototype = heir(Bytecode.prototype);\n\n    // assign: top-level or module-level set!\n    function assign(id, rhs, undefOk) {\n      Bytecode.call(this);\n      this.id      = id;      // topLevel\n      this.rhs     = rhs;     // expr, seq, indirect, any\n      this.undefOk = undefOk; // boolean\n      this.toBytecode = function(){\n        return '{\"$\":\"assign\",\"id\":'+this.id.toBytecode()+',\"rhs\":'+this.rhs.toBytecode()\n                +',\"undef-ok\":'+this.undefOk.toBytecode()+'}';\n      };\n    };\n    assign.prototype = heir(Bytecode.prototype);\n\n    // applyValues: `(call-with-values (lambda () ,args-expr) ,proc)\n    function applyValues(proc, args) {\n      Bytecode.call(this);\n      this.proc    = proc;    // expr, seq, indirect, any\n      this.args    = args;    // expr, seq, indirect, any\n      this.toBytecode = function(){\n        return '{\"$\":\"apply-values\",\"proc\":'+this.proc.toBytecode()+',\"args\":'+this.args.toBytecode()+'}';\n      };\n    };\n    applyValues.prototype = heir(Bytecode.prototype);\n\n    // primVal: direct preference to a kernel primitive\n    function primVal(id) {\n      Bytecode.call(this);\n      this.id      = id;    // exact, non-negative integer\n      this.toBytecode = function(){ return '{\"$\":\"primval\",\"id\":'+this.id.toBytecode()+'}';  };\n    };\n    primVal.prototype = heir(Bytecode.prototype);\n\n    // req\n    function req(reqs, dummy) {\n      Bytecode.call(this);\n      this.$        = 'req';\n      this.reqs    = reqs;    // syntax\n      this.dummy   = dummy;   // toplevel\n      this.toBytecode = function(){\n        var reqBytecode = (this.reqs instanceof literal)? '\"'+this.reqs.val+'\"' : this.reqs.toBytecode();\n        return '{\"$\":\"req\",\"reqs\":'+reqBytecode+',\"dummy\":'+this.dummy.toBytecode()+'}';\n      };\n    };\n    req.prototype = heir(Bytecode.prototype);\n\n    // lexicalRename\n    function lexicalRename(bool1, bool2, alist) {\n      this.bool1   = bool1;    // boolean\n      this.bool2   = bool2;    // boolean\n      this.alist   = alist;    // should be list of (cons symbol, symbol)\n      Bytecode.call(this);\n    };\n    lexicalRename.prototype = heir(Bytecode.prototype);\n\n    // phaseShift\n    function phaseShift(amt, src, dest) {\n      this.amt     = amt;    // syntax\n      this.src     = src;    // false or modulePathIndex\n      this.dest    = dest;   // false or modulePathIndex\n      Bytecode.call(this);\n    };\n    phaseShift.prototype = heir(Bytecode.prototype);\n\n    // wrapMark\n    function wrapMark(val) {\n      this.val     = val;    // exact integer\n      Bytecode.call(this);\n    };\n    wrapMark.prototype = heir(Bytecode.prototype);\n\n    // prune\n    function prune(sym) {\n      this.sym     = sym;    // any\n      Bytecode.call(this);\n    };\n    prune.prototype = heir(Bytecode.prototype);\n\n    // allFromModule\n    function allFromModule(path, phase, srcPhase, exceptions, prefix) {\n      this.path     = path;       // modulePathIndex\n      this.phase    = phase;      // false or exact integer\n      this.srcPhase = srcPhase;   // any\n      this.prefix   = prefix;     // false or symbol\n      this.exceptions=exceptions; // list of symbols\n      Bytecode.call(this);\n    };\n    allFromModule.prototype = heir(Bytecode.prototype);\n\n    // nominalPath\n    function nominalPath() {\n      Bytecode.call(this);\n    };\n    nominalPath.prototype = heir(Bytecode.prototype);\n\n    // simpleNominalPath\n    function simpleNominalPath(value) {\n      this.value = value; // modulePathIndex\n      Bytecode.call(this);\n    };\n    simpleNominalPath.prototype = heir(Bytecode.prototype);\n\n/*    // moduleBinding\n    function moduleBinding() {\n      Bytecode.call(this);\n    };\n    moduleBinding.prototype = heir(Bytecode.prototype);\n*/\n    // phasedModuleBinding\n    function phasedModuleBinding(path, phase, exportName, nominalPath, nominalExportName) {\n      this.path       = path;       // modulePathIndex\n      this.phase      = phase;      // exact integer\n      this.exportName = nominalPath;// nominalPath\n      this.nominalExportName  = nominalExportName; // any\n      Bytecode.call(this);\n    };\n    phasedModuleBinding.prototype = heir(Bytecode.prototype);\n\n    // exportedNominalModuleBinding\n    function exportedNominalModuleBinding(path, exportName, nominalPath, nominalExportName) {\n      this.path       = path;       // modulePathIndex\n      this.exportName = exportName; // any\n      this.nominalPath= nominalPath;// nominalPath\n      this.nominalExportName  = nominalExportName; // any\n      Bytecode.call(this);\n    };\n    exportedNominalModuleBinding.prototype = heir(Bytecode.prototype);\n\n    // nominalModuleBinding\n    function nominalModuleBinding(path, nominalPath) {\n      this.path       = path;        // modulePathIndex\n      this.nominalPath= nominalPath; // any\n      Bytecode.call(this);\n    };\n    nominalModuleBinding.prototype = heir(Bytecode.prototype);\n\n    // exportedModuleBinding\n    function exportedModuleBinding(path, exportName) {\n      this.path       = path;       // modulePathIndex\n      this.exportName = exportName; // any\n      Bytecode.call(this);\n    };\n    exportedModuleBinding.prototype = heir(Bytecode.prototype);\n\n    // simpleModuleBinding\n    function simpleModuleBinding(path) {\n      this.path       = path;       // modulePathIndex\n      Bytecode.call(this);\n    };\n    simpleModuleBinding.prototype = heir(Bytecode.prototype);\n\n    // ModuleRename\n    function ModuleRename(phase, kind, setId, unmarshals, renames, markRenames, plusKern) {\n      this.phase      = phase;       // false or exact integer\n      this.kind       = kind;        // \"marked\" or \"normal\"\n      this.unmarshals = unmarshals;  // list of allFromModule\n      this.renames    = renames;     // list of (symbol or moduleBinding)\n      this.markRenames= markRenames; // any\n      this.plusKern   = plusKern;    // boolean\n      Bytecode.call(this);\n    };\n    ModuleRename.prototype = heir(Bytecode.prototype);\n \n    // HACK: module-path\n    function modulePath(path, base){\n      this.path = path;\n      this.base = base;\n      Bytecode.call(this);\n      this.toBytecode = function(){\n        return '{\"$\":\"module-path\",\"path\":'+convertToBytecode(this.path)+',\"base\":'+convertToBytecode(this.base)+'}';\n      };\n    };\n    modulePath.prototype = heir(Bytecode.prototype);\n \n    // freeVariables : [listof symbols] env -> [list of symbols]\n    Program.prototype.freeVariables   = function(acc, env){ return acc; }\n    ifExpr.prototype.freeVariables    = function(acc, env){\n      return this.alternative.freeVariables(this.consequence.freeVariables(this.predicate.freeVariables(acc, env), env), env);\n    };\n    beginExpr.prototype.freeVariables = function(acc, env){\n      return this.exprs.reduceRight(function(acc, expr){return expr.freeVariables(acc, env);}, acc);\n    };\n    // if it's an unbound variable that we haven't seen before, add it to acc\n    symbolExpr.prototype.freeVariables= function(acc, env){\n      return ((env.lookup(this.val, 0) instanceof unboundStackReference)\n              && (acc.indexOf(this) == -1))? acc.concat([this]) : acc;\n    };\n    localExpr.prototype.freeVariables = function(acc, env){\n      // helper functions\n      var pushLocalBoxedFromSym = function(env, sym) { return new plt.compiler.localEnv(sym.val, true, env); },\n          pushLocalFromSym      = function(env, sym) { return new plt.compiler.localEnv(sym.val, false, env); };\n \n          // collect all the defined names in the local\n      var definedNames = this.defs.reduce(function(names, d){\n                                            return ((d instanceof defVars)? d.names : [d.name]).concat(names); }\n                                           , []),\n          // make an environment with those names added to the stack\n          updatedEnv = definedNames.reduce(pushLocalBoxedFromSym, env),\n          // use that env to find all free variables in the body\n          freeVarsInBody = this.body.freeVariables(acc, updatedEnv),\n \n          // given free variables and a definition, add the free variables from that definition...\n          // while *also* updating the stack to reflect defined names\n          addFreeVarsInDef = function(acc, d){\n             if(d instanceof defFunc){\n                var envWithArgs = d.args.reduce(function(env, arg){return pushLocalFromSym(env, arg);}, updatedEnv);\n                return d.body.freeVariables(acc, envWithArgs);\n             }\n             if(d instanceof defStruct){ return acc; }\n             else{ return d.expr.freeVariables(acc, updatedEnv); }\n          }\n \n      // collect free variables from all the definitions and the body, while simultaneously\n      // updating the environment to reflect defined names\n      return this.defs.reduce(addFreeVarsInDef, freeVarsInBody);\n    };\n    andExpr.prototype.freeVariables   = function(acc, env){\n       return this.exprs.reduceRight(function(acc, expr){ return expr.freeVariables(acc, env);} , acc);\n    };\n    orExpr.prototype.freeVariables    = function(acc, env){\n       return this.exprs.reduceRight(function(acc, expr){ return expr.freeVariables(acc, env);} , acc);\n    }\n    // be careful to make a copy of the array before reversing!\n    lambdaExpr.prototype.freeVariables= function(acc, env){\n      var pushLocalFromSym  = function(env, sym) { return new plt.compiler.localEnv(sym.val, false, env); },\n          envWithArgs       = this.args.slice(0).reverse().reduce(pushLocalFromSym, env);\n      return this.body.freeVariables(acc, envWithArgs);\n \n    };\n    quotedExpr.prototype.freeVariables= function(acc, env){ return acc; };\n    callExpr.prototype.freeVariables  = function(acc, env){\n      return this.func.freeVariables(acc, env).concat(this.args).reduceRight(function(acc, expr){\n                                                                                return expr.freeVariables(acc, env);\n                                                                              } , acc);\n    };\n \n  /**************************************************************************\n   *\n   *    COMPILATION -\n   *    (see https://github.com/bootstrapworld/wescheme-compiler2012/blob/master/js-runtime/src/mzscheme-vm.ss)\n   *\n   **************************************************************************/\n \n   // sort-and-unique: (listof X) (X X -> boolean) (X X -> boolean) -> (listof X)\n   function sortAndUnique(elts, lessThan, equalTo) {\n      function unique(elts){\n        return (elts.length <= 1)? elts\n               :  equalTo(elts[0], elts[1])? unique(elts.slice(1))\n               :  [elts[0]].concat(unique(elts.slice(1)));\n      }\n      // convert lessThan fn into a fn that returns -1 for less, 1 for greater, 0 for equal\n      var convertedSortFn = function(x,y){ return lessThan(x,y)? -1 : lessThan(y,x);}\n      return unique(elts.sort(convertedSortFn));\n   }\n \n \n   // [bytecodes, pinfo, env], Program -> [bytecodes, pinfo, env]\n   // compile the program, then add the bytecodes and pinfo information to the acc\n   function compilePrograms(acc, p){\n    var bytecodes = acc[0], pinfo = acc[1], env = acc[2],\n        compiledProgramAndPinfo = p.compile(env, pinfo),\n        compiledProgram = compiledProgramAndPinfo[0],\n        pinfo     = compiledProgramAndPinfo[1];\n    return [[compiledProgram].concat(bytecodes), pinfo, env];\n   }\n \n   // extend the Program class to include compilation\n   // compile: pinfo -> [bytecode, pinfo]\n \n   // literals evaluate to themselves\n   Program.prototype.compile = function(env, pinfo){\n      return [this, pinfo];\n   };\n   \n   defFunc.prototype.compile = function(env, pinfo){\n      var compiledFunNameAndPinfo = this.name.compile(env, pinfo),\n          compiledFunName = compiledFunNameAndPinfo[0],\n          pinfo = compiledFunNameAndPinfo[1];\n      var lambda = new lambdaExpr(this.args, this.body),\n          compiledLambdaAndPinfo = lambda.compile(env, pinfo, false, this.name),\n          compiledLambda = compiledLambdaAndPinfo[0],\n          pinfo = compiledLambdaAndPinfo[1];\n      var bytecode = new defValues([compiledFunName], compiledLambda);\n      return [bytecode, pinfo];\n   };\n\n   defVar.prototype.compile = function(env, pinfo){\n      var compiledIdAndPinfo = this.name.compile(env, pinfo),\n          compiledId = compiledIdAndPinfo[0],\n          pinfo = compiledIdAndPinfo[1];\n      var compiledExprAndPinfo = this.expr.compile(env, pinfo),\n          compiledExpr = compiledExprAndPinfo[0],\n          pinfo = compiledExprAndPinfo[1];\n      var bytecode = new defValues([compiledId], compiledExpr);\n      return [bytecode, pinfo];\n   };\n\n   defVars.prototype.compile = function(env, pinfo){\n        var compiledIdsAndPinfo = this.names.reduceRight(compilePrograms, [[], pinfo, env]),\n            compiledIds = compiledIdsAndPinfo[0],\n            pinfo = compiledIdsAndPinfo[1];\n        var compiledBodyAndPinfo = this.expr.compile(env, pinfo),\n            compiledBody = compiledBodyAndPinfo[0],\n            pinfo = compiledBodyAndPinfo[1];\n        var bytecode = new defValues(compiledIds, compiledBody);\n        return [bytecode, pinfo];\n   };\n   \n   beginExpr.prototype.compile = function(env, pinfo){\n      var compiledExpressionsAndPinfo = this.exprs.reduceRight(compilePrograms, [[], pinfo, env]),\n          compiledExpressions = compiledExpressionsAndPinfo[0],\n          pinfo1 = compiledExpressionsAndPinfo[1];\n      var bytecode = new seq(compiledExpressions);\n      return [bytecode, pinfo1];\n   };\n\n   // Compile a lambda expression.  The lambda must close its free variables over the\n   // environment.\n   lambdaExpr.prototype.compile = function(env, pinfo, isUnnamedLambda, name){\n      if(isUnnamedLambda===undefined) isUnnamedLambda = true;\n \n      // maskUnusedGlobals : (listof symbol?) (listof symbol?) -> (listof symbol or false)\n      function maskUnusedGlobals(listOfNames, namesToKeep){\n        return listOfNames.map(function(n){ return (namesToKeep.indexOf(n)>-1)? n : false; });\n      }\n\n      function pushLocal(env, n)      { return new plt.compiler.localEnv(n, false, env); }\n      function pushLocalBoxed(env, n) { return new plt.compiler.localEnv(n, true, env); }\n      function pushGlobals(names, env){ return new plt.compiler.globalEnv(names, false, env); }\n \n      // getClosureVectorAndEnv : (list of Symbols) (list of Symbols) env -> [(Vector of number), env]\n      // take in a list of args, a list of freevars, and an empty env that ONLY includes the arguments\n      function getClosureVectorAndEnv(args, freeVariables, originalEnv){\n        // pull out the stack references for all variables that are free in this environment\n        var freeVariableRefs = freeVariables.map(function(v){return originalEnv.lookup(v.val, 0);}),\n            // some utility functions\n            ormap = function(f, l){return (l.length===0)? false : f(l[0])? l[0] : ormap(f, l.slice(1));},\n            isLocalStackRef   = function(r){return r instanceof localStackReference;},\n            isGlobalStackRef  = function(r){return r instanceof globalStackReference;},\n            isUnboundStackRef = function(r){return r instanceof unboundStackReference;},\n            getDepthFromRef   = function(r){return r.depth;},\n            // this will either be #f, or the first unboundStackRef\n            anyUnboundStackRefs = ormap(isUnboundStackRef, freeVariableRefs);\n        // if any of the references are unbound, freak out!\n        if(anyUnboundStackRefs){\n          throw \"Can't produce closure; I don't know where \" + anyUnboundStackRefs.name + \" is bound.\";\n        // otherwise, compute the depths of all local and global free variables\n        } else {\n          var lexicalFreeRefs   = sortAndUnique(freeVariableRefs.filter(isLocalStackRef),\n                                                function(x,y){return x.depth < y.depth;},\n                                                function(x,y){return x.depth === y.depth;}),\n              lexicalFreeDepths = lexicalFreeRefs.map(getDepthFromRef),\n              globalRefs        = freeVariableRefs.filter(isGlobalStackRef),\n              globalDepths      = sortAndUnique(globalRefs.map(getDepthFromRef),\n                                                function(x,y){return x<y;},\n                                                function(x,y){return x===y;});\n          // Add Function Arguments (in reverse order) to the environment\n          var env1 = args.reverse().map(function(s){return s.val;}).reduce(pushLocal, originalEnv);\n\n          // Add the lexical free variables (in reverse order)\n          var env2 = lexicalFreeRefs.reverse().reduce(function(env, ref){\n                      return ref.isBoxed? pushLocalBoxed(env, ref.name) : pushLocal(env, ref.name);\n                    }, env1);\n\n          // Add the global free variables (in reverse order)\n          var env3 = globalDepths.reverse().reduce(function(env, depth){\n                       var refsAtDepth = globalRefs.filter(function(ref){return ref.depth===depth;}),\n                           usedGlobals = refsAtDepth.map(function(ref){return ref.name}),\n                           newGlobals  = maskUnusedGlobals(originalEnv.peek(depth).names, usedGlobals);\n                       return pushGlobals(newGlobals, env);\n                     }, env2);\n\n          // return a vector of depths (global, then local), along with the environment\n          return [globalDepths.concat(lexicalFreeDepths), env3];\n        }\n      }\n      // push each arg onto an empty Env, the compute the free variables in the function body with that Env\n      var envWithArgs = this.args.map(function(s){return s.val;}).reduce(pushLocal, new plt.compiler.emptyEnv());\n          freeVarsInBody = this.body.freeVariables([], envWithArgs);\n      // compute the closure information using a COPY of the args array (protect against in-place reversal)\n      var closureVectorAndEnv = getClosureVectorAndEnv(this.args.slice(0), freeVarsInBody, env),\n          closureVector = closureVectorAndEnv[0],\n          extendedEnv = closureVectorAndEnv[1];\n      // compile the body using the closure's environent\n      var compiledBodyAndPinfo = this.body.compile(extendedEnv, pinfo),\n          compiledBody = compiledBodyAndPinfo[0],\n          pinfo1 = compiledBodyAndPinfo[1];\n      // emit the bytecode\n      var getLocs = function(id){return id.location.toVector();},\n          bytecode = new lam(isUnnamedLambda? [] : new symbolExpr(name),\n                             [isUnnamedLambda? this.stx:name].concat(this.args).map(getLocs),\n                             [],                                                          // flags\n                             this.args.length,                                            // numParams\n                             this.args.map( function(){ return new symbolExpr(\"val\");}  ),  // paramTypes\n                             false,                                                       // rest\n                             closureVector,                                               // closureMap\n                             closureVector.map(function(){ return new symbolExpr(\"val/ref\"); }  ), // closureTypes\n                             0,                                                           // maxLetDepth\n                             compiledBody);                                               // body\n      return [bytecode, pinfo1];\n   };\n\n   localExpr.prototype.compile = function(env, pinfo){\n     // if there are no definitions, just pull the body out and compile it.\n     if(this.defs.length === 0) return this.body.compile(env, pinfo);\n\n     // Otherwise...\n     // (1) create an environment where all defined names are given local, boxed stackrefs\n     var that = this,\n         definedNames = this.defs.reduce(getDefinedNames, []),\n         pushLocalBoxedFromSym = function(env, sym) { return new plt.compiler.localEnv(sym.val, true, env); },\n         envWithBoxedNames = definedNames.reverse().reduce(pushLocalBoxedFromSym, env);\n \n     // (2) process the definitions, starting with pinfo and our new environment as the base\n     var letVoidBodyAndPinfo = processDefns(this.defs, pinfo, envWithBoxedNames, 0),\n         letVoidBody = letVoidBodyAndPinfo[0],\n         pinfo = letVoidBodyAndPinfo[1];\n \n     // (3) return a new letVoid for the stack depth we require, then use the bytecode as the body\n     return [new letVoid(definedNames.length, true, letVoidBody), pinfo]\n\n     // getDefinedNames : [names], def -> names\n     // given a list of names and a defn, add defined name(s) to the list\n     function getDefinedNames(names, def){\n        return names.concat((def instanceof defVars)? def.names : def.name);\n     }\n \n     // processDefns : [defs], pinfo, numInstalled -> [bytecode, pinfo]\n     // fold-like function that will generate bytecode to install each defn at the\n     // correct stack location , then move on to the rest of the definitions\n     function processDefns(defs, pinfo, env, numInstalled){\n        if(defs.length===0){ return that.body.compile(envWithBoxedNames, pinfo); }\n \n        // compile the first definition in the current environment\n        var compiledDefAndPInfo = defs[0].compile(env, pinfo),\n            compiledRhs         = compiledDefAndPInfo[0].rhs, // important: all we need is the rhs!!\n            pinfo               = compiledDefAndPInfo[1];\n\n        // figure out how much room we'll need on the stack for this defn\n        // compile the rest of the definitions, using the new pinfo and stack size\n        var numToInstall    = (defs[0] instanceof defVars)? defs[0].names.length : 1,\n            newBodyAndPinfo = processDefns(defs.slice(1), pinfo, env, numInstalled+numToInstall)\n            newBody         = newBodyAndPinfo[0],\n            pinfo           = newBodyAndPinfo[1];\n \n       // generate bytecode to install new values for the remaining body\n        var bytecode = new installValue(numToInstall, numInstalled, true, compiledRhs, newBody);\n        return [bytecode, pinfo];\n     }\n   };\n   \n   callExpr.prototype.compile = function(env, pinfo){\n      // add space to the stack for each argument, then build the bytecode for the application itself\n      var makeSpace = function(env, operand){return new plt.compiler.unnamedEnv(env);},\n          extendedEnv = this.args.reduce(makeSpace, env);\n      var compiledOperatorAndPinfo = this.func.compile(extendedEnv, pinfo),\n          compiledOperator = compiledOperatorAndPinfo[0],\n          pinfo1 = compiledOperatorAndPinfo[1];\n      var compiledOperandsAndPinfo = this.args.reduceRight(compilePrograms, [[], pinfo, extendedEnv]),\n          compiledOperands = compiledOperandsAndPinfo[0],\n          pinfo2 = compiledOperatorAndPinfo[1],\n          app = new application(compiledOperator, compiledOperands);\n      // extract the relevant locations for error reporting, then wrap the application in continuation marks\n      var extractLoc= function(e){return e.location;},\n          locs      = [this.func.location].concat(this.args.map(extractLoc)),\n          locVectors= locs.concat(this.location).map(function(loc){return loc.toVector();}),\n          appWithcontMark=new withContMark(new symbolExpr(\"moby-application-position-key\"), locVectors,\n                                           new withContMark(new symbolExpr(\"moby-stack-record-continuation-mark-key\"),\n                                                            this.location.toVector(), app));\n          return [appWithcontMark, pinfo2];\n   };\n   \n   ifExpr.prototype.compile = function(env, pinfo){\n      var compiledPredicateAndPinfo = this.predicate.compile(env, pinfo),\n          compiledPredicate = compiledPredicateAndPinfo[0],\n          pinfo1 = compiledPredicateAndPinfo[1];\n      var compiledConsequenceAndPinfo = this.consequence.compile(env, pinfo),\n          compiledConsequence = compiledConsequenceAndPinfo[0],\n          pinfo2 = compiledConsequenceAndPinfo[1];\n      var compiledAlternateAndPinfo = this.alternative.compile(env, pinfo),\n          compiledAlternate = compiledAlternateAndPinfo[0],\n          pinfo3 = compiledAlternateAndPinfo[1];\n      var bytecode = new branch(compiledPredicate, compiledConsequence, compiledAlternate);\n      return [bytecode, pinfo3];\n   };\n   \n   symbolExpr.prototype.compile = function(env, pinfo){\n     var stackReference = env.lookup(this.val, 0), bytecode;\n      if(stackReference instanceof localStackReference){\n        bytecode = new localRef(stackReference.isBoxed, stackReference.depth, false, false, false);\n      } else if(stackReference instanceof globalStackReference){\n        bytecode = new topLevel(stackReference.depth, stackReference.pos, false, false, this.location);\n      } else if(stackReference instanceof unboundStackReference){\n        throw \"Couldn't find '\"+this.val+\"' in the environment\";\n      } else {\n        throw \"IMPOSSIBLE: env.lookup failed for '\"+this.val+\"'! A reference should be added to the environment!\";\n      }\n      return [bytecode, pinfo];\n   };\n \n   // a quotedExpr is a literal version of the raw stx object\n   quotedExpr.prototype.compile = function(env, pinfo){\n      function unwrapLiterals(v){\n        return (v instanceof literal)? unwrapLiterals(v.val) : (v instanceof Array)? v.map(unwrapLiterals) : v;\n      }\n      result = new literal(unwrapLiterals(this.val));\n      return [result, pinfo];\n   };\n \n   provideStatement.prototype.compile = function(env, pinfo){};\n   requireExpr.prototype.compile = function(env, pinfo){\n     return [new req(this.spec, new topLevel(0, 0, false, false, false)), pinfo];\n   };\n\n   // compile-compilation-top: program pinfo -> bytecode\n   function compileCompilationTop(program, pinfo){\n      // makeModulePrefixAndEnv : pinfo -> [prefix, env]\n      // collect all the free names being defined and used at toplevel\n      // Create a prefix that refers to those values\n      // Create an environment that maps to the prefix\n      function makeModulePrefixAndEnv(pinfo){\n        var requiredModuleBindings = pinfo.modules.reduce(function(acc, m){return acc.concat(m.bindings);}, []),\n            isNotRequiredModuleBinding = function(b){ return b.moduleSource && (requiredModuleBindings.indexOf(b) === -1)},\n            moduleOrTopLevelDefinedBindings = pinfo.usedBindingsHash.values().filter(isNotRequiredModuleBinding),\n \n            allModuleBindings = requiredModuleBindings.concat(moduleOrTopLevelDefinedBindings),\n\n            // utility functions for making globalBuckets and moduleVariables\n            makeGlobalBucket = function(name){ return new globalBucket(name);},\n            modulePathIndexJoin = function(path, base){return new modulePath(path, base);},\n            // Match Moby: if it's a module that was imported via 'require', we treat it differently for some reason (WTF)\n            makeModuleVariablefromBinding = function(b){\n              return new moduleVariable(modulePathIndexJoin(b.moduleSource,\n                                                            (b.imported)? false : modulePathIndexJoin(false, false))\n                                      , new symbolExpr(b.name), -1, 0);\n            };\n        var globalNames = pinfo.freeVariables.concat(pinfo.definedNames.keys()),\n        // FIXME: we have to make uniqueGlobalNames because a function name can also be a free variable,\n        // due to a bug in analyze-lambda-expression in which the base pinfo is used for the function body.\n            uniqueGlobalNames = sortAndUnique(globalNames, function(a,b){return a<b;}, function(a,b){return a==b;}),\n            topLevels         = [false].concat(uniqueGlobalNames.map(makeGlobalBucket)\n                                               ,allModuleBindings.map(makeModuleVariablefromBinding)),\n            globals           = [false].concat(uniqueGlobalNames\n                                               ,allModuleBindings.map(function(b){return b.name;}));\n        return [new prefix(0, topLevels ,[])\n               , new plt.compiler.globalEnv(globals, false, new plt.compiler.emptyEnv())];\n      };\n      // The toplevel is going to include all of the defined identifiers in the pinfo\n      // The environment will refer to elements in the toplevel.\n      var toplevelPrefixAndEnv = makeModulePrefixAndEnv(pinfo),\n          toplevelPrefix = toplevelPrefixAndEnv[0],\n          env = toplevelPrefixAndEnv[1];\n      // pull out separate program components for ordered compilation\n      var defns    = program.filter(plt.compiler.isDefinition),\n          requires = program.filter((function(p){return (p instanceof requireExpr);})),\n          exprs    = program.filter(plt.compiler.isExpression);\n      var compiledRequiresAndPinfo = requires.reduceRight(compilePrograms, [[], pinfo, env]),\n          compiledRequires = compiledRequiresAndPinfo[0],\n          pinfo = compiledRequiresAndPinfo[1];\n      var compiledDefinitionsAndPinfo = defns.reduceRight(compilePrograms, [[], pinfo, env]),\n          compiledDefinitions = compiledDefinitionsAndPinfo[0],\n          pinfo = compiledDefinitionsAndPinfo[1];\n      var compiledExpressionsAndPinfo = exprs.reduceRight(compilePrograms, [[], pinfo, env]),\n          compiledExpressions = compiledExpressionsAndPinfo[0],\n          pinfo = compiledExpressionsAndPinfo[1];\n      // generate the bytecode for the program and return it, along with the program info\n      var forms = new seq([].concat(compiledRequires, compiledDefinitions, compiledExpressions)),\n          zo_bytecode = new compilationTop(0, toplevelPrefix, forms),\n          response = {\"bytecode\" : \"/* runtime-version: local-compiler-summer2014 */\\n\" + zo_bytecode.toBytecode(),\n                      \"permissions\" : pinfo.permissions(),\n                      \"provides\" : pinfo.providedNames.keys()};\n          return response;\n   }\n \n \n  /////////////////////\n  /* Export Bindings */\n  /////////////////////\n  plt.compiler.localStackReference  = localStackReference;\n  plt.compiler.globalStackReference = globalStackReference;\n  plt.compiler.unboundStackReference= unboundStackReference;\n  plt.compiler.compile              = function(program, pinfo, debug){\n      var start = new Date().getTime();\n      try { var response = compileCompilationTop(program, pinfo); }  // do the actual work\n      catch (e) { console.log(\"COMPILATION ERROR\"); throw e; }\n      var end = new Date().getTime();\n      if(debug){\n        console.log(\"Compiled in \"+(Math.floor(end-start))+\"ms\");\n        console.log(JSON.stringify(response));\n      }\n      return response;\n   };\n })();\n\nmodule.exports = plt.compiler;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/compiler.js\n ** module id = 9\n ** module chunks = 0\n **/"],"sourceRoot":""}